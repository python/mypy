-- Test cases for import returned by the native parser using a side channel
-- In particular, test import flags related to reachability and priority when ordering SCCs

[case testNoImport]
# No imports
print()
[out]

[case testSimpleImport]
import foo
[out]
1: import foo

[case testMultipleImports]
import foo
import bar
import baz
[out]
1: import foo
2: import bar
3: import baz

[case testImportAs]
import foo as f
import bar as b
[out]
1: import foo as f
2: import bar as b

[case testFromImport]
from foo import bar
[out]
1: from foo import bar

[case testFromImportMultiple]
from foo import bar, baz, qux
[out]
1: from foo import bar, baz, qux

[case testFromImportAs]
from foo import bar as b, baz as z
[out]
1: from foo import bar as b, baz as z

[case testRelativeImport]
from . import foo
from .. import bar
from ...baz import qux
[out]
1: from . import foo
2: from .. import bar
3: from ...baz import qux

[case testNonTopLevelImport]
def f():
    import foo
    from bar import baz
[out]
2: import foo [not top_level]
3: from bar import baz [not top_level]

[case testMixedTopLevel]
import toplevel
def f():
    import inside_func
import another_toplevel
[out]
1: import toplevel
3: import inside_func [not top_level]
4: import another_toplevel

[case testImportInClass]
class Foo:
    import bar
[out]
2: import bar
[case testUnreachableImportPY2]
# Imports in unreachable blocks should not appear
if PY2:
    import unreachable_module
import reachable_module
[out]
4: import reachable_module

[case testUnreachableFromImportPY2]
# From imports in unreachable blocks should not appear
if PY2:
    from unreachable import foo
from reachable import bar
[out]
4: from reachable import bar

[case testReachableImportPY3]
# Imports in reachable if PY3 blocks should appear
if PY3:
    import reachable_module
[out]
3: import reachable_module

[case testUnreachableElseBlock]
# Imports in unreachable else block should not appear
if PY3:
    import reachable
else:
    import unreachable
[out]
3: import reachable

[case testMixedReachableUnreachable]
# Mix of reachable and unreachable imports
import before
if PY2:
    import unreachable_in_if
else:
    import reachable_in_else
import after
[out]
2: import before
6: import reachable_in_else
7: import after

[case testNestedUnreachable]
# Nested unreachable blocks
if PY2:
    import outer_unreachable
    if True:
        import inner_unreachable
import reachable
[out]
6: import reachable

[case testUnreachableWithTopLevel]
# Unreachable imports are still marked as top_level correctly
def f():
    if PY2:
        import unreachable_func
    import reachable_func
if PY2:
    import unreachable_top
import reachable_top
[out]
5: import reachable_func [not top_level]
8: import reachable_top

[case testVersionCheckUnreachable]
# sys.version_info check makes else unreachable
import sys
if sys.version_info >= (3, 8):
    import reachable_version_check
else:
    import unreachable_old_version
[out]
2: import sys
4: import reachable_version_check

[case testElifUnreachable]
# Elif after always-true condition is unreachable
if PY3:
    import reachable_if
elif True:
    import unreachable_elif
else:
    import unreachable_else
[out]
3: import reachable_if

[case testAllBranchesUnreachable]
# When all branches are unreachable, no imports appear
if PY2:
    import unreachable_if
elif PY2:
    import unreachable_elif
else:
    import reachable_else
[out]
7: import reachable_else

[case testMypyOnlyImport]
# Imports in TYPE_CHECKING blocks are mypy_only
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    import mypy_only_module
import regular_module
[out]
2: from typing import TYPE_CHECKING
4: import mypy_only_module [mypy_only]
5: import regular_module

[case testMypyOnlyFromImport]
# From imports in TYPE_CHECKING blocks are mypy_only
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from mypy_types import MyType
from regular import RegularType
[out]
2: from typing import TYPE_CHECKING
4: from mypy_types import MyType [mypy_only]
5: from regular import RegularType

[case testMypyNameAlias]
# MYPY is also recognized as mypy_only
if MYPY:
    import only_for_mypy
import for_everyone
[out]
3: import only_for_mypy [mypy_only]
4: import for_everyone

[case testMypyOnlyElseBranch]
# Else branch of TYPE_CHECKING is unreachable (runtime-only, not analyzed by mypy)
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    import for_mypy
else:
    import for_runtime
[out]
2: from typing import TYPE_CHECKING
4: import for_mypy [mypy_only]

[case testNestedMypyOnly]
# Nested blocks inside TYPE_CHECKING are also mypy_only
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    if True:
        import deeply_nested
    import also_mypy_only
[out]
2: from typing import TYPE_CHECKING
5: import deeply_nested [mypy_only]
6: import also_mypy_only [mypy_only]

[case testMypyOnlyInFunction]
# Mypy-only imports in functions
from typing import TYPE_CHECKING
def f():
    if TYPE_CHECKING:
        import mypy_func_import
    import regular_func_import
[out]
2: from typing import TYPE_CHECKING
5: import mypy_func_import [not top_level, mypy_only]
6: import regular_func_import [not top_level]

[case testMypyOnlyElifBranch]
# Elif after TYPE_CHECKING is unreachable (runtime-only)
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    import for_mypy
elif True:
    import for_runtime_elif
[out]
2: from typing import TYPE_CHECKING
4: import for_mypy [mypy_only]

[case testNotMypyFalseBranch]
# Not TYPE_CHECKING makes body unreachable, else is mypy_only
from typing import TYPE_CHECKING
if not TYPE_CHECKING:
    import runtime_only
else:
    import mypy_only
[out]
2: from typing import TYPE_CHECKING
6: import mypy_only [mypy_only]

[case testMixedMypyOnlyAndUnreachable]
# Combination of mypy_only and unreachable
from typing import TYPE_CHECKING
if PY2:
    import unreachable_py2
if TYPE_CHECKING:
    import mypy_only_import
if PY3:
    import always_reachable
[out]
2: from typing import TYPE_CHECKING
6: import mypy_only_import [mypy_only]
8: import always_reachable

[case testTypingExtensionsTypeChecking]
# typing_extensions.TYPE_CHECKING is also recognized
from typing_extensions import TYPE_CHECKING
if TYPE_CHECKING:
    import mypy_import
[out]
2: from typing_extensions import TYPE_CHECKING
4: import mypy_import [mypy_only]

[case testUnknownCondition]
# Unknown conditions - all branches reachable
if x:
    import in_if
else:
    import in_else
[out]
3: import in_if
5: import in_else

[case testUnknownConditionWithElif]
# Unknown conditions with elif
if unknown_var:
    import first
elif another_var:
    import second
else:
    import third
[out]
3: import first
5: import second
7: import third

[case testMixedKnownUnknown]
# Mix of known and unknown conditions
if TYPE_CHECKING:
    import mypy_only
if some_var:
    import maybe_reachable
if PY2:
    import unreachable
[out]
3: import mypy_only [mypy_only]
5: import maybe_reachable

[case testNestedUnknownInMypyOnly]
# Unknown condition nested in mypy-only block
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    if condition:
        import nested_mypy
    import also_mypy
[out]
2: from typing import TYPE_CHECKING
5: import nested_mypy [mypy_only]
6: import also_mypy [mypy_only]

[case testUnknownAfterMypyTrue]
# Unknown elif after TYPE_CHECKING is unreachable
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    import for_mypy
elif x:
    import unreachable_elif
[out]
2: from typing import TYPE_CHECKING
4: import for_mypy [mypy_only]

[case testComplexCondition]
# Complex boolean conditions that can't be evaluated
if x and y:
    import complex_if
elif z or w:
    import complex_elif
[out]
3: import complex_if
5: import complex_elif

[case testUnknownWithFunction]
# Unknown condition with function call
if func():
    import from_func_call
import regular
[out]
3: import from_func_call
4: import regular

[case testStarImport]
from foo import *
[out]
1: from foo import *

[case testRelativeStarImport]
from . import *
from ..bar import *
from ...baz import *
[out]
1: from . import *
2: from ..bar import *
3: from ...baz import *

[case testStarImportInFunction]
def f():
    from foo import *
[out]
2: from foo import * [not top_level]

[case testMypyOnlyStarImport]
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from mypy_types import *
from regular import *
[out]
1: from typing import TYPE_CHECKING
3: from mypy_types import * [mypy_only]
4: from regular import *

[case testUnreachableStarImport]
if PY2:
    from unreachable import *
from reachable import *
[out]
3: from reachable import *
