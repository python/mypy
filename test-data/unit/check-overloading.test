-- Test cases for function overloading
[case testOverloadNotImportedNoCrash]
@overload
def f(a): pass
@overload
def f(a): pass
def f(a): pass
f(0)

@overload  # E: Name 'overload' is not defined
def g(a:int): pass
def g(a): pass  # E: Name 'g' already defined
g(0)

@something  # E: Name 'something' is not defined
def r(a:int): pass
def r(a): pass  # E: Name 'r' already defined
r(0)
[out]
main:1: error: Name 'overload' is not defined
main:3: error: Name 'f' already defined
main:3: error: Name 'overload' is not defined
main:5: error: Name 'f' already defined

[case testTypeCheckOverloadWithImplementation]
from typing import overload, Any
@overload
def f(x: 'A') -> 'B': ...
@overload
def f(x: 'B') -> 'A': ...

def f(x: Any) -> Any:
    pass

reveal_type(f(A())) # E: Revealed type is '__main__.B'
reveal_type(f(B())) # E: Revealed type is '__main__.A'

class A: pass
class B: pass
[builtins fixtures/isinstance.pyi]

[case testOverloadNeedsImplementation]
from typing import overload, Any
@overload  # E: An overloaded function outside a stub file must have an implementation
def f(x: 'A') -> 'B': ...
@overload
def f(x: 'B') -> 'A': ...

reveal_type(f(A())) # E: Revealed type is '__main__.B'
reveal_type(f(B())) # E: Revealed type is '__main__.A'

class A: pass
class B: pass
[builtins fixtures/isinstance.pyi]

[case testSingleOverloadNoImplementation]
from typing import overload, Any
@overload  # E: Single overload definition, multiple required
def f(x: 'A') -> 'B': ...

class A: pass
class B: pass
[builtins fixtures/isinstance.pyi]

[case testOverloadByAnyOtherName]
from typing import overload as rose
from typing import Any
@rose
def f(x: 'A') -> 'B': ...
@rose
def f(x: 'B') -> 'A': ...

def f(x: Any) -> Any:
    pass

reveal_type(f(A())) # E: Revealed type is '__main__.B'
reveal_type(f(B())) # E: Revealed type is '__main__.A'

class A: pass
class B: pass
[builtins fixtures/isinstance.pyi]

[case testTypeCheckOverloadWithDecoratedImplementation]
from typing import overload, Any

def deco(fun): ...

@overload
def f(x: 'A') -> 'B': ...
@overload
def f(x: 'B') -> 'A': ...

@deco
def f(x: Any) -> Any:
    pass

reveal_type(f(A())) # E: Revealed type is '__main__.B'
reveal_type(f(B())) # E: Revealed type is '__main__.A'

class A: pass
class B: pass
[builtins fixtures/isinstance.pyi]

[case testOverloadDecoratedImplementationNotLast]
from typing import overload, Any

def deco(fun): ...

@overload
def f(x: 'A') -> 'B': ...

@deco  # E: The implementation for an overloaded function must come last
def f(x: Any) -> Any:
    pass

@overload
def f(x: 'B') -> 'A': ...

class A: pass
class B: pass
[builtins fixtures/isinstance.pyi]

[case testOverloadImplementationNotLast]
from typing import overload, Any

@overload
def f(x: 'A') -> 'B': ...

def f(x: Any) -> Any:  # E: The implementation for an overloaded function must come last
    pass

@overload
def f(x: 'B') -> 'A': ...

class A: pass
class B: pass
[builtins fixtures/isinstance.pyi]

[case testDecoratedRedefinitionIsNotOverload]
from typing import overload, Any

def deco(fun): ...

@deco
def f(x: 'A') -> 'B': ...
@deco  # E: Name 'f' already defined
def f(x: 'B') -> 'A': ...
@deco  # E: Name 'f' already defined
def f(x: Any) -> Any: ...

class A: pass
class B: pass
[builtins fixtures/isinstance.pyi]

[case testTypeCheckOverloadWithImplementationPy2]
# flags: --python-version 2.7

from typing import overload
@overload
def f(x):
    # type: (A) -> B
    pass

@overload
def f(x):
    # type: (B) -> A
    pass

def f(x):
    pass

reveal_type(f(A()))  # E: Revealed type is '__main__.B'
reveal_type(f(B()))  # E: Revealed type is '__main__.A'

class A: pass
class B: pass
[builtins fixtures/isinstance.pyi]

[case testTypeCheckOverloadWithImplementationError]
from typing import overload, Any

@overload
def f(x: 'A') -> 'B': ...
@overload
def f(x: 'B') -> 'A': ...

def f(x: Any) -> Any:
    foo = 1
    foo = "bar"  # E: Incompatible types in assignment (expression has type "str", variable has type "int")

@overload
def g(x: 'A') -> 'B': ...
@overload
def g(x: 'B') -> 'A': ...

def g(x):
    foo = 1
    foo = "bar"

reveal_type(f(A()))  # E: Revealed type is '__main__.B'
reveal_type(f(B()))  # E: Revealed type is '__main__.A'

class A: pass
class B: pass
[builtins fixtures/isinstance.pyi]

[case testTypeCheckOverloadWithImplTooSpecificArg]
from typing import overload, Any

class A: pass
class B: pass

a = A()

@overload
def f(x: 'A') -> 'B': ...
@overload
def f(x: 'B') -> 'A': ...

def f(x: 'A') -> Any: # E: Overloaded function implementation does not accept all possible arguments of signature 2
    pass

reveal_type(f(A())) # E: Revealed type is '__main__.B'
reveal_type(f(B())) # E: Revealed type is '__main__.A'

[builtins fixtures/isinstance.pyi]

[case testTypeCheckOverloadWithImplTooSpecificRetType]
from typing import overload, Any

class A: pass
class B: pass

a = A()

@overload
def f(x: 'A') -> 'B': ...
@overload
def f(x: 'B') -> 'A': ...

def f(x: Any) -> 'B': # E: Overloaded function implementation cannot produce return type of signature 2
    return B()

reveal_type(f(A())) # E: Revealed type is '__main__.B'
reveal_type(f(B())) # E: Revealed type is '__main__.A'

[builtins fixtures/isinstance.pyi]

[case testTypeCheckOverloadWithImplTypeVar]
from typing import overload, Any, TypeVar

T = TypeVar('T')

class A: pass
class B: pass

a = A()

@overload
def f(x: 'A') -> 'A': ...
@overload
def f(x: 'B') -> 'B': ...

def f(x: T) -> T:
    ...

reveal_type(f(A())) # E: Revealed type is '__main__.A'
reveal_type(f(B())) # E: Revealed type is '__main__.B'

[builtins fixtures/isinstance.pyi]

[case testTypeCheckOverloadWithImplTypeVarProblems]
from typing import overload, Any, TypeVar

T = TypeVar('T', bound='A')

class A: pass
class B: pass

a = A()

@overload
def f(x: 'A') -> 'A': ...
@overload
def f(x: 'B') -> 'B': ...

def f(x: Any) -> T:  # E: Type variable mismatch between overload signature 2 and implementation
    ...

reveal_type(f(A())) # E: Revealed type is '__main__.A'
reveal_type(f(B())) # E: Revealed type is '__main__.B'

[builtins fixtures/isinstance.pyi]

[case testTypeCheckOverloadedFunctionBody]
from foo import *
[file foo.pyi]
from typing import overload
@overload
def f(x: 'A'):
    x = B() # E: Incompatible types in assignment (expression has type "B", variable has type "A")
    x = A()
@overload
def f(x: 'B'):
    x = A() # E: Incompatible types in assignment (expression has type "A", variable has type "B")
    x = B()
class A: pass
class B: pass
[out]

[case testTypeCheckOverloadedMethodBody]
from foo import *
[file foo.pyi]
from typing import overload
class A:
    @overload
    def f(self, x: 'A'):
        x = B() # E: Incompatible types in assignment (expression has type "B", variable has type "A")
        x = A()
    @overload
    def f(self, x: 'B'):
        x = A() # E: Incompatible types in assignment (expression has type "A", variable has type "B")
        x = B()
class B: pass
[out]

[case testCallToOverloadedFunction]
from foo import *
[file foo.pyi]
from typing import overload
f(C()) # E: No overload variant of "f" matches argument type "C"
f(A())
f(B())

@overload
def f(x: 'A') -> None: pass
@overload
def f(x: 'B') -> None: pass

class A: pass
class B: pass
class C: pass

[case testOverloadedFunctionReturnValue]
from foo import *
[file foo.pyi]
from typing import overload
a, b = None, None # type: (A, B)
b = f(a) # E: Incompatible types in assignment (expression has type "A", variable has type "B")
a = f(b) # E: Incompatible types in assignment (expression has type "B", variable has type "A")
a = f(a)
b = f(b)

@overload
def f(x: 'A') -> 'A': pass
@overload
def f(x: 'B') -> 'B': pass
class A: pass
class B: pass

[case testCallToOverloadedMethod]
from foo import *
[file foo.pyi]
from typing import overload
A().f(C()) # E: No overload variant of "f" of "A" matches argument type "C"
A().f(A())
A().f(B())

class A:
  @overload
  def f(self, x: 'A') -> None: pass
  @overload
  def f(self, x: 'B') -> None: pass

class B: pass
class C: pass

[case testOverloadedMethodReturnValue]
from foo import *
[file foo.pyi]
from typing import overload
a, b = None, None # type: (A, B)
b = a.f(a) # E: Incompatible types in assignment (expression has type "A", variable has type "B")
a = a.f(b) # E: Incompatible types in assignment (expression has type "B", variable has type "A")
a = a.f(a)
b = a.f(b)

class A:
  @overload
  def f(self, x: 'A') -> 'A': pass
  @overload
  def f(self, x: 'B') -> 'B': pass
class B: pass

[case testOverloadsWithDifferentArgumentCounts]
from foo import *
[file foo.pyi]
from typing import overload
a, b = None, None # type: (A, B)
a = f(a)
b = f(a) # E: Incompatible types in assignment (expression has type "A", variable has type "B")
f(b)     # E: No overload variant of "f" matches argument type "B"
b = f(b, a)
a = f(b, a) # E: Incompatible types in assignment (expression has type "B", variable has type "A")
f(a, a)     # E: No overload variant of "f" matches argument types "A", "A"
f(b, b)     # E: No overload variant of "f" matches argument types "B", "B"

@overload
def f(x: 'A') -> 'A': pass
@overload
def f(x: 'B', y: 'A') -> 'B': pass
class A: pass
class B: pass

[case testGenericOverloadVariant]
from foo import *
[file foo.pyi]
from typing import overload, TypeVar, Generic
t = TypeVar('t')
ab, ac, b, c = None, None, None, None # type: (A[B], A[C], B, C)
b = f(ab)
c = f(ac)
b = f(ac) # E: Incompatible types in assignment (expression has type "C", variable has type "B")
b = f(b)
c = f(b)  # E: Incompatible types in assignment (expression has type "B", variable has type "C")
@overload
def f(x: 'A[t]') -> t: pass
@overload
def f(x: 'B') -> 'B': pass
class A(Generic[t]): pass
class B: pass
class C: pass

[case testOverloadedInit]
from foo import *
[file foo.pyi]
from typing import overload
a, b = None, None # type: (A, B)
a = A(a)
a = A(b)
a = A(object()) # E: No overload variant of "A" matches argument type "object"

class A:
  @overload
  def __init__(self, a: 'A') -> None: pass
  @overload
  def __init__(self, b: 'B') -> None: pass
class B: pass

[case testIntersectionTypeCompatibility]
from foo import *
[file foo.pyi]
from typing import overload, Callable
o = None # type: object
a = None # type: A

a = f # E: Incompatible types in assignment (expression has type overloaded function, variable has type "A")
o = f

@overload
def f(a: 'A') -> None: pass
@overload
def f(a: Callable[[], None]) -> None: pass
class A: pass

[case testCompatibilityOfIntersectionTypeObjectWithStdType]
from foo import *
[file foo.pyi]
from typing import overload
t, a = None, None # type: (type, A)

a = A # E: Incompatible types in assignment (expression has type "Type[A]", variable has type "A")
t = A

class A:
    @overload
    def __init__(self, a: 'A') -> None: pass
    @overload
    def __init__(self, a: 'B') -> None: pass
class B: pass

[case testOverloadedGetitem]
from foo import *
[file foo.pyi]
from typing import overload
a, b = None, None # type: int, str
a = A()[a]
b = A()[a] # E: Incompatible types in assignment (expression has type "int", variable has type "str")
b = A()[b]
a = A()[b] # E: Incompatible types in assignment (expression has type "str", variable has type "int")

class A:
    @overload
    def __getitem__(self, a: int) -> int: pass
    @overload
    def __getitem__(self, b: str) -> str: pass

[case testOverloadedGetitemWithGenerics]
from foo import *
[file foo.pyi]
from typing import TypeVar, Generic, overload
t = TypeVar('t')
a, b, c = None, None, None # type: (A, B, C[A])
a = c[a]
b = c[a] # E: Incompatible types in assignment (expression has type "A", variable has type "B")
a = c[b]
b = c[b] # E: Incompatible types in assignment (expression has type "A", variable has type "B")

class C(Generic[t]):
    @overload
    def __getitem__(self, a: 'A') -> t: pass
    @overload
    def __getitem__(self, b: 'B') -> t: pass
class A: pass
class B: pass

[case testImplementingOverloadedMethod]
from foo import *
[file foo.pyi]
from typing import overload
from abc import abstractmethod, ABCMeta

class I(metaclass=ABCMeta):
    @overload
    @abstractmethod
    def f(self) -> None: pass
    @overload
    @abstractmethod
    def f(self, a: 'A') -> None: pass
class A(I):
    @overload
    def f(self) -> None: pass
    @overload
    def f(self, a: 'A') -> None: pass

[case testOverloadWithFunctionType]
from foo import *
[file foo.pyi]
from typing import overload, Callable
class A: pass
@overload
def f(x: A) -> None: pass
@overload
def f(x: Callable[[], None]) -> None: pass

f(A())
[builtins fixtures/function.pyi]

[case testVarArgsOverload]
from foo import *
[file foo.pyi]
from typing import overload, Any
@overload
def f(x: 'A', *more: Any) -> 'A': pass
@overload
def f(x: 'B', *more: Any) -> 'A': pass
f(A())
f(A(), A, A)
f(B())
f(B(), B)
f(B(), B, B)
f(object()) # E: No overload variant of "f" matches argument type "object"
class A: pass
class B: pass
[builtins fixtures/list.pyi]

[case testVarArgsOverload2]
from foo import *
[file foo.pyi]
from typing import overload
@overload
def f(x: 'A', *more: 'B') -> 'A': pass
@overload
def f(x: 'B', *more: 'A') -> 'A': pass
f(A(), B())
f(A(), B(), B())
f(A(), A(), B()) # E: No overload variant of "f" matches argument types "A", "A", "B"
f(A(), B(), A()) # E: No overload variant of "f" matches argument types "A", "B", "A"
class A: pass
class B: pass
[builtins fixtures/list.pyi]

[case testOverloadWithTypeObject]
from foo import *
[file foo.pyi]
from typing import overload
@overload
def f(a: 'A', t: type) -> None: pass
@overload
def f(a: 'B', t: type) -> None: pass
f(A(), B)
f(B(), A)
class A: pass
class B: pass
[builtins fixtures/function.pyi]

[case testOverloadedInitAndTypeObjectInOverload]
from foo import *
[file foo.pyi]
from typing import overload
@overload
def f(t: type) -> 'A': pass
@overload
def f(t: 'A') -> 'B': pass
a, b = None, None # type: (A, B)
a = f(A)
b = f(a)
b = f(A) # E: Incompatible types in assignment (expression has type "A", variable has type "B")
a = f(a) # E: Incompatible types in assignment (expression has type "B", variable has type "A")
class A:
   @overload
   def __init__(self) -> None: pass
   @overload
   def __init__(self, a: 'A') -> None: pass
class B:
    pass

[case testOverlappingErasedSignatures]
from foo import *
[file foo.pyi]
from typing import overload, List
@overload
def f(a: List[int]) -> int: pass
@overload
def f(a: List[str]) -> int: pass
list_int = [] # type: List[int]
list_str = [] # type: List[str]
list_object = [] # type: List[object]
n = f(list_int)
m = f(list_str)
n = 1
m = 1
n = 'x' # E: Incompatible types in assignment (expression has type "str", variable has type "int")
m = 'x' # E: Incompatible types in assignment (expression has type "str", variable has type "int")
f(list_object) # E: Argument 1 to "f" has incompatible type "List[object]"; expected "List[int]"
[builtins fixtures/list.pyi]

[case testOverlappingOverloadSignatures]
from foo import *
[file foo.pyi]
from typing import overload
class A: pass
class B(A): pass
@overload
def f(x: B) -> int: pass # E: Overloaded function signatures 1 and 2 overlap with incompatible return types
@overload
def f(x: A) -> str: pass

[case testContravariantOverlappingOverloadSignatures]
from foo import *
[file foo.pyi]
from typing import overload
class A: pass
class B(A): pass
@overload
def f(x: A) -> A: pass
@overload
def f(x: B) -> B: pass   # E: Overloaded function signature 2 will never be matched: signature 1's parameter type(s) are the same or broader

[case testPartiallyCovariantOverlappingOverloadSignatures]
from foo import *
[file foo.pyi]
from typing import overload
class A: pass
class B(A): pass
@overload
def f(x: B) -> A: pass # E: Overloaded function signatures 1 and 2 overlap with incompatible return types
@overload
def f(x: A) -> B: pass

[case testPartiallyContravariantOverloadSignatures]
from foo import *
[file foo.pyi]
from typing import overload
class A: pass
class B(A): pass
@overload
def g(x: A) -> int: pass
@overload
def g(x: B) -> str: pass  # E: Overloaded function signature 2 will never be matched: signature 1's parameter type(s) are the same or broader

[case testCovariantOverlappingOverloadSignatures]
from foo import *
[file foo.pyi]
from typing import overload
class A: pass
class B(A): pass
@overload
def g(x: B) -> B: pass
@overload
def g(x: A) -> A: pass

[case testCovariantOverlappingOverloadSignaturesWithSomeSameArgTypes]
from foo import *
[file foo.pyi]
from typing import overload
class A: pass
class B(A): pass
@overload
def g(x: int, y: B) -> B: pass
@overload
def g(x: int, y: A) -> A: pass

[case testCovariantOverlappingOverloadSignaturesWithAnyType]
from foo import *
[file foo.pyi]
from typing import Any, overload
@overload
def g(x: int) -> int: pass
@overload
def g(x: Any) -> Any: pass

[case testContravariantOverlappingOverloadSignaturesWithAnyType]
from foo import *
[file foo.pyi]
from typing import Any, overload
@overload
def g(x: Any) -> Any: pass
@overload
def g(x: int) -> int: pass  # E: Overloaded function signature 2 will never be matched: signature 1's parameter type(s) are the same or broader

[case testOverloadedLtAndGtMethods]
from foo import *
[file foo.pyi]
from typing import overload
class A:
    def __lt__(self, x: A) -> int: pass
    def __gt__(self, x: A) -> int: pass
class B:
    @overload
    def __lt__(self, x: B) -> int: pass
    @overload
    def __lt__(self, x: A) -> int: pass
    @overload
    def __gt__(self, x: B) -> int: pass
    @overload
    def __gt__(self, x: A) -> int: pass
A() < A()
A() < B()
B() < A()
B() < B()
A() < object() # E: Unsupported operand types for < ("A" and "object")
B() < object() # E: No overload variant of "__lt__" of "B" matches argument type "object"

[case testOverloadedForwardMethodAndCallingReverseMethod]
from foo import *
[file foo.pyi]
from typing import overload
class A:
    @overload
    def __add__(self, x: 'A') -> int: pass
    @overload
    def __add__(self, x: int) -> int: pass
class B:
    def __radd__(self, x: A) -> int: pass
A() + A()
A() + 1
A() + B()
A() + '' # E: No overload variant of "__add__" of "A" matches argument type "str"

[case testOverrideOverloadedMethodWithMoreGeneralArgumentTypes]
from foo import *
[file foo.pyi]
from typing import overload

class IntSub(int): pass

class StrSub(str): pass
class A:
    @overload
    def f(self, x: IntSub) -> int: return 0
    @overload
    def f(self, x: StrSub) -> str: return ''
class B(A):
    @overload
    def f(self, x: int) -> int: return 0
    @overload
    def f(self, x: str) -> str: return ''
[out]

[case testOverrideOverloadedMethodWithMoreSpecificArgumentTypes]
from foo import *
[file foo.pyi]
from typing import overload

class IntSub(int): pass

class StrSub(str): pass
class A:
    @overload
    def f(self, x: int) -> int: return 0
    @overload
    def f(self, x: str) -> str: return ''
class B(A):
    @overload
    def f(self, x: IntSub) -> int: return 0
    @overload
    def f(self, x: str) -> str: return ''
class C(A):
    @overload
    def f(self, x: int) -> int: return 0
    @overload
    def f(self, x: StrSub) -> str: return ''
class D(A):
    @overload
    def f(self, x: int) -> int: return 0
    @overload
    def f(self, x: str) -> str: return ''
[out]
tmp/foo.pyi:12: error: Signature of "f" incompatible with supertype "A"
tmp/foo.pyi:17: error: Signature of "f" incompatible with supertype "A"

[case testOverloadingAndDucktypeCompatibility]
from foo import *
[file foo.pyi]
from typing import overload, _promote

class A: pass

@_promote(A)
class B: pass

@overload
def f(n: B) -> B:
    return n
@overload
def f(n: A) -> A:
    return n

f(B()) + 'x'  # E: Unsupported left operand type for + ("B")
f(A()) + 'x'  # E: Unsupported left operand type for + ("A")

[case testOverloadingAndIntFloatSubtyping]
from foo import *
[file foo.pyi]
from typing import overload
@overload
def f(x: float) -> None: pass
@overload
def f(x: str) -> None: pass
f(1.1)
f('')
f(1)
f(()) # E: No overload variant of "f" matches argument type "Tuple[]"
[builtins fixtures/primitives.pyi]
[out]

[case testOverloadingVariableInputs]
from foo import *
[file foo.pyi]
from typing import overload
@overload
def f(x: int, y: int) -> None: pass
@overload
def f(x: int) -> None: pass
f(1)
f(1, 2)
z = (1, 2)
f(*z)
[builtins fixtures/primitives.pyi]
[out]

[case testTypeInferenceSpecialCaseWithOverloading]
from foo import *
[file foo.pyi]
from typing import overload

class A:
    def __add__(self, x: A) -> A: pass
class B:
    def __radd__(self, x: A) -> B: pass

@overload
def f(x: A) -> A: pass
@overload
def f(x: B) -> B: pass

f(A() + B())() # E: "B" not callable

[case testKeywordArgOverload]
from foo import *
[file foo.pyi]
from typing import overload
@overload
def f(x: int, y: str) -> int: pass
@overload
def f(x: str, y: int) -> str: pass
f(x=1, y='')() # E: "int" not callable
f(y=1, x='')() # E: "str" not callable

[case testIgnoreOverloadVariantBasedOnKeywordArg]
from foo import *
[file foo.pyi]
from typing import overload
@overload
def f(x: int) -> int: pass
@overload
def f(y: int) -> str: pass
f(x=1)() # E: "int" not callable
f(y=1)() # E: "str" not callable

[case testOverloadWithTupleVarArg]
from foo import *
[file foo.pyi]
from typing import overload
@overload
def f(x: int, y: str) -> int: pass
@overload
def f(*x: str) -> str: pass
f(*(1,))() # E: No overload variant of "f" matches argument type "Tuple[int]"
f(*('',))() # E: "str" not callable
f(*(1, ''))() # E: "int" not callable
f(*(1, '', 1))() # E: No overload variant of "f" matches argument type "Tuple[int, str, int]"

[case testPreferExactSignatureMatchInOverload]
from foo import *
[file foo.pyi]
from typing import overload, List
@overload
def f(x: int, y: List[int] = None) -> int: pass
@overload
def f(x: int, y: List[str] = None) -> int: pass
f(y=[1], x=0)() # E: "int" not callable
f(y=[''], x=0)() # E: "int" not callable
a = f(y=[['']], x=0) # E: List item 0 has incompatible type "List[str]"; expected "int"
reveal_type(a)  # E: Revealed type is 'builtins.int'
[builtins fixtures/list.pyi]

[case testOverloadWithDerivedFromAny]
from foo import *
[file foo.pyi]
from typing import Any, overload
Base = None  # type: Any

class C:
    @overload
    def __init__(self, a: str) -> None: pass
    @overload
    def __init__(self, a: int) -> None: pass

class Derived(Base):
    def to_dict(self) -> C:
        return C(self)  # fails without the fix for #1363
C(Derived())  # fails without the hack
C(Base())  # Always ok

[case testOverloadWithBoundedTypeVar]
from foo import *
[file foo.pyi]
from typing import overload, TypeVar
T = TypeVar('T', bound=str)
@overload
def f(x: T) -> T: pass
@overload
def f(x: int) -> bool: pass
class mystr(str): pass

f('x')() # E: "str" not callable
f(1)() # E: "bool" not callable
f(1.1) # E: No overload variant of "f" matches argument type "float"
f(mystr())() # E: "mystr" not callable
[builtins fixtures/primitives.pyi]

[case testOverloadedCallWithVariableTypes]
from foo import *
[file foo.pyi]
from typing import overload, TypeVar, List
T = TypeVar('T', bound=str)
@overload
def f(x: T) -> T: pass
@overload
def f(x: List[T]) -> None: pass
class mystr(str): pass

U = TypeVar('U', bound=mystr)
V = TypeVar('V')
def g(x: U, y: V) -> None:
    f(x)() # E: "mystr" not callable
    f(y) # E: No overload variant of "f" matches argument type "V"
    a = f([x]) # E: "f" does not return a value
    f([y]) # E: Value of type variable "T" of "f" cannot be "V"
    f([x, y]) # E: Value of type variable "T" of "f" cannot be "object"
[builtins fixtures/list.pyi]
[out]

[case testOverloadOverlapWithTypeVars]
from foo import *
[file foo.pyi]
from typing import overload, TypeVar, Sequence, List
T = TypeVar('T', bound=str)
@overload
def f(x: Sequence[T]) -> None: pass
@overload
def f(x: Sequence[int]) -> int: pass

@overload
def g(x: Sequence[T]) -> None: pass
@overload
def g(x: Sequence[str]) -> int: pass  # E: Overloaded function signature 2 will never be matched: signature 1's parameter type(s) are the same or broader

@overload
def h(x: Sequence[str]) -> int: pass
@overload
def h(x: Sequence[T]) -> None: pass  # E: Overloaded function signature 2 will never be matched: signature 1's parameter type(s) are the same or broader

@overload
def i(x: List[str]) -> int: pass  # E: Overloaded function signatures 1 and 2 overlap with incompatible return types
@overload
def i(x: List[T]) -> None: pass
[builtins fixtures/list.pyi]


[case testOverlapWithTypeVarsWithValues]
from foo import *
[file foo.pyi]
from typing import overload, TypeVar
AnyStr = TypeVar('AnyStr', bytes, str)

@overload
def f(x: int) -> int: pass
@overload
def f(x: AnyStr) -> str: pass

f(1)() # E: "int" not callable
f('1')() # E: "str" not callable
f(b'1')() # E: "str" not callable
f(1.0) # E: No overload variant of "f" matches argument type "float"

@overload
def g(x: AnyStr, *a: AnyStr) -> None: pass
@overload
def g(x: int, *a: AnyStr) -> None: pass

g('foo')
g('foo', 'bar')
g('foo', b'bar') # E: Value of type variable "AnyStr" of "g" cannot be "object"
g(1)
g(1, 'foo')
g(1, 'foo', b'bar') # E: Value of type variable "AnyStr" of "g" cannot be "object"
[builtins fixtures/primitives.pyi]

[case testOverloadOverlapWithTypeVarsWithValuesOrdering]
from foo import *
[file foo.pyi]
from typing import overload, TypeVar
AnyStr = TypeVar('AnyStr', bytes, str)

@overload
def f(x: AnyStr) -> AnyStr: pass
@overload
def f(x: str) -> str: pass  # E: Overloaded function signature 2 will never be matched: signature 1's parameter type(s) are the same or broader

@overload
def g(x: str) -> str: pass
@overload
def g(x: AnyStr) -> AnyStr: pass
[builtins fixtures/primitives.pyi]

[case testOverloadsUsingAny]
from typing import overload, List, Any, Union

@overload
def foo(x: List[int]) -> int: ...
@overload
def foo(x: List[str]) -> str: ...
def foo(x): pass

a: List[int]
b: List[str]
c: List[Any]
d: Union[List[int], List[str]]
e: List[bool]
f: List[object]
g: List[Union[int, str]]

reveal_type(foo(a))
reveal_type(foo(b))
reveal_type(foo(c))
reveal_type(foo(d))
foo(e)
foo(f)
foo(g)

[builtins fixtures/list.pyi]
[out]
main:17: error: Revealed type is 'builtins.int'
main:18: error: Revealed type is 'builtins.str'
main:19: error: Revealed type is 'Any'
main:20: error: Revealed type is 'Union[builtins.int, builtins.str]'
main:21: error: Argument 1 to "foo" has incompatible type "List[bool]"; expected "List[int]"
main:21: note: "List" is invariant -- see http://mypy.readthedocs.io/en/latest/common_issues.html#variance
main:21: note: Consider using "Sequence" instead, which is covariant
main:22: error: Argument 1 to "foo" has incompatible type "List[object]"; expected "List[int]"
main:23: error: Argument 1 to "foo" has incompatible type "List[Union[int, str]]"; expected "List[int]"

[case testOverlappingOverloadCounting]
from foo import *
[file foo.pyi]
from typing import overload
class A: pass
class B(A): pass
@overload
def f(x: int) -> None: pass
@overload
def f(x: B) -> str: pass # E: Overloaded function signatures 2 and 3 overlap with incompatible return types
@overload
def f(x: A) -> int: pass

[case testOverloadWithTupleMatchingTypeVar]
from foo import *
[file foo.pyi]
from typing import TypeVar, Generic, Tuple, overload

T = TypeVar('T')

class A(Generic[T]):
    @overload
    def f(self, arg: T) -> None:
        pass
    @overload
    def f(self, arg: T, default: int) -> None:
        pass

b = A()  # type: A[Tuple[int, int]]
b.f((0, 0))
b.f((0, '')) # E: Argument 1 to "f" of "A" has incompatible type "Tuple[int, str]"; expected "Tuple[int, int]"

[case testSingleOverloadStub]
from foo import *
[file foo.pyi]
from typing import overload
@overload
def f(a: int) -> None: pass
def f(a: int) -> None: pass
[out]
tmp/foo.pyi:2: error: Single overload definition, multiple required
tmp/foo.pyi:4: error: An implementation for an overloaded function is not allowed in a stub file

[case testSingleOverload2]
from foo import *
[file foo.pyi]
from typing import overload
def f(a: int) -> None: pass
@overload
def f(a: str) -> None: pass
[out]
tmp/foo.pyi:3: error: Name 'f' already defined
tmp/foo.pyi:3: error: Single overload definition, multiple required

[case testNonconsecutiveOverloads]
from foo import *
[file foo.pyi]
from typing import overload
@overload
def f(a: int) -> None: pass
1
@overload
def f(a: str) -> None: pass
[out]
tmp/foo.pyi:2: error: Single overload definition, multiple required
tmp/foo.pyi:5: error: Name 'f' already defined
tmp/foo.pyi:5: error: Single overload definition, multiple required

[case testNonconsecutiveOverloadsMissingFirstOverload]
from foo import *
[file foo.pyi]
from typing import overload
def f(a: int) -> None: pass
1
@overload
def f(a: str) -> None: pass
[out]
tmp/foo.pyi:4: error: Name 'f' already defined
tmp/foo.pyi:4: error: Single overload definition, multiple required

[case testNonconsecutiveOverloadsMissingLaterOverload]
from foo import *
[file foo.pyi]
from typing import overload
@overload
def f(a: int) -> None: pass
1
def f(a: str) -> None: pass
[out]
tmp/foo.pyi:2: error: Single overload definition, multiple required
tmp/foo.pyi:5: error: Name 'f' already defined on line 2

[case testOverloadTuple]
from foo import *
[file foo.pyi]
from typing import overload, Tuple
@overload
def f(x: int, y: Tuple[str, ...]) -> None: pass
@overload
def f(x: int, y: str) -> None: pass
f(1, ('2', '3'))
f(1, (2, '3')) # E: Argument 2 to "f" has incompatible type "Tuple[int, str]"; expected "Tuple[str, ...]"
f(1, ('2',))
f(1, '2')
f(1, (2, 3)) # E: Argument 2 to "f" has incompatible type "Tuple[int, int]"; expected "Tuple[str, ...]"
x = ('2', '3')  # type: Tuple[str, ...]
f(1, x)
y = (2, 3)  # type: Tuple[int, ...]
f(1, y) # E: Argument 2 to "f" has incompatible type "Tuple[int, ...]"; expected "Tuple[str, ...]"
[builtins fixtures/tuple.pyi]

[case testCallableSpecificOverload]
from foo import *
[file foo.pyi]
from typing import overload, Callable
@overload
def f(a: Callable[[], int]) -> None: pass
@overload
def f(a: str) -> None: pass
f(0)  # E: No overload variant of "f" matches argument type "int"

[case testCustomRedefinitionDecorator]
from typing import Any, Callable, Type

class Chain(object):
    def chain(self, function: Callable[[Any], int]) -> 'Chain':
        return self

class Test(object):
    do_chain = Chain()

    @do_chain.chain
    def do_chain(self) -> int:
        return 2

    @do_chain.chain  # E: Name 'do_chain' already defined
    def do_chain(self) -> int:
        return 3

t = Test()
reveal_type(t.do_chain)  # E: Revealed type is '__main__.Chain'

[case testOverloadWithOverlappingItemsAndAnyArgument1]
from typing import overload, Any

@overload
def f(x: int) -> int: ...
@overload
def f(x: object) -> object: ...
def f(x): pass

a: Any
reveal_type(f(a))  # E: Revealed type is 'Any'

[case testOverloadWithOverlappingItemsAndAnyArgument2]
from typing import overload, Any

@overload
def f(x: int) -> int: ...
@overload
def f(x: float) -> float: ...
def f(x): pass

a: Any
reveal_type(f(a))  # E: Revealed type is 'Any'

[case testOverloadWithOverlappingItemsAndAnyArgument3]
from typing import overload, Any

@overload
def f(x: int) -> int: ...
@overload
def f(x: str) -> str: ...
def f(x): pass

a: Any
reveal_type(f(a))  # E: Revealed type is 'Any'

[case testOverloadWithOverlappingItemsAndAnyArgument4]
from typing import overload, Any

@overload
def f(x: int, y: int, z: str) -> int: ...
@overload
def f(x: object, y: int, z: str) -> object: ...
def f(x): pass

a: Any
# Any causes ambiguity
reveal_type(f(a, 1, ''))  # E: Revealed type is 'Any'
# Any causes no ambiguity
reveal_type(f(1, a, a))  # E: Revealed type is 'builtins.int'
reveal_type(f('', a, a))  # E: Revealed type is 'builtins.object'
# Like above, but use keyword arguments.
reveal_type(f(y=1, z='', x=a))  # E: Revealed type is 'Any'
reveal_type(f(y=a, z='', x=1))  # E: Revealed type is 'builtins.int'
reveal_type(f(z='', x=1, y=a))  # E: Revealed type is 'builtins.int'
reveal_type(f(z='', x=a, y=1))  # E: Revealed type is 'Any'

[case testOverloadWithOverlappingItemsAndAnyArgument5]
from typing import overload, Any, Union

@overload
def f(x: int) -> int: ...
@overload
def f(x: Union[int, float]) -> float: ...
def f(x): pass

a: Any
reveal_type(f(a))  # E: Revealed type is 'Any'

[case testOverloadWithOverlappingItemsAndAnyArgument6]
from typing import overload, Any

@overload
def f(x: int, y: int) -> int: ...
@overload
def f(x: float, y: int, z: str) -> float: ...
@overload
def f(x: object, y: int, z: str, a: None) -> object: ...
def f(x): pass

a: Any
# Any causes ambiguity
reveal_type(f(*a))  # E: Revealed type is 'Any'
reveal_type(f(a, *a))  # E: Revealed type is 'Any'
reveal_type(f(1, *a))  # E: Revealed type is 'Any'
reveal_type(f(1.1, *a))  # E: Revealed type is 'Any'
reveal_type(f('', *a))  # E: Revealed type is 'builtins.object'

[case testOverloadWithOverlappingItemsAndAnyArgument7]
from typing import overload, Any

@overload
def f(x: int, y: int, z: int) -> int: ...
@overload
def f(x: object, y: int, z: int) -> object: ...
def f(x): pass

a: Any
# TODO: We could infer 'int' here
reveal_type(f(1, *a))  # E: Revealed type is 'Any'

[case testOverloadWithOverlappingItemsAndAnyArgument8]
from typing import overload, Any

@overload
def f(x: int, y: int, z: int) -> str: ...
@overload
def f(x: object, y: int, z: int) -> str: ...
def f(x): pass

a: Any
# The return type is not ambiguous so Any arguments cause no ambiguity.
reveal_type(f(a, 1, 1)) # E: Revealed type is 'builtins.str'
reveal_type(f(1, *a))  # E: Revealed type is 'builtins.str'

[case testOverloadOnOverloadWithType]
from typing import Any, Type, TypeVar, overload
from mod import MyInt
T = TypeVar('T')

@overload
def make(cls: Type[T]) -> T: pass
@overload
def make() -> Any: pass

def make(*args):
    pass

c = make(MyInt)
reveal_type(c) # E: Revealed type is 'mod.MyInt*'

[file mod.pyi]
from typing import overload
class MyInt:
    @overload
    def __init__(self, x: str) -> None: pass
    @overload
    def __init__(self, x: str, y: int) -> None: pass
[out]

[case testOverloadTupleInstance]
from typing import overload, Tuple, Any

class A: ...
class A1(A): ...
class B: ...
class C: ...
class D: ...

@overload
def f(x: A) -> A: ...
@overload
def f(x: Tuple[C]) -> B: ...
@overload
def f(x: Tuple[A1, int]) -> C: ...  # E: Overloaded function signatures 3 and 5 overlap with incompatible return types
@overload
def f(x: Tuple[A, str]) -> D: ...
@overload
def f(x: Tuple[A, int]) -> D: ...
@overload
def f(x: Tuple[()]) -> D: ...
def f(x: Any) -> Any:...

[case testOverloadTupleEllipsisNumargs]
from typing import overload, Tuple, Any

class A: ...
class B: ...

@overload
def r1(x: Tuple[()]) -> B: ...  # E: Overloaded function signatures 1 and 4 overlap with incompatible return types
@overload
def r1(x: Tuple[A]) -> B: ...  # E: Overloaded function signatures 2 and 4 overlap with incompatible return types
@overload
def r1(x: Tuple[A, A]) -> B: ...  # E: Overloaded function signatures 3 and 4 overlap with incompatible return types
@overload
def r1(x: Tuple[A, ...]) -> A: ...
def r1(x: Any) -> Any: ...

@overload
def r2(x: Tuple[A, ...]) -> A: ...
@overload
def r2(x: Tuple[A, A]) -> B: ...  # E: Overloaded function signature 2 will never be matched: signature 1's parameter type(s) are the same or broader
@overload
def r2(x: Tuple[A]) -> B: ...  # E: Overloaded function signature 3 will never be matched: signature 1's parameter type(s) are the same or broader
@overload
def r2(x: Tuple[()]) -> B: ...  # E: Overloaded function signature 4 will never be matched: signature 1's parameter type(s) are the same or broader
def r2(x: Any) -> Any: ...

[builtins fixtures/tuple.pyi]

[case testOverloadTupleEllipsisVariance]
from typing import overload, Tuple, Any

class A: ...
class A1(A): ...
class B: ...
class C: ...
class D: ...

@overload
def r(x: Tuple[A1, ...]) -> A: ...  # E: Overloaded function signatures 1 and 2 overlap with incompatible return types
@overload
def r(x: Tuple[A, ...]) -> B: ...
@overload
def r(x: Tuple[B, ...]) -> C: ...
def r(x: Any) -> Any:...

@overload
def g(x: A) -> A: ...
@overload
def g(x: Tuple[A1, ...]) -> B: ...  # E: Overloaded function signatures 2 and 3 overlap with incompatible return types
@overload
def g(x: Tuple[A, A]) -> C: ...
@overload
def g(x: Tuple[A, B]) -> D: ...
def g(x: Any) -> Any:...

[builtins fixtures/tuple.pyi]

[case testOverloadWithMethodOverrideAndImplementation]
from typing import overload, Union, Any

class Parent:
    @overload
    def f(self, arg: int) -> int: ...
    @overload
    def f(self, arg: str) -> str: ...
    def f(self, arg: Any) -> Any: ...

class Child1(Parent):
    @overload
    def f(self, arg: int) -> int: ...
    @overload
    def f(self, arg: str) -> str: ...
    def f(self, arg: Union[int, str]) -> Union[int, str]: ...

class Child2(Parent):
    @overload
    def f(self, arg: int) -> int: ...
    @overload
    def f(self, arg: str) -> str: ...
    def f(self, arg: Union[int, str]) -> int: ... # E: Overloaded function implementation cannot produce return type of signature 2

class Child3(Parent):
    @overload
    def f(self, arg: int) -> int: ...
    @overload
    def f(self, arg: str) -> str: ...
    def f(self, arg: Any) -> Any: ...

class Child4(Parent):
    @overload
    def f(self, arg: int) -> int: ...
    @overload
    def f(self, arg: str) -> str: ...
    def f(self, arg: Union[int, str]) -> Union[int, str]:
        return True  # E: Incompatible return value type (got "bool", expected "Union[int, str]")

[builtins fixtures/tuple.pyi]

[case testOverloadWithIncompatibleMethodOverrideAndImplementation]
from typing import overload, Union, Any

class StrSub: pass

class ParentWithTypedImpl:
    @overload
    def f(self, arg: int) -> int: ...
    @overload
    def f(self, arg: str) -> str: ...
    def f(self, arg: Union[int, str]) -> Union[int, str]: ...

class Child1(ParentWithTypedImpl):
    @overload # E: Signature of "f" incompatible with supertype "ParentWithTypedImpl"
    def f(self, arg: int) -> int: ...
    @overload
    def f(self, arg: StrSub) -> str: ...
    def f(self, arg: Union[int, StrSub]) -> Union[int, str]: ...

class Child2(ParentWithTypedImpl):
    @overload # E: Signature of "f" incompatible with supertype "ParentWithTypedImpl"
    def f(self, arg: int) -> int: ...
    @overload
    def f(self, arg: StrSub) -> str: ...
    def f(self, arg: Any) -> Any: ...

class ParentWithDynamicImpl:
    @overload
    def f(self, arg: int) -> int: ...
    @overload
    def f(self, arg: str) -> str: ...
    def f(self, arg: Any) -> Any: ...

class Child3(ParentWithDynamicImpl):
    @overload # E: Signature of "f" incompatible with supertype "ParentWithDynamicImpl"
    def f(self, arg: int) -> int: ...
    @overload
    def f(self, arg: StrSub) -> str: ...
    def f(self, arg: Union[int, StrSub]) -> Union[int, str]: ...

class Child4(ParentWithDynamicImpl):
    @overload # E: Signature of "f" incompatible with supertype "ParentWithDynamicImpl"
    def f(self, arg: int) -> int: ...
    @overload
    def f(self, arg: StrSub) -> str: ...
    def f(self, arg: Any) -> Any: ...

[builtins fixtures/tuple.pyi]

[case testOverloadAnyIsConsideredValidReturnSubtype]
from typing import Any, overload, Optional

@overload
def foo(x: None) -> Any: ...
@overload
def foo(x: Optional[str]) -> str: ...
def foo(x): pass

@overload
def bar(x: None) -> object: ...  # E: Overloaded function signatures 1 and 2 overlap with incompatible return types
@overload
def bar(x: Optional[str]) -> str: ...
def bar(x): pass

[case testOverloadWithNonPositionalArgs]
from typing import overload

class A: ...
class B: ...
class C: ...

@overload
def foo(*, p1: A, p2: B = B()) -> A: ...
@overload
def foo(*, p2: B = B()) -> B: ...
def foo(p1, p2=None): ...

reveal_type(foo())  # E: Revealed type is '__main__.B'
reveal_type(foo(p2=B()))  # E: Revealed type is '__main__.B'
reveal_type(foo(p1=A()))  # E: Revealed type is '__main__.A'

[case testOverloadWithNonPositionalArgsIgnoresOrder]
from typing import overload

class A: ...
class B(A): ...
class X: ...
class Y: ...

@overload
def f(*, p1: X, p2: A) -> X: ...
@overload
def f(*, p2: B, p1: X) -> Y: ...  # E: Overloaded function signature 2 will never be matched: signature 1's parameter type(s) are the same or broader
def f(*, p1, p2): ...

@overload
def g(*, p1: X, p2: B) -> X: ...  # E: Overloaded function signatures 1 and 2 overlap with incompatible return types
@overload
def g(*, p2: A, p1: X) -> Y: ...
def g(*, p1, p2): ...

[case testOverloadWithVariableArgsAreOverlapping-skip]
# TODO: Re-enable this after adding support for partially overlapping arg counts
from wrapper import *
[file wrapper.pyi]
from typing import overload

@overload
def foo1(*x: int) -> int: ...  # E: Overloaded function signatures 1 and 2 overlap with incompatible return types
@overload
def foo1(x: int, y: int, z: int) -> str: ...

@overload
def foo2(*x: int) -> int: ...
@overload
def foo2(x: int, y: str, z: int) -> str: ...

@overload
def bar1(x: int, y: int, z: int) -> str: ...  # E: Overloaded function signatures 1 and 2 overlap with incompatible return types
@overload
def bar1(*x: int) -> int: ...

@overload
def bar2(x: int, y: str, z: int) -> str: ...
@overload
def bar2(*x: int) -> int: ...

[case testOverloadDetectsPossibleMatchesWithGenerics]
from typing import overload, TypeVar, Generic

T = TypeVar('T')

@overload
def foo(x: None, y: None) -> str: ...  # E: Overloaded function signatures 1 and 2 overlap with incompatible return types
@overload
def foo(x: T, y: T) -> int: ...
def foo(x): ...

# TODO: We should allow this; T can't be bound to two distinct types
@overload
def bar(x: None, y: int) -> str: ...  # E: Overloaded function signatures 1 and 2 overlap with incompatible return types
@overload
def bar(x: T, y: T) -> int: ...
def bar(x, y): ...

class Wrapper(Generic[T]):
    # TODO: This should be an error
    @overload
    def foo(self, x: None, y: None) -> str: ...
    @overload
    def foo(self, x: T, y: None) -> str: ...
    def foo(self, x): ...

    @overload
    def bar(self, x: None, y: int) -> str: ...
    @overload
    def bar(self, x: T, y: T) -> str: ...
    def bar(self, x, y): ...

[case testOverloadFlagsPossibleMatches]
from wrapper import *
[file wrapper.pyi]
from typing import overload

@overload
def foo1(x: str) -> str: ...  # E: Overloaded function signatures 1 and 2 overlap with incompatible return types
@overload
def foo1(x: str, y: str = ...) -> int: ...

@overload
def foo2(x: str, y: str = ...) -> int: ...
@overload
def foo2(x: str) -> str: ...  # E: Overloaded function signature 2 will never be matched: signature 1's parameter type(s) are the same or broader

@overload
def foo3(x: str) -> str: ...
@overload
def foo3(x: str, y: str) -> int: ...

[case testOverloadPossibleOverlapWithArgsAndKwargs-skip]
# TODO: Re-enable this after adding support for partially overlapping arg counts
from wrapper import *
[file wrapper.pyi]
from typing import overload

@overload
def foo1(*args: int) -> int: ...  # E: Overloaded function signatures 1 and 2 overlap with incompatible return types
@overload
def foo1(**kwargs: int) -> str: ...

@overload
def foo2(**kwargs: int) -> str: ...
@overload
def foo2(*args: int) -> int: ...  # E: Overloaded function signature 2 will never be matched: function 1's parameter type(s) are the same or broader
[builtins fixtures/dict.pyi]

[case testOverloadWithPartiallyOverlappingUnions]
from typing import overload, Union

class A: ...
class B: ...
class C: ...
class D: ...

@overload
def f(x: Union[A, B]) -> int: ...  # E: Overloaded function signatures 1 and 2 overlap with incompatible return types
@overload
def f(x: Union[B, C]) -> str: ...
def f(x): ...

@overload
def g(x: Union[A, B]) -> int: ...
@overload
def g(x: Union[C, D]) -> str: ...
def g(x): ...

@overload
def h(x: Union[A, B]) -> int: ...  # E: Overloaded function signatures 1 and 2 overlap with incompatible return types
@overload
def h(x: Union[A, B, C]) -> str: ...
def h(x): ...

[case testOverloadPartialOverlapWithUnrestrictedTypeVar]
from typing import TypeVar, overload

T = TypeVar('T')

@overload
def f(x: int) -> str: ...  # E: Overloaded function signatures 1 and 2 overlap with incompatible return types
@overload
def f(x: T) -> T: ...
def f(x): ...

[case testOverloadNotConfusedForProperty]
from typing import overload

class PropertyClass:
    @property
    def foo(self) -> str: return "..."
    @foo.setter
    def foo(self, value: str) -> None: pass
    @foo.deleter
    def foo(self) -> None: pass

class OverloadClass:
    @overload
    def foo(self) -> str: pass
    @overload
    def foo(self, value: str) -> None: pass
    @overload
    def foo(self) -> None: pass  # E: Overloaded function signature 3 will never be matched: signature 1's parameter type(s) are the same or broader
    def foo(self, *args): pass

[builtins fixtures/property.pyi]

[case testOverloadInferUnionReturnBasic]
from typing import overload, Union

class A: ...
class B: ...
class C: ...
class D: ...

@overload
def f1(x: A) -> B: ...
@overload
def f1(x: C) -> D: ...
def f1(x): ...

arg1: Union[A, C]
reveal_type(f1(arg1))  # E: Revealed type is 'Union[__main__.B, __main__.D]'

arg2: Union[A, B]
f1(arg2)  # E: Argument 1 to "f1" has incompatible type "Union[A, B]"; expected "A"

@overload
def f2(x: A) -> B: ...
@overload
def f2(x: C) -> B: ...
def f2(x): ...

reveal_type(f2(arg1))  # E: Revealed type is '__main__.B'

[case testOverloadInferUnionReturnMultipleArguments]
from typing import overload, Union

class A: ...
class B: ...
class C: ...
class D: ...

@overload
def f1(x: A, y: C) -> B: ...
@overload
def f1(x: C, y: A) -> D: ...
def f1(x, y): ...

arg1: Union[A, C]
reveal_type(f1(arg1, arg1))

@overload
def f2(x: A, y: C) -> B: ...
@overload
def f2(x: C, y: C) -> D: ...
def f2(x, y): ...

reveal_type(f2(arg1, arg1))
reveal_type(f2(arg1, C()))

[out]
main:15: error: Revealed type is '__main__.B'
main:15: error: Argument 1 to "f1" has incompatible type "Union[A, C]"; expected "A"
main:15: error: Argument 2 to "f1" has incompatible type "Union[A, C]"; expected "C"
main:23: error: Revealed type is 'Union[__main__.B, __main__.D]'
main:23: error: Argument 2 to "f2" has incompatible type "Union[A, C]"; expected "C"
main:24: error: Revealed type is 'Union[__main__.B, __main__.D]'

[case testOverloadInferUnionSkipIfParameterNamesAreDifferent]
from typing import overload, Union

class A: ...
class B: ...
class C: ...

@overload
def f(x: A) -> B: ...
@overload
def f(y: B) -> C: ...
def f(x): ...

x: Union[A, B]
reveal_type(f(A()))  # E: Revealed type is '__main__.B'
reveal_type(f(B()))  # E: Revealed type is '__main__.C'
f(x)                 # E: Argument 1 to "f" has incompatible type "Union[A, B]"; expected "A"

[case testOverloadInferUnionReturnFunctionsWithKwargs]
from typing import overload, Union, Optional

class A: ...
class B: ...
class C: ...
class D(B, C): ...

@overload
def f(x: A) -> D: ...
@overload
def f(x: A, y: Optional[B] = None) -> C: ...
@overload
def f(x: A, z: Optional[C] = None) -> B: ...
def f(x, y=None, z=None): ...

reveal_type(f(A(), B()))
reveal_type(f(A(), C()))

arg: Union[B, C]
reveal_type(f(A(), arg))
reveal_type(f(A()))

[builtins fixtures/tuple.pyi]
[out]
main:16: error: Revealed type is '__main__.C'
main:17: error: Revealed type is '__main__.B'
main:20: error: Revealed type is '__main__.C'
main:20: error: Argument 2 to "f" has incompatible type "Union[B, C]"; expected "Optional[B]"
main:21: error: Revealed type is '__main__.D'

[case testOverloadingInferUnionReturnWithTypevarWithValueRestriction]
from typing import overload, Union, TypeVar, Generic

class A: pass
class B: pass
class C: pass

T = TypeVar('T', B, C)

class Wrapper(Generic[T]):
    @overload
    def f(self, x: T) -> B: ...

    @overload
    def f(self, x: A) -> C: ...

    def f(self, x): ...

obj: Wrapper[B] = Wrapper()
x: Union[A, B]

reveal_type(obj.f(A()))  # E: Revealed type is '__main__.C'
reveal_type(obj.f(B()))  # E: Revealed type is '__main__.B'
reveal_type(obj.f(x))    # E: Revealed type is 'Union[__main__.B, __main__.C]'

[case testOverloadingInferUnionReturnWithTypevarReturn]
from typing import overload, Union, TypeVar, Generic

T = TypeVar('T')

class W1(Generic[T]): pass
class W2(Generic[T]): pass
class A: pass
class B: pass

@overload
def foo(x: W1[T]) -> T: ...
@overload
def foo(x: W2[T]) -> T: ...
def foo(x): ...

def bar(x: Union[W1[T], W2[T]]) -> T: ...

class SomeType(Generic[T]):
    @overload
    def foo(self, x: W1[T]) -> T: ...
    @overload
    def foo(self, x: W2[T]) -> T: ...
    def foo(self, x): ...

    def bar(self, x: Union[W1[T], W2[T]]) -> T: ...

def wrapper(mysterious: T) -> T:
    obj1: Union[W1[A], W2[A]]

    # Phase 1: Things mypy should be able to infer

    a1: A = foo(obj1)
    a2 = foo(obj1)
    a3 = SomeType[A]().foo(obj1)

    reveal_type(a1)  # E: Revealed type is '__main__.A'
    reveal_type(a2)  # E: Revealed type is '__main__.A*'
    reveal_type(a3)  # E: Revealed type is '__main__.A*'

    # Phase 2: Things mypy should be able to infer, but does not
    #          due to bugs unrelated to overloads
    #
    #          (We confirm this by checking to see that the error
    #          message is identical to what we would have gotten if
    #          we manually union the overload)

    a4_overload: A = SomeType().foo(obj1)  # E: Argument 1 to "foo" of "SomeType" has incompatible type "Union[W1[A], W2[A]]"; expected "Union[W1[<nothing>], W2[<nothing>]]"
    a4_union: A    = SomeType().bar(obj1)  # E: Argument 1 to "bar" of "SomeType" has incompatible type "Union[W1[A], W2[A]]"; expected "Union[W1[<nothing>], W2[<nothing>]]"

    SomeType().foo(obj1)  # E: Argument 1 to "foo" of "SomeType" has incompatible type "Union[W1[A], W2[A]]"; expected "Union[W1[<nothing>], W2[<nothing>]]"
    SomeType().bar(obj1)  # E: Argument 1 to "bar" of "SomeType" has incompatible type "Union[W1[A], W2[A]]"; expected "Union[W1[<nothing>], W2[<nothing>]]"


    # Phase 3: Things where type inference is impossible and
    #          mypy should report an error

    obj2: Union[W1[A], W2[B]]

    foo(obj2)  # E: Cannot infer type argument 1 of "foo"
    bar(obj2)  # E: Cannot infer type argument 1 of "bar"

    b2_overload: A = foo(obj2)  # E: Cannot infer type argument 1 of "foo"
    b2_union: A    = bar(obj2)  # E: Cannot infer type argument 1 of "bar"

    SomeType().foo(obj2)  # E: Argument 1 to "foo" of "SomeType" has incompatible type "Union[W1[A], W2[B]]"; expected "Union[W1[<nothing>], W2[<nothing>]]"
    SomeType().bar(obj2)  # E: Argument 1 to "bar" of "SomeType" has incompatible type "Union[W1[A], W2[B]]"; expected "Union[W1[<nothing>], W2[<nothing>]]"

    SomeType[A]().foo(obj2)  # E: Argument 1 to "foo" of "SomeType" has incompatible type "Union[W1[A], W2[B]]"; expected "Union[W1[A], W2[A]]"
    SomeType[A]().bar(obj2)  # E: Argument 1 to "bar" of "SomeType" has incompatible type "Union[W1[A], W2[B]]"; expected "Union[W1[A], W2[A]]"

    SomeType[T]().foo(obj2)  # E: Argument 1 to "foo" of "SomeType" has incompatible type "Union[W1[A], W2[B]]"; expected "Union[W1[T], W2[T]]"
    SomeType[T]().bar(obj2)  # E: Argument 1 to "bar" of "SomeType" has incompatible type "Union[W1[A], W2[B]]"; expected "Union[W1[T], W2[T]]"

    return mysterious

[case testOverloadsAndNoneWithoutStrictOptional]
# flags: --no-strict-optional
from typing import overload, Optional

@overload
def f(x: None) -> int: ...  # E: Overloaded function signatures 1 and 2 overlap with incompatible return types
@overload
def f(x: object) -> str: ...
def f(x): ...

# We pretend strict-optional is enabled for overload definitions,
# even in non-strict optional mode
@overload
def g(x: None) -> int: ...
@overload
def g(x: int) -> str: ...
def g(x): ...

# Calls are still checked normally though
a: None
b: int
c: Optional[int]
reveal_type(g(a))  # E: Revealed type is 'builtins.int'
reveal_type(g(b))  # E: Revealed type is 'builtins.str'
reveal_type(g(c))  # E: Revealed type is 'builtins.str'

[case testOverloadsAndNoneWithStrictOptional]
# flags: --strict-optional
from typing import overload, Optional

@overload
def f(x: None) -> int: ...  # E: Overloaded function signatures 1 and 2 overlap with incompatible return types
@overload
def f(x: object) -> str: ...
def f(x): ...

@overload
def g(x: None) -> int: ...
@overload
def g(x: int) -> str: ...
def g(x): ...

a: None
b: int
c: Optional[int]
reveal_type(g(a))  # E: Revealed type is 'builtins.int'
reveal_type(g(b))  # E: Revealed type is 'builtins.str'
reveal_type(g(c))  # E: Revealed type is 'Union[builtins.int, builtins.str]'

[case testOverloadsNoneAndTypeVarsWithNoStrictOptional]
# flags: --no-strict-optional
from typing import Callable, Iterable, TypeVar, overload, Optional

T = TypeVar('T')
S = TypeVar('S')

@overload
def mymap(func: None, seq: Iterable[T]) -> Iterable[T]: ...
@overload
def mymap(func: Callable[[T], S], seq: Iterable[T]) -> Iterable[S]: ...
def mymap(*args): ...

seq = [1, 2, 3]
f1: Callable[[int], str]
f2: None
f3: Optional[Callable[[int], str]]

reveal_type(mymap(f1, seq))  # E: Revealed type is 'typing.Iterable[builtins.str*]'
reveal_type(mymap(f2, seq))  # E: Revealed type is 'typing.Iterable[builtins.int*]'
reveal_type(mymap(f3, seq))  # E: Revealed type is 'typing.Iterable[builtins.str*]'

[builtins fixtures/list.pyi]
[typing fixtures/typing-full.pyi]

[case testOverloadsNoneAndTypeVarsWithStrictOptional]
# flags: --strict-optional
from typing import Callable, Iterable, TypeVar, overload, Optional

T = TypeVar('T')
S = TypeVar('S')

@overload
def mymap(func: None, seq: Iterable[T]) -> Iterable[T]: ...
@overload
def mymap(func: Callable[[T], S], seq: Iterable[T]) -> Iterable[S]: ...
def mymap(*args): ...

seq = [1, 2, 3]
f1: Callable[[int], str]
f2: None
f3: Optional[Callable[[int], str]]

reveal_type(mymap(f1, seq))  # E: Revealed type is 'typing.Iterable[builtins.str*]'
reveal_type(mymap(f2, seq))  # E: Revealed type is 'typing.Iterable[builtins.int*]'
reveal_type(mymap(f3, seq))  # E: Revealed type is 'Union[typing.Iterable[builtins.int], typing.Iterable[builtins.str*]]'

[builtins fixtures/list.pyi]
[typing fixtures/typing-full.pyi]

[case testOverloadsAndNoReturnNarrowTypeNoStrictOptional]
# flags: --no-strict-optional
from typing import overload, Union, TypeVar, NoReturn, Optional

@overload
def narrow_int(x: str) -> NoReturn: ...
@overload
def narrow_int(x: int) -> int: ...
def narrow_int(x):
    assert isinstance(x, int)
    return x

T = TypeVar('T')
@overload
def narrow_none(x: None) -> NoReturn: ...
@overload
def narrow_none(x: T) -> T: ...
def narrow_none(x):
    assert x is not None
    return x

def test_narrow_int() -> None:
    a: Union[int, str]
    a = narrow_int(a)
    reveal_type(a)  # E: Revealed type is 'builtins.int'

    b: int
    b = narrow_int(b)
    reveal_type(b)  # E: Revealed type is 'builtins.int'

    c: str
    c = narrow_int(c)
    reveal_type(c)  # Note: branch is now dead, so no type is revealed
                    # TODO: maybe we should make mypy report a warning instead?

def test_narrow_none() -> None:
    a: Optional[int]
    a = narrow_none(a)
    reveal_type(a)  # E: Revealed type is 'Union[builtins.int, None]'

    b: int
    b = narrow_none(b)
    reveal_type(b)  # E: Revealed type is 'builtins.int'

    c: None
    c = narrow_none(c)
    reveal_type(c)  # Note: branch is now dead, so no type is revealed

[builtins fixtures/isinstance.pyi]
[typing fixtures/typing-full.pyi]

[case testOverloadsAndNoReturnNarrowTypeWithStrictOptional]
# flags: --strict-optional
from typing import overload, Union, TypeVar, NoReturn, Optional

@overload
def narrow_int(x: str) -> NoReturn: ...
@overload
def narrow_int(x: int) -> int: ...
def narrow_int(x):
    assert isinstance(x, int)
    return x

T = TypeVar('T')
@overload
def narrow_none(x: None) -> NoReturn: ...
@overload
def narrow_none(x: T) -> T: ...
def narrow_none(x):
    assert x is not None
    return x

def test_narrow_int() -> None:
    a: Union[int, str]
    a = narrow_int(a)
    reveal_type(a)  # E: Revealed type is 'builtins.int'

    b: int
    b = narrow_int(b)
    reveal_type(b)  # E: Revealed type is 'builtins.int'

    c: str
    c = narrow_int(c)
    reveal_type(c)  # Note: branch is now dead, so no type is revealed
                    # TODO: maybe we should make mypy report a warning instead?

def test_narrow_none() -> None:
    a: Optional[int]
    a = narrow_none(a)
    reveal_type(a)  # E: Revealed type is 'builtins.int'

    b: int
    b = narrow_none(b)
    reveal_type(b)  # E: Revealed type is 'builtins.int'

    c: None
    c = narrow_none(c)
    reveal_type(c)  # Branch is now dead

[builtins fixtures/isinstance.pyi]
[typing fixtures/typing-full.pyi]
