-- Normal assignment and subtyping
-- -------------------------------


[case testTupleAssignmentWithTupleTypes]
from typing import Tuple
t1 = None # type: Tuple[A]
t2 = None # type: Tuple[B]
t3 = None # type: Tuple[A, A]
t4 = None # type: Tuple[A, B]
t5 = None # type: Tuple[B, A]

t1 = t2 # E:0: Incompatible types in assignment (expression has type "Tuple[B]", variable has type "Tuple[A]")
t1 = t3 # E:0: Incompatible types in assignment (expression has type "Tuple[A, A]", variable has type "Tuple[A]")
t3 = t1 # E:0: Incompatible types in assignment (expression has type "Tuple[A]", variable has type "Tuple[A, A]")
t3 = t4 # E:0: Incompatible types in assignment (expression has type "Tuple[A, B]", variable has type "Tuple[A, A]")
t3 = t5 # E:0: Incompatible types in assignment (expression has type "Tuple[B, A]", variable has type "Tuple[A, A]")

# Ok
t1 = t1
t2 = t2
t3 = t3
t4 = t4
t5 = t5

class A: pass
class B: pass
[builtins fixtures/tuple.pyi]

[case testTupleSubtyping]
from typing import Tuple
t1 = None # type: Tuple[A, A]
t2 = None # type: Tuple[A, B]
t3 = None # type: Tuple[B, A]

t2 = t1  # E:0: Incompatible types in assignment (expression has type "Tuple[A, A]", variable has type "Tuple[A, B]")
t2 = t3  # E:0: Incompatible types in assignment (expression has type "Tuple[B, A]", variable has type "Tuple[A, B]")
t3 = t1  # E:0: Incompatible types in assignment (expression has type "Tuple[A, A]", variable has type "Tuple[B, A]")
t3 = t2  # E:0: Incompatible types in assignment (expression has type "Tuple[A, B]", variable has type "Tuple[B, A]")

t1 = t2
t1 = t3

class A: pass
class B(A): pass
[builtins fixtures/tuple.pyi]

[case testTupleCompatibilityWithOtherTypes]
from typing import Tuple
a, o = None, None # type: (A, object)
t = None # type: Tuple[A, A]

a = t # E:0: Incompatible types in assignment (expression has type "Tuple[A, A]", variable has type "A")
t = o # E:0: Incompatible types in assignment (expression has type "object", variable has type "Tuple[A, A]")
t = a # E:0: Incompatible types in assignment (expression has type "A", variable has type "Tuple[A, A]")
# TODO: callable types + tuples

# Ok
o = t
t = None

class A: pass
[builtins fixtures/tuple.pyi]

[case testNestedTupleTypes]
from typing import Tuple
t1 = None # type: Tuple[A, Tuple[A, A]]
t2 = None # type: Tuple[B, Tuple[B, B]]

t2 = t1 # E:0: Incompatible types in assignment (expression has type "Tuple[A, Tuple[A, A]]", variable has type "Tuple[B, Tuple[B, B]]")
t1 = t2

class A: pass
class B(A): pass
[builtins fixtures/tuple.pyi]

[case testNestedTupleTypes2]
from typing import Tuple
t1 = None # type: Tuple[A, Tuple[A, A]]
t2 = None # type: Tuple[B, Tuple[B, B]]

t2 = t1 # E:0: Incompatible types in assignment (expression has type "Tuple[A, Tuple[A, A]]", variable has type "Tuple[B, Tuple[B, B]]")
t1 = t2

class A: pass
class B(A): pass
[builtins fixtures/tuple.pyi]

[case testSubtypingWithNamedTupleType]
from typing import Tuple
t1 = None # type: Tuple[A, A]
t2 = None # type: tuple

t1 = t2 # E:0: Incompatible types in assignment (expression has type Tuple[Any, ...], variable has type "Tuple[A, A]")
t2 = t1

class A: pass
[builtins fixtures/tuple.pyi]

[case testTupleInitializationWithNone]
from typing import Tuple
t = None # type: Tuple[A, A]
t = None
class A: pass
[builtins fixtures/tuple.pyi]


-- Tuple expressions
-- -----------------


[case testTupleExpressions]
from typing import Tuple
t1 = None # type: tuple
t2 = None # type: Tuple[A]
t3 = None # type: Tuple[A, B]

a, b, c = None, None, None # type: (A, B, C)

t2 = ()        # E:0: Incompatible types in assignment (expression has type "Tuple[]", variable has type "Tuple[A]")
t2 = (a, a)    # E:0: Incompatible types in assignment (expression has type "Tuple[A, A]", variable has type "Tuple[A]")
t3 = (a, a)    # E:0: Incompatible types in assignment (expression has type "Tuple[A, A]", variable has type "Tuple[A, B]")
t3 = (b, b)    # E:0: Incompatible types in assignment (expression has type "Tuple[B, B]", variable has type "Tuple[A, B]")
t3 = (a, b, a) # E:0: Incompatible types in assignment (expression has type "Tuple[A, B, A]", variable has type "Tuple[A, B]")

t1 = ()
t1 = (a,)
t2 = (a,)
t3 = (a, b)
t3 = (a, c)
t3 = (None, None)

class A: pass
class B: pass
class C(B): pass
[builtins fixtures/tuple.pyi]

[case testVoidValueInTuple]
import typing
(None, f()) # E:5: "f" does not return a value
(f(), None) # E:4: "f" does not return a value

def f() -> None: pass
[builtins fixtures/tuple.pyi]


-- Indexing
-- --------


[case testIndexingTuples]
from typing import Tuple
t1 = None # type: Tuple[A, B]
t2 = None # type: Tuple[A]
t3 = None # type: Tuple[A, B, C, D, E]
a, b = None, None # type: (A, B)
x = None # type: Tuple[A, B, C]
y = None # type: Tuple[A, C, E]
n = 0

a = t1[1] # E:0: Incompatible types in assignment (expression has type "B", variable has type "A")
b = t1[0] # E:0: Incompatible types in assignment (expression has type "A", variable has type "B")
t1[2]     # E:2: Tuple index out of range
t1[3]     # E:2: Tuple index out of range
t2[1]     # E:2: Tuple index out of range
t1[n]     # E:2: Tuple index must be an integer literal
t3[n:]    # E:3: Tuple slice must be an integer literal
b = t1[(0)] # E:0: Incompatible types in assignment (expression has type "A", variable has type "B")

a = t1[0]
b = t1[1]
b = t1[-1]
a = t1[(0)]
x = t3[0:3] # type (A, B, C)
y = t3[0:5:2] # type (A, C, E)
x = t3[:-2] # type (A, B, C)

class A: pass
class B: pass
class C: pass
class D: pass
class E: pass
[builtins fixtures/tuple.pyi]

[case testIndexingTuplesWithNegativeIntegers]
from typing import Tuple
t1 = None  # type: Tuple[A, B]
t2 = None  # type: Tuple[A]
a, b = None, None  # type: A, B

a = t1[-1] # E:0: Incompatible types in assignment (expression has type "B", variable has type "A")
b = t1[-2] # E:0: Incompatible types in assignment (expression has type "A", variable has type "B")
t1[-3]     # E:2: Tuple index out of range
t1[-4]     # E:2: Tuple index out of range
b = t2[(-1)] # E:0: Incompatible types in assignment (expression has type "A", variable has type "B")

a = t1[-2]
b = t1[-1]
a = t2[(-1)]

class A: pass
class B: pass
[builtins fixtures/tuple.pyi]

[case testAssigningToTupleItems]
from typing import Tuple
t = None # type: Tuple[A, B]
n = 0

t[0] = A() # E:8: Unsupported target for indexed assignment
t[2] = A() # E:8: Unsupported target for indexed assignment
t[n] = A() # E:8: Unsupported target for indexed assignment

class A: pass
class B: pass
[builtins fixtures/tuple.pyi]


-- Multiple assignment
-- -------------------


[case testMultipleAssignmentWithTuples]
from typing import Tuple
t1 = None # type: Tuple[A, B]
t2 = None # type: Tuple[A, B, A]
a, b = None, None # type: (A, B)

a, a = t1 # E:3: Incompatible types in assignment (expression has type "B", variable has type "A")
b, b = t1 # E:0: Incompatible types in assignment (expression has type "A", variable has type "B")
a, b, b = t2 # E:6: Incompatible types in assignment (expression has type "A", variable has type "B")

a, b = t1
a, b, a = t2

class A: pass
class B: pass
[builtins fixtures/tuple.pyi]

[case testMultipleAssignmentWithInvalidNumberOfValues]
from typing import Tuple
t1 = None # type: Tuple[A, A, A]
a = None # type: A

a, a = t1       # E:1: Too many values to unpack (2 expected, 3 provided)
a, a, a, a = t1 # E:1: Need more than 3 values to unpack (4 expected)

a, a, a = t1

class A: pass
[builtins fixtures/tuple.pyi]

[case testMultipleAssignmentWithTupleExpressionRvalue]

a, b = None, None # type: (A, B)

a, b = a, a # Fail
a, b = b, a # Fail

a, b = a, b
a, a = a, a

class A: pass
class B: pass
[builtins fixtures/tuple.pyi]
[out]
main:4:3: error: Incompatible types in assignment (expression has type "A", variable has type "B")
main:5:0: error: Incompatible types in assignment (expression has type "B", variable has type "A")
main:5:3: error: Incompatible types in assignment (expression has type "A", variable has type "B")

[case testSubtypingInMultipleAssignment]

a, b = None, None # type: (A, B)

b, b = a, b # E:0: Incompatible types in assignment (expression has type "A", variable has type "B")
b, b = b, a # E:3: Incompatible types in assignment (expression has type "A", variable has type "B")

a, b = b, b
b, a = b, b

class A: pass
class B(A): pass
[builtins fixtures/tuple.pyi]

[case testInitializationWithMultipleValues]

a, b = None, None # type: (A, B)

a1, b1 = a, a # type: (A, B)  # E:4: Incompatible types in assignment (expression has type "A", variable has type "B")
a2, b2 = b, b # type: (A, B)  # E:0: Incompatible types in assignment (expression has type "B", variable has type "A")
a3, b3 = a # type: (A, B)     # E:2: '__main__.A' object is not iterable
a4, b4 = None # type: (A, B)  # E:2: 'builtins.None' object is not iterable
a5, b5 = a, b, a # type: (A, B)  # E:2: Too many values to unpack (2 expected, 3 provided)

ax, bx = a, b # type: (A, B)

class A: pass
class B: pass
[builtins fixtures/tuple.pyi]

[case testMultipleAssignmentWithNonTupleRvalue]

a, b = None, None # type: (A, B)
def f(): pass

a, b = None # E:1: 'builtins.None' object is not iterable
a, b = a   # E:1: '__main__.A' object is not iterable
a, b = f   # E:1: 'def () -> Any' object is not iterable

class A: pass
class B: pass
[builtins fixtures/tuple.pyi]

[case testMultipleAssignmentWithIndexedLvalues]

a, b = None, None # type: (A, B)
aa, bb = None, None # type: (AA, BB)

a[a], b[b] = a, bb   # E:13: Incompatible types in assignment (expression has type "A", target has type "AA")
a[a], b[b] = aa, b   # E:17: Incompatible types in assignment (expression has type "B", target has type "BB")
a[aa], b[b] = aa, bb # E:14: Invalid index type "AA" for "A"
a[a], b[bb] = aa, bb # E:18: Invalid index type "BB" for "B"
a[a], b[b] = aa, bb

class A:
    def __setitem__(self, x: 'A', y: 'AA') -> None: pass
class B:
    def __setitem__(self, x: 'B', y: 'BB') -> None: pass

class AA: pass
class BB: pass
[builtins fixtures/tuple.pyi]

[case testMultipleDeclarationWithParentheses]

(a, b) = (None, None) # type: int, str
a = '' # E:0: Incompatible types in assignment (expression has type "str", variable has type "int")
b = 1  # E:0: Incompatible types in assignment (expression has type "int", variable has type "str")
a = 1
b = ''

[case testMultipleAssignmentWithExtraParentheses]

a, b = None, None # type: (A, B)

(a, b) = (a, a) # E:4: Incompatible types in assignment (expression has type "A", variable has type "B")
(a, b) = (b, b) # E:1: Incompatible types in assignment (expression has type "B", variable has type "A")
((a), (b)) = ((a), (a))  # E:7: Incompatible types in assignment (expression has type "A", variable has type "B")
((a), (b)) = ((b), (b))  # E:2: Incompatible types in assignment (expression has type "B", variable has type "A")
[a, b] = a, a  # E:4: Incompatible types in assignment (expression has type "A", variable has type "B")
[a, b] = b, b  # E:1: Incompatible types in assignment (expression has type "B", variable has type "A")

(a, b) = (a, b)
((a), (b)) = ((a), (b))
[a, b] = a, b

class A: pass
class B: pass
[builtins fixtures/tuple.pyi]

[case testMultipleAssignmentUsingSingleTupleType]
from typing import Tuple
a, b = None, None  # type: Tuple[int, str]
a = 1
b = ''
a = '' # E:0: Incompatible types in assignment (expression has type "str", variable has type "int")
b = 1  # E:0: Incompatible types in assignment (expression has type "int", variable has type "str")

[case testMultipleAssignmentWithMixedVariables]
a = b, c = 1, 1
x, y = p, q = 1, 1
u, v, w = r, s = 1, 1 # E:1: Need more than 2 values to unpack (3 expected)
d, e = f, g, h = 1, 1 # E:8: Need more than 2 values to unpack (3 expected)


-- Assignment to starred expressions
-- ---------------------------------


[case testAssignmentToStarMissingAnnotation]
from typing import List
t = 1, 2
a, b, *c = 1, 2  # E:7: Need type annotation for variable
aa, bb, *cc = t  # E:9: Need type annotation for variable
[builtins fixtures/list.pyi]

[case testAssignmentToStarAnnotation]
from typing import List
li, lo = None, None # type: List[int], List[object]
a, b, *c = 1, 2  # type: int, int, *List[int]
c = lo  # E:0: Incompatible types in assignment (expression has type List[object], variable has type List[int])
c = li
[builtins fixtures/list.pyi]

[case testAssignmentToStarCount1]
from typing import List
ca = None # type: List[int]
c = [1]
a, b, *c = 1,  # E:1: Need more than 1 value to unpack (2 expected)
a, b, *c = 1, 2
a, b, *c = 1, 2, 3
a, b, *c = 1, 2, 3, 4
[builtins fixtures/list.pyi]

[case testAssignmentToStarCount2]
from typing import List
ca = None # type: List[int]
t1 = 1,
t2 = 1, 2
t3 = 1, 2, 3
t4 = 1, 2, 3, 4
c = [1]
a, b, *c = t1  # E:1: Need more than 1 value to unpack (2 expected)
a, b, *c = t2
a, b, *c = t3
a, b, *c = t4
[builtins fixtures/list.pyi]

[case testAssignmentToStarFromAny]
from typing import Any
a, c = Any(1), C()
p, *q = a
c = a
c = q

class C: pass

[case testAssignmentToComplexStar]
from typing import List
li = None # type: List[int]
a, *(li) = 1,
a, *(b, c) = 1, 2  # E:6: Need more than 1 value to unpack (2 expected)
a, *(b, c) = 1, 2, 3
a, *(b, c) = 1, 2, 3, 4  # E:6: Too many values to unpack (2 expected, 3 provided)
[builtins fixtures/list.pyi]

[case testAssignmentToStarFromTupleType]
from typing import List, Tuple
li = None # type: List[int]
la = None # type: List[A]
ta = None # type: Tuple[A, A, A]
a, *la = ta
a, *li = ta  # E
a, *na = ta
na = la
na = a  # E

class A: pass
[builtins fixtures/list.pyi]
[out]
main:6: error: List item 0 has incompatible type "A"
main:6: error: List item 1 has incompatible type "A"
main:9:0: error: Incompatible types in assignment (expression has type "A", variable has type List[A])

[case testAssignmentToStarFromTupleInference]
from typing import List
li = None # type: List[int]
la = None # type: List[A]
a, *l = A(), A()
l = li  # E:0: Incompatible types in assignment (expression has type List[int], variable has type List[A])
l = la

class A: pass
[builtins fixtures/list.pyi]
[out]

[case testAssignmentToStarFromListInference]
from typing import List
li = None # type: List[int]
la = None # type: List[A]
a, *l = [A(), A()]
l = li  # E:0: Incompatible types in assignment (expression has type List[int], variable has type List[A])
l = la

class A: pass
[builtins fixtures/list.pyi]
[out]

[case testAssignmentToStarFromTupleTypeInference]
from typing import List, Tuple
li = None # type: List[int]
la = None # type: List[A]
ta = None # type: Tuple[A, A, A]
a, *l = ta
l = li  # E:0: Incompatible types in assignment (expression has type List[int], variable has type List[A])
l = la

class A: pass
[builtins fixtures/list.pyi]
[out]

[case testAssignmentToStarFromListTypeInference]
from typing import List
li = None # type: List[int]
la = None # type: List[A]
a, *l = la
l = li  # E:0: Incompatible types in assignment (expression has type List[int], variable has type List[A])
l = la

class A: pass
[builtins fixtures/list.pyi]
[out]


-- Nested tuple assignment
-- ----------------------------


[case testNestedTupleAssignment1]

a1, b1, c1 = None, None, None # type: (A, B, C)
a2, b2, c2 = None, None, None # type: (A, B, C)

a1, (b1, c1) = a2, (b2, c2)
a1, (a1, (b1, c1)) = a2, (a2, (b2, c2))
a1, (a1, (a1, b1)) = a1, (a1, (a1, c1))  # Fail

class A: pass
class B: pass
class C: pass
[out]
main:7:14: error: Incompatible types in assignment (expression has type "C", variable has type "B")

[case testNestedTupleAssignment2]

a1, b1, c1 = None, None, None # type: (A, B, C)
a2, b2, c2 = None, None, None # type: (A, B, C)
t = a1, b1

a2, b2 = t
(a2, b2), c2 = t, c1
(a2, c2), c2 = t, c1  # Fail
t, c2 = (a2, b2), c2
t, c2 = (a2, a2), c2  # Fail
t = a1, a1, a1  # Fail
t = a1  # Fail
a2, a2, a2 = t  # Fail
a2, = t  # Fail
a2 = t  # Fail

class A: pass
class B: pass
class C: pass
[out]
main:8:5: error: Incompatible types in assignment (expression has type "B", variable has type "C")
main:10:0: error: Incompatible types in assignment (expression has type "Tuple[A, A]", variable has type "Tuple[A, B]")
main:11:0: error: Incompatible types in assignment (expression has type "Tuple[A, A, A]", variable has type "Tuple[A, B]")
main:12:0: error: Incompatible types in assignment (expression has type "A", variable has type "Tuple[A, B]")
main:13:2: error: Need more than 2 values to unpack (3 expected)
main:14:2: error: Too many values to unpack (1 expected, 2 provided)
main:15:0: error: Incompatible types in assignment (expression has type "Tuple[A, B]", variable has type "A")


-- Error messages
-- --------------


[case testTupleErrorMessages]

a = None # type: A

(a, a) + a  # E:7: Unsupported left operand type for + (Tuple[A, ...])
a + (a, a)  # E:2: Unsupported operand types for + ("A" and "Tuple[A, A]")
f((a, a))   # E:1: Argument 1 to "f" has incompatible type "Tuple[A, A]"; expected "A"
(a, a).foo  # E:6: Tuple[A, ...] has no attribute "foo"

def f(x: 'A') -> None: pass

class A:
    def __add__(self, x: 'A') -> 'A': pass
[builtins fixtures/tuple.pyi]

[case testLargeTuplesInErrorMessages]

a = None # type: LongTypeName
a + (a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a) # Fail

class LongTypeName:
    def __add__(self, x: 'LongTypeName') -> 'LongTypeName': pass
[builtins fixtures/tuple.pyi]
[out]
main:3:2: error: Unsupported operand types for + ("LongTypeName" and tuple(length 50))


-- Tuple methods
-- -------------


[case testTupleMethods]
from typing import Tuple
t = None # type: Tuple[int, str]
i = 0
s = ''
b = bool()

s = t.__len__()  # E:0: Incompatible types in assignment (expression has type "int", variable has type "str")
i = t.__str__()  # E:0: Incompatible types in assignment (expression has type "str", variable has type "int")
i = s in t       # E:0: Incompatible types in assignment (expression has type "bool", variable has type "int")
t.foo            # E:1: Tuple[Any, ...] has no attribute "foo"

i = t.__len__()
s = t.__str__()
b = s in t

[file builtins.py]
from typing import TypeVar, Generic
_T = TypeVar('_T')
class object:
    def __init__(self) -> None: pass
class tuple(Generic[_T]):
    def __len__(self) -> int: pass
    def __str__(self) -> str: pass
    def __contains__(self, o: object) -> bool: pass
class int: pass
class str: pass
class bool: pass
class type: pass
class function: pass


-- For loop over tuple
-- -------------------


[case testForLoopOverTuple]
import typing
t = 1, 2
for x in t:
    x = 1
    x = '' # E:4: Incompatible types in assignment (expression has type "str", variable has type "int")
[builtins fixtures/for.pyi]

[case testForLoopOverEmptyTuple]
import typing
t = ()
for x in t: pass # E:4: Need type annotation for variable
[builtins fixtures/for.pyi]

[case testForLoopOverNoneValuedTuple]
import typing
t = ()
for x in None, None: pass # E:4: Need type annotation for variable
[builtins fixtures/for.pyi]

[case testForLoopOverTupleAndSubtyping]
import typing
class A: pass
class B(A): pass
for x in B(), A():
    x = A()
    x = B()
    x = '' # E:4: Incompatible types in assignment (expression has type "str", variable has type "A")
[builtins fixtures/for.pyi]

[case testTupleIterable]
y = 'a'
x = sum((1,2))
y = x # E:0: Incompatible types in assignment (expression has type "int", variable has type "str")
[builtins fixtures/tuple.pyi]


-- Tuple as a base type
-- --------------------


[case testTupleBaseClass]
import m
[file m.pyi]
from typing import Tuple
class A(Tuple[int, str]):
    def f(self, x: int) -> None:
        a, b = 1, ''
        a, b = self
        b, a = self  # Error
        self.f('')   # Error
[builtins fixtures/tuple.pyi]
[out]
main:1: note: In module imported here:
tmp/m.pyi: note: In member "f" of class "A":
tmp/m.pyi:6:8: error: Incompatible types in assignment (expression has type "int", variable has type "str")
tmp/m.pyi:6:11: error: Incompatible types in assignment (expression has type "str", variable has type "int")
tmp/m.pyi:7:14: error: Argument 1 to "f" of "A" has incompatible type "str"; expected "int"

[case testInvalidTupleBaseClass]
from typing import Tuple
class A(Tuple[int, str]): pass # E:0: Tuple[...] not supported as a base class outside a stub file
[builtins fixtures/tuple.pyi]
[out]

[case testValidTupleBaseClass]
from typing import Tuple
class A(tuple): pass
[out]

[case testTupleBaseClass2-skip]
import m
[file m.pyi]
# This doesn't work correctly -- no errors are reported (#867)
from typing import Tuple
a = None # type: A
class A(Tuple[int, str]): pass
x, y = a
x() # Expected: "int" not callable
y() # Expected: "str" not callable
[out]
(should fail)

[case testGenericClassWithTupleBaseClass]
from typing import TypeVar, Generic, Tuple
T = TypeVar('T')
class Test(Generic[T], Tuple[T]): pass
x = Test() # type: Test[int]
[builtins fixtures/tuple.pyi]
[out]
main:3:0: error: Tuple[...] not supported as a base class outside a stub file
main:4: error: Generic tuple types not supported


-- Variable-length tuples (Tuple[t, ...] with literal '...')
-- ---------------------------------------------------------


[case testIndexingVariableLengthTuple]
from typing import Tuple
x = () # type: Tuple[str, ...]
n = 5
x[n]() # E:4: "str" not callable
x[3]() # E:4: "str" not callable
[builtins fixtures/tuple.pyi]

[case testSubtypingVariableLengthTuple]
from typing import Tuple
class A: pass
class B(A): pass
def fa(t: Tuple[A, ...]) -> None: pass
def fb(t: Tuple[B, ...]) -> None: pass
ta = () # type: Tuple[A, ...]
tb = () # type: Tuple[B, ...]
fa(ta)
fa(tb)
fb(tb)
fb(ta) # E:2: Argument 1 to "fb" has incompatible type Tuple[A, ...]; expected Tuple[B, ...]
[builtins fixtures/tuple.pyi]

[case testSubtypingFixedAndVariableLengthTuples]
from typing import Tuple
class A: pass
class B(A): pass
def fa(t: Tuple[A, ...]) -> None: pass
def fb(t: Tuple[B, ...]) -> None: pass
aa = (A(), A())
ab = (A(), B())
bb = (B(), B())
fa(aa)
fa(ab)
fa(bb)
fb(bb)
fb(ab) # E:2: Argument 1 to "fb" has incompatible type "Tuple[A, B]"; expected Tuple[B, ...]
fb(aa) # E:2: Argument 1 to "fb" has incompatible type "Tuple[A, A]"; expected Tuple[B, ...]
[builtins fixtures/tuple.pyi]

[case testSubtypingTupleIsContainer]
from typing import Container
a = None  # type: Container[str]
a = ()

[case testSubtypingTupleIsSized]
from typing import Sized
a = None  # type: Sized
a = ()

[case testTupleWithStarExpr1]
# flags: --fast-parser
a = (1, 2)
b = (*a, '')
reveal_type(b)  # E: Revealed type is 'Tuple[builtins.int, builtins.int, builtins.str]'

[case testTupleWithStarExpr2]
a = [1]
b = (0, *a)
reveal_type(b)  # E: Revealed type is 'builtins.tuple[builtins.int*]'
[builtins fixtures/tuple.pyi]

[case testTupleWithStarExpr3]
a = ['']
b = (0, *a)
reveal_type(b)  # E: Revealed type is 'builtins.tuple[builtins.object*]'
c = (*a, '')
reveal_type(c)  # E: Revealed type is 'builtins.tuple[builtins.str*]'
[builtins fixtures/tuple.pyi]

[case testTupleWithStarExpr4]
a = (1, 1, 'x', 'x')
b = (1, 'x')
a = (0, *b, '')
[builtins fixtures/tuple.pyi]

[case testTupleWithUndersizedContext]
a = ([1], 'x')
a = ([], 'x', 1)  # E:0: Incompatible types in assignment (expression has type "Tuple[List[int], str, int]", variable has type "Tuple[List[int], str]")
[builtins fixtures/tuple.pyi]

[case testTupleWithOversizedContext]
a = (1, [1], 'x')
a = (1, [])  # E:0: Incompatible types in assignment (expression has type "Tuple[int, List[int]]", variable has type "Tuple[int, List[int], str]")
[builtins fixtures/tuple.pyi]

[case testTupleWithoutContext]
a = (1, [])  # E:6: Need type annotation for variable
[builtins fixtures/tuple.pyi]

[case testTupleWithUnionContext]
from typing import List, Union, Tuple
def f() -> Union[int, Tuple[List[str]]]:
    return ([],)
[builtins fixtures/tuple.pyi]

[case testTupleWithVariableSizedTupleContext]
from typing import List, Tuple
def f() -> Tuple[List[str], ...]:
    return ([],)
[builtins fixtures/tuple.pyi]
