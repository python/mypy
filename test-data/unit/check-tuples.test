-- Normal assignment and subtyping
-- -------------------------------


[case testTupleAssignmentWithTupleTypes]
from typing import Tuple
t1: Tuple[A]
t2: Tuple[B]
t3: Tuple[A, A]
t4: Tuple[A, B]
t5: Tuple[B, A]

if int():
    t1 = t2 # E: Incompatible types in assignment (expression has type "tuple[B]", variable has type "tuple[A]")
if int():
    t1 = t3 # E: Incompatible types in assignment (expression has type "tuple[A, A]", variable has type "tuple[A]")
if int():
    t3 = t1 # E: Incompatible types in assignment (expression has type "tuple[A]", variable has type "tuple[A, A]")
if int():
    t3 = t4 # E: Incompatible types in assignment (expression has type "tuple[A, B]", variable has type "tuple[A, A]")
if int():
    t3 = t5 # E: Incompatible types in assignment (expression has type "tuple[B, A]", variable has type "tuple[A, A]")

# Ok
if int():
    t1 = t1
if int():
    t2 = t2
if int():
    t3 = t3
if int():
    t4 = t4
if int():
    t5 = t5

class A: pass
class B: pass
[builtins fixtures/tuple.pyi]

[case testTupleSubtyping]
from typing import Tuple
t1: Tuple[A, A]
t2: Tuple[A, B]
t3: Tuple[B, A]

if int():
    t2 = t1  # E: Incompatible types in assignment (expression has type "tuple[A, A]", variable has type "tuple[A, B]")
    t2 = t3  # E: Incompatible types in assignment (expression has type "tuple[B, A]", variable has type "tuple[A, B]")
    t3 = t1  # E: Incompatible types in assignment (expression has type "tuple[A, A]", variable has type "tuple[B, A]")
    t3 = t2  # E: Incompatible types in assignment (expression has type "tuple[A, B]", variable has type "tuple[B, A]")

    t1 = t2
    t1 = t3

class A: pass
class B(A): pass
[builtins fixtures/tuple.pyi]

[case testTupleCompatibilityWithOtherTypes]
# flags: --no-strict-optional
from typing import Tuple
a, o = None, None # type: (A, object)
t = None # type: Tuple[A, A]

if int():
    a = t # E: Incompatible types in assignment (expression has type "tuple[A, A]", variable has type "A")
if int():
    t = o # E: Incompatible types in assignment (expression has type "object", variable has type "tuple[A, A]")
if int():
    t = a # E: Incompatible types in assignment (expression has type "A", variable has type "tuple[A, A]")
# TODO: callable types + tuples

# Ok
if int():
    o = t
if int():
    t = None

class A: pass
[builtins fixtures/tuple.pyi]

[case testNestedTupleTypes]
from typing import Tuple
t1: Tuple[A, Tuple[A, A]]
t2: Tuple[B, Tuple[B, B]]

if int():
    t2 = t1 # E: Incompatible types in assignment (expression has type "tuple[A, tuple[A, A]]", variable has type "tuple[B, tuple[B, B]]")
if int():
    t1 = t2

class A: pass
class B(A): pass
[builtins fixtures/tuple.pyi]

[case testNestedTupleTypes2]
from typing import Tuple
t1: Tuple[A, Tuple[A, A]]
t2: Tuple[B, Tuple[B, B]]

if int():
    t2 = t1 # E: Incompatible types in assignment (expression has type "tuple[A, tuple[A, A]]", variable has type "tuple[B, tuple[B, B]]")
if int():
    t1 = t2

class A: pass
class B(A): pass
[builtins fixtures/tuple.pyi]

[case testSubtypingWithTupleType]
from __future__ import annotations
from typing import Any, Tuple

tuple_aa: tuple[A, A]
Tuple_aa: Tuple[A, A]

tuple_obj: tuple[object, ...]
Tuple_obj: Tuple[object, ...]

tuple_obj_one: tuple[object]
Tuple_obj_one: Tuple[object]

tuple_obj_two: tuple[object, object]
Tuple_obj_two: Tuple[object, object]

tuple_any_implicit: tuple
Tuple_any_implicit: Tuple

tuple_any: tuple[Any, ...]
Tuple_any: Tuple[Any, ...]

tuple_any_one: tuple[Any]
Tuple_any_one: Tuple[Any]

tuple_any_two: tuple[Any, Any]
Tuple_any_two: Tuple[Any, Any]

def takes_tuple_aa(t: tuple[A, A]): ...

takes_tuple_aa(tuple_aa)
takes_tuple_aa(Tuple_aa)
takes_tuple_aa(tuple_obj)  # E: Argument 1 to "takes_tuple_aa" has incompatible type "tuple[object, ...]"; expected "tuple[A, A]"
takes_tuple_aa(Tuple_obj)  # E: Argument 1 to "takes_tuple_aa" has incompatible type "tuple[object, ...]"; expected "tuple[A, A]"
takes_tuple_aa(tuple_obj_one)  # E: Argument 1 to "takes_tuple_aa" has incompatible type "tuple[object]"; expected "tuple[A, A]"
takes_tuple_aa(Tuple_obj_one)  # E: Argument 1 to "takes_tuple_aa" has incompatible type "tuple[object]"; expected "tuple[A, A]"
takes_tuple_aa(tuple_obj_two)  # E: Argument 1 to "takes_tuple_aa" has incompatible type "tuple[object, object]"; expected "tuple[A, A]"
takes_tuple_aa(Tuple_obj_two)  # E: Argument 1 to "takes_tuple_aa" has incompatible type "tuple[object, object]"; expected "tuple[A, A]"
takes_tuple_aa(tuple_any_implicit)
takes_tuple_aa(Tuple_any_implicit)
takes_tuple_aa(tuple_any)
takes_tuple_aa(Tuple_any)
takes_tuple_aa(tuple_any_one)  # E: Argument 1 to "takes_tuple_aa" has incompatible type "tuple[Any]"; expected "tuple[A, A]"
takes_tuple_aa(Tuple_any_one)  # E: Argument 1 to "takes_tuple_aa" has incompatible type "tuple[Any]"; expected "tuple[A, A]"
takes_tuple_aa(tuple_any_two)
takes_tuple_aa(Tuple_any_two)

def takes_tuple_any_implicit(t: tuple): ...

takes_tuple_any_implicit(tuple_aa)
takes_tuple_any_implicit(Tuple_aa)
takes_tuple_any_implicit(tuple_obj)
takes_tuple_any_implicit(Tuple_obj)
takes_tuple_any_implicit(tuple_obj_one)
takes_tuple_any_implicit(Tuple_obj_one)
takes_tuple_any_implicit(tuple_obj_two)
takes_tuple_any_implicit(Tuple_obj_two)
takes_tuple_any_implicit(tuple_any_implicit)
takes_tuple_any_implicit(Tuple_any_implicit)
takes_tuple_any_implicit(tuple_any)
takes_tuple_any_implicit(Tuple_any)
takes_tuple_any_implicit(tuple_any_one)
takes_tuple_any_implicit(Tuple_any_one)
takes_tuple_any_implicit(tuple_any_two)
takes_tuple_any_implicit(Tuple_any_two)

def takes_tuple_any_one(t: tuple[Any]): ...

takes_tuple_any_one(tuple_aa)  # E: Argument 1 to "takes_tuple_any_one" has incompatible type "tuple[A, A]"; expected "tuple[Any]"
takes_tuple_any_one(Tuple_aa)  # E: Argument 1 to "takes_tuple_any_one" has incompatible type "tuple[A, A]"; expected "tuple[Any]"
takes_tuple_any_one(tuple_obj)  # E: Argument 1 to "takes_tuple_any_one" has incompatible type "tuple[object, ...]"; expected "tuple[Any]"
takes_tuple_any_one(Tuple_obj)  # E: Argument 1 to "takes_tuple_any_one" has incompatible type "tuple[object, ...]"; expected "tuple[Any]"
takes_tuple_any_one(tuple_obj_one)
takes_tuple_any_one(Tuple_obj_one)
takes_tuple_any_one(tuple_obj_two)  # E: Argument 1 to "takes_tuple_any_one" has incompatible type "tuple[object, object]"; expected "tuple[Any]"
takes_tuple_any_one(Tuple_obj_two)  # E: Argument 1 to "takes_tuple_any_one" has incompatible type "tuple[object, object]"; expected "tuple[Any]"
takes_tuple_any_one(tuple_any_implicit)
takes_tuple_any_one(Tuple_any_implicit)
takes_tuple_any_one(tuple_any)
takes_tuple_any_one(Tuple_any)
takes_tuple_any_one(tuple_any_one)
takes_tuple_any_one(Tuple_any_one)
takes_tuple_any_one(tuple_any_two)  # E: Argument 1 to "takes_tuple_any_one" has incompatible type "tuple[Any, Any]"; expected "tuple[Any]"
takes_tuple_any_one(Tuple_any_two)  # E: Argument 1 to "takes_tuple_any_one" has incompatible type "tuple[Any, Any]"; expected "tuple[Any]"

class A: pass
[builtins fixtures/tuple.pyi]

[case testSubtypingWithTupleTypeSubclass]
from __future__ import annotations
from typing import Any, Tuple

class A: ...

inst_tuple_aa: Tuple[A, A]

class tuple_aa_subclass(Tuple[A, A]): ...
inst_tuple_aa_subclass: tuple_aa_subclass

class tuple_any_subclass(Tuple[Any, ...]): ...
inst_tuple_any_subclass: tuple_any_subclass

class tuple_any_one_subclass(Tuple[Any]): ...
inst_tuple_any_one_subclass: tuple_any_one_subclass

class tuple_any_two_subclass(Tuple[Any, Any]): ...
inst_tuple_any_two_subclass: tuple_any_two_subclass

class tuple_obj_subclass(Tuple[object, ...]): ...
inst_tuple_obj_subclass: tuple_obj_subclass

class tuple_obj_one_subclass(Tuple[object]): ...
inst_tuple_obj_one_subclass: tuple_obj_one_subclass

class tuple_obj_two_subclass(Tuple[object, object]): ...
inst_tuple_obj_two_subclass: tuple_obj_two_subclass

def takes_tuple_aa(t: Tuple[A, A]): ...

takes_tuple_aa(inst_tuple_aa)
takes_tuple_aa(inst_tuple_aa_subclass)
takes_tuple_aa(inst_tuple_any_subclass)
takes_tuple_aa(inst_tuple_any_one_subclass)  # E: Argument 1 to "takes_tuple_aa" has incompatible type "tuple_any_one_subclass"; expected "tuple[A, A]"
takes_tuple_aa(inst_tuple_any_two_subclass)
takes_tuple_aa(inst_tuple_obj_subclass)  # E: Argument 1 to "takes_tuple_aa" has incompatible type "tuple_obj_subclass"; expected "tuple[A, A]"
takes_tuple_aa(inst_tuple_obj_one_subclass)  # E: Argument 1 to "takes_tuple_aa" has incompatible type "tuple_obj_one_subclass"; expected "tuple[A, A]"
takes_tuple_aa(inst_tuple_obj_two_subclass)  # E: Argument 1 to "takes_tuple_aa" has incompatible type "tuple_obj_two_subclass"; expected "tuple[A, A]"

def takes_tuple_aa_subclass(t: tuple_aa_subclass): ...

takes_tuple_aa_subclass(inst_tuple_aa)  # E: Argument 1 to "takes_tuple_aa_subclass" has incompatible type "tuple[A, A]"; expected "tuple_aa_subclass"
takes_tuple_aa_subclass(inst_tuple_aa_subclass)
takes_tuple_aa_subclass(inst_tuple_any_subclass)  # E: Argument 1 to "takes_tuple_aa_subclass" has incompatible type "tuple_any_subclass"; expected "tuple_aa_subclass"
takes_tuple_aa_subclass(inst_tuple_any_one_subclass)  # E: Argument 1 to "takes_tuple_aa_subclass" has incompatible type "tuple_any_one_subclass"; expected "tuple_aa_subclass"
takes_tuple_aa_subclass(inst_tuple_any_two_subclass)  # E: Argument 1 to "takes_tuple_aa_subclass" has incompatible type "tuple_any_two_subclass"; expected "tuple_aa_subclass"
takes_tuple_aa_subclass(inst_tuple_obj_subclass)  # E: Argument 1 to "takes_tuple_aa_subclass" has incompatible type "tuple_obj_subclass"; expected "tuple_aa_subclass"
takes_tuple_aa_subclass(inst_tuple_obj_one_subclass)  # E: Argument 1 to "takes_tuple_aa_subclass" has incompatible type "tuple_obj_one_subclass"; expected "tuple_aa_subclass"
takes_tuple_aa_subclass(inst_tuple_obj_two_subclass)  # E: Argument 1 to "takes_tuple_aa_subclass" has incompatible type "tuple_obj_two_subclass"; expected "tuple_aa_subclass"

[builtins fixtures/tuple.pyi]

[case testTupleInitializationWithNone]
# flags: --no-strict-optional
from typing import Tuple
t = None # type: Tuple[A, A]
t = None
class A: pass
[builtins fixtures/tuple.pyi]


-- Tuple expressions
-- -----------------


[case testTupleExpressions]
# flags: --no-strict-optional
from typing import Tuple
t1 = None # type: tuple
t2 = None # type: Tuple[A]
t3 = None # type: Tuple[A, B]

a, b, c = None, None, None # type: (A, B, C)

if int():
    t2 = ()        # E: Incompatible types in assignment (expression has type "tuple[()]", variable has type "tuple[A]")
if int():
    t2 = (a, a)    # E: Incompatible types in assignment (expression has type "tuple[A, A]", variable has type "tuple[A]")
if int():
    t3 = (a, a)    # E: Incompatible types in assignment (expression has type "tuple[A, A]", variable has type "tuple[A, B]")
if int():
    t3 = (b, b)    # E: Incompatible types in assignment (expression has type "tuple[B, B]", variable has type "tuple[A, B]")
if int():
    t3 = (a, b, a) # E: Incompatible types in assignment (expression has type "tuple[A, B, A]", variable has type "tuple[A, B]")

t1 = ()
t1 = (a,)
t2 = (a,)
t3 = (a, b)
t3 = (a, c)
t3 = (None, None)

class A: pass
class B: pass
class C(B): pass
[builtins fixtures/tuple.pyi]

[case testVoidValueInTuple]
import typing
def f() -> None: pass

(None, f()) # E: "f" does not return a value (it only ever returns None)
(f(), None) # E: "f" does not return a value (it only ever returns None)
[builtins fixtures/tuple.pyi]


-- Indexing
-- --------


[case testIndexingTuples]
from typing import Tuple
t1: Tuple[A, B]
t2: Tuple[A]
t3: Tuple[A, B, C, D, E]
a: A
b: B
x: Tuple[A, B, C]
y: Tuple[A, C, E]
n = 0

if int():
    a = t1[1] # E: Incompatible types in assignment (expression has type "B", variable has type "A")
if int():
    b = t1[0] # E: Incompatible types in assignment (expression has type "A", variable has type "B")
t1[2]     # E: Tuple index out of range
t1[3]     # E: Tuple index out of range
t2[1]     # E: Tuple index out of range
reveal_type(t1[n])     # N: Revealed type is "Union[__main__.A, __main__.B]"
reveal_type(t3[n:])    # N: Revealed type is "builtins.tuple[Union[__main__.A, __main__.B, __main__.C, __main__.D, __main__.E], ...]"
if int():
    b = t1[(0)] # E: Incompatible types in assignment (expression has type "A", variable has type "B")

if int():
    a = t1[0]
if int():
    b = t1[1]
if int():
    b = t1[-1]
if int():
    a = t1[(0)]
if int():
    b = t1[+1]
if int():
    x = t3[0:3] # type (A, B, C)
if int():
    y = t3[0:+5:2] # type (A, C, E)
if int():
    x = t3[:-2] # type (A, B, C)

class A: pass
class B: pass
class C: pass
class D: pass
class E: pass
[builtins fixtures/tuple.pyi]

[case testIndexingTuplesWithNegativeIntegers]
from typing import Tuple
t1: Tuple[A, B]
t2: Tuple[A]
a: A
b: B

if int():
    a = t1[-1] # E: Incompatible types in assignment (expression has type "B", variable has type "A")
if int():
    b = t1[-2] # E: Incompatible types in assignment (expression has type "A", variable has type "B")
t1[-3]     # E: Tuple index out of range
t1[-4]     # E: Tuple index out of range
if int():
    b = t2[(-1)] # E: Incompatible types in assignment (expression has type "A", variable has type "B")

if int():
    a = t1[-2]
if int():
    b = t1[-1]
if int():
    a = t2[(-1)]

class A: pass
class B: pass
[builtins fixtures/tuple.pyi]

[case testAssigningToTupleItems]
from typing import Tuple

class A: pass
class B: pass

t: Tuple[A, B]
n = 0

t[0] = A() # E: Unsupported target for indexed assignment ("tuple[A, B]")
t[2] = A() # E: Unsupported target for indexed assignment ("tuple[A, B]")
t[n] = A() # E: Unsupported target for indexed assignment ("tuple[A, B]")
[builtins fixtures/tuple.pyi]


-- Multiple assignment
-- -------------------


[case testMultipleAssignmentWithTuples]
# flags: --no-strict-optional
from typing import Tuple
t1 = None # type: Tuple[A, B]
t2 = None # type: Tuple[A, B, A]
a, b = None, None # type: (A, B)
(a1, b1) = None, None # type: Tuple[A, B]

reveal_type(a1)  # N: Revealed type is "__main__.A"
reveal_type(b1)  # N: Revealed type is "__main__.B"

if int():
    a, a = t1 # E: Incompatible types in assignment (expression has type "B", variable has type "A")
if int():
    b, b = t1 # E: Incompatible types in assignment (expression has type "A", variable has type "B")
if int():
    a, b, b = t2 # E: Incompatible types in assignment (expression has type "A", variable has type "B")

if int():
    a, b = t1
if int():
    a, b, a1 = t2

class A: pass
class B: pass
[builtins fixtures/tuple.pyi]

[case testMultipleAssignmentWithSquareBracketTuples]
# flags: --no-strict-optional
from typing import Tuple

def avoid_confusing_test_parser() -> None:
    t1 = None # type: Tuple[A, B]
    t2 = None # type: Tuple[A, B, A]
    [a, b] = None, None # type: (A, B)
    [a1, b1] = None, None # type: Tuple[A, B]

    reveal_type(a)  # N: Revealed type is "__main__.A"
    reveal_type(b)  # N: Revealed type is "__main__.B"
    reveal_type(a1)  # N: Revealed type is "__main__.A"
    reveal_type(b1)  # N: Revealed type is "__main__.B"

    if int():
        [a, a] = t1 # E: Incompatible types in assignment (expression has type "B", variable has type "A")
        [b, b] = t1 # E: Incompatible types in assignment (expression has type "A", variable has type "B")
        [a, b, b] = t2 # E: Incompatible types in assignment (expression has type "A", variable has type "B")

        [a, b] = t1
        [a, b, a1] = t2

        [a2, b2] = t1
        reveal_type(a2)  # N: Revealed type is "__main__.A"
        reveal_type(b2)  # N: Revealed type is "__main__.B"

class A: pass
class B: pass
[builtins fixtures/tuple.pyi]

[case testMultipleAssignmentWithInvalidNumberOfValues]
from typing import Tuple
t1: Tuple[A, A, A]
a: A

a, a = t1       # E: Too many values to unpack (2 expected, 3 provided)
a, a, a, a = t1 # E: Need more than 3 values to unpack (4 expected)

a, a, a = t1

class A: pass
[builtins fixtures/tuple.pyi]

[case testMultipleAssignmentWithTupleExpressionRvalue]
a: A
b: B

if int():
    a, b = a, a # E: Incompatible types in assignment (expression has type "A", variable has type "B")
if int():
    a, b = b, a \
      # E: Incompatible types in assignment (expression has type "B", variable has type "A") \
      # E: Incompatible types in assignment (expression has type "A", variable has type "B")

if int():
    a, b = a, b
if int():
    a, a = a, a

class A: pass
class B: pass
[builtins fixtures/tuple.pyi]

[case testSubtypingInMultipleAssignment]
a: A
b: B

if int():
    b, b = a, b # E: Incompatible types in assignment (expression has type "A", variable has type "B")
if int():
    b, b = b, a # E: Incompatible types in assignment (expression has type "A", variable has type "B")

if int():
    a, b = b, b
if int():
    b, a = b, b

class A: pass
class B(A): pass
[builtins fixtures/tuple.pyi]

[case testInitializationWithMultipleValues]
# flags: --no-strict-optional
a, b = None, None # type: (A, B)

a1, b1 = a, a # type: (A, B)  # E: Incompatible types in assignment (expression has type "A", variable has type "B")
a2, b2 = b, b # type: (A, B)  # E: Incompatible types in assignment (expression has type "B", variable has type "A")
a3, b3 = a # type: (A, B)     # E: "A" object is not iterable
a4, b4 = None # type: (A, B)  # E: "None" object is not iterable
a5, b5 = a, b, a # type: (A, B)  # E: Too many values to unpack (2 expected, 3 provided)

ax, bx = a, b # type: (A, B)

class A: pass
class B: pass
[builtins fixtures/tuple.pyi]

[case testMultipleAssignmentWithNonTupleRvalue]
a: A
b: B
def f(): pass

a, b = None # E: "None" object is not iterable
a, b = a   # E: "A" object is not iterable
a, b = f   # E: "Callable[[], Any]" object is not iterable

class A: pass
class B: pass
[builtins fixtures/tuple.pyi]

[case testMultipleAssignmentWithIndexedLvalues]
a: A
b: B
aa: AA
bb: BB

a[a], b[b] = a, bb   # E: Incompatible types in assignment (expression has type "A", target has type "AA")
a[a], b[b] = aa, b   # E: Incompatible types in assignment (expression has type "B", target has type "BB")
a[aa], b[b] = aa, bb # E: Invalid index type "AA" for "A"; expected type "A"
a[a], b[bb] = aa, bb # E: Invalid index type "BB" for "B"; expected type "B"
a[a], b[b] = aa, bb

class A:
    def __setitem__(self, x: 'A', y: 'AA') -> None: pass
class B:
    def __setitem__(self, x: 'B', y: 'BB') -> None: pass

class AA: pass
class BB: pass
[builtins fixtures/tuple.pyi]

[case testMultipleDeclarationWithParentheses]
# flags: --no-strict-optional
(a, b) = (None, None) # type: int, str
if int():
    a = '' # E: Incompatible types in assignment (expression has type "str", variable has type "int")
    b = 1  # E: Incompatible types in assignment (expression has type "int", variable has type "str")
if int():
    a = 1
    b = ''
[builtins fixtures/tuple.pyi]

[case testMultipleAssignmentWithExtraParentheses]
a: A
b: B

if int():
    (a, b) = (a, a) # E: Incompatible types in assignment (expression has type "A", variable has type "B")
if int():
    (a, b) = (b, b) # E: Incompatible types in assignment (expression has type "B", variable has type "A")
if int():
    ((a), (b)) = ((a), (a))  # E: Incompatible types in assignment (expression has type "A", variable has type "B")
if int():
    ((a), (b)) = ((b), (b))  # E: Incompatible types in assignment (expression has type "B", variable has type "A")
if int():
    [a, b] = a, a  # E: Incompatible types in assignment (expression has type "A", variable has type "B")
if int():
    [a, b] = b, b  # E: Incompatible types in assignment (expression has type "B", variable has type "A")

if int():
    (a, b) = (a, b)
if int():
    ((a), (b)) = ((a), (b))
if int():
    [a, b] = a, b

class A: pass
class B: pass
[builtins fixtures/tuple.pyi]

[case testMultipleAssignmentUsingSingleTupleType]
# flags: --no-strict-optional
from typing import Tuple
a, b = None, None  # type: Tuple[int, str]
if int():
    a = 1
if int():
    b = ''
if int():
    a = '' # E: Incompatible types in assignment (expression has type "str", variable has type "int")
if int():
    b = 1  # E: Incompatible types in assignment (expression has type "int", variable has type "str")
[builtins fixtures/tuple.pyi]

[case testMultipleAssignmentWithMixedVariables]
a = b, c = 1, 1
x, y = p, q = 1, 1
u, v, w = r, s = 1, 1 # E: Need more than 2 values to unpack (3 expected)
d, e = f, g, h = 1, 1 # E: Need more than 2 values to unpack (3 expected)
[builtins fixtures/tuple.pyi]

[case testUnpackAssignmentWithStarExpr]
a: A
b: list[B]
if int():
    (a,) = (*b,)  # E: Incompatible types in assignment (expression has type "B", variable has type "A")

class A: pass
class B: pass


-- Assignment to starred expressions
-- ---------------------------------


[case testAssignmentToStarMissingAnnotation]
from typing import List
t = 1, 2
a, b, *c = 1, 2  # E: Need type annotation for "c" (hint: "c: list[<type>] = ...")
aa, bb, *cc = t  # E: Need type annotation for "cc" (hint: "cc: list[<type>] = ...")
[builtins fixtures/list.pyi]

[case testAssignmentToStarAnnotation]
# flags: --no-strict-optional
from typing import List
li, lo = None, None # type: List[int], List[object]
a, b, *c = 1, 2  # type: int, int, List[int]
if int():
    c = lo  # E: Incompatible types in assignment (expression has type "list[object]", variable has type "list[int]")
if int():
    c = li
[builtins fixtures/list.pyi]

[case testAssignmentToStarCount1]
from typing import List
ca: List[int]
c = [1]
if int():
    a, b, *c = 1,  # E: Need more than 1 value to unpack (2 expected)
if int():
    a, b, *c = 1, 2
if int():
    a, b, *c = 1, 2, 3
if int():
    a, b, *c = 1, 2, 3, 4
[builtins fixtures/list.pyi]

[case testAssignmentToStarCount2]
from typing import List
ca: List[int]
t1 = 1,
t2 = 1, 2
t3 = 1, 2, 3
t4 = 1, 2, 3, 4
c = [1]
if int():
    a, b, *c = t1  # E: Need more than 1 value to unpack (2 expected)
if int():
    a, b, *c = t2
if int():
    a, b, *c = t3
if int():
    a, b, *c = t4
[builtins fixtures/list.pyi]

[case testAssignmentToStarFromAny]
from typing import Any, cast
class C: pass

a, c = cast(Any, 1), C()
p, *q = a
c = a
c = q
[case testAssignmentToComplexStar]
from typing import List
li: List[int]
if int():
    a, *(li) = 1,
a, *(b, c) = 1, 2  # E: Need more than 1 value to unpack (2 expected)
if int():
    a, *(b, c) = 1, 2, 3
if int():
    a, *(b, c) = 1, 2, 3, 4  # E: Too many values to unpack (2 expected, 3 provided)
[builtins fixtures/list.pyi]

[case testAssignmentToStarFromTupleType]
from typing import List, Tuple
li: List[int]
la: List[A]
ta: Tuple[A, A, A]
if int():
    a, *la = ta
if int():
    a, *li = ta  # E: List item 0 has incompatible type "A"; expected "int" \
                 # E: List item 1 has incompatible type "A"; expected "int"
if int():
    a, *na = ta
    if int():
        na = la
        na = a  # E: Incompatible types in assignment (expression has type "A", variable has type "list[A]")

class A: pass
[builtins fixtures/list.pyi]

[case testAssignmentToStarFromTupleInference]
from typing import List
class A: pass
li: List[int]
la: List[A]
a, *l = A(), A()
if int():
    l = li  # E: Incompatible types in assignment (expression has type "list[int]", variable has type "list[A]")
if int():
    l = la
[builtins fixtures/list.pyi]
[out]

[case testAssignmentToStarFromListInference]
from typing import List

class A: pass

li: List[int]
la: List[A]
a, *l = [A(), A()]
if int():
    l = li  # E: Incompatible types in assignment (expression has type "list[int]", variable has type "list[A]")
if int():
    l = la
[builtins fixtures/list.pyi]
[out]

[case testAssignmentToStarFromTupleTypeInference]
from typing import List, Tuple
li: List[int]
la: List[A]
ta: Tuple[A, A, A]
a, *l = ta
if int():
    l = li  # E: Incompatible types in assignment (expression has type "list[int]", variable has type "list[A]")
if int():
    l = la

class A: pass
[builtins fixtures/list.pyi]
[out]

[case testAssignmentToStarFromListTypeInference]
from typing import List
li: List[int]
la: List[A]
a, *l = la
if int():
    l = li  # E: Incompatible types in assignment (expression has type "list[int]", variable has type "list[A]")
if int():
    l = la

class A: pass
[builtins fixtures/list.pyi]
[out]

[case testAssignmentToStarFromIterable]
from typing import List, Tuple, Iterable

class CustomIterable(Iterable[int]): pass

a: List[int]
b: Tuple[int, ...]
c: Tuple[int, int, int]
d: Iterable[int]
e: CustomIterable

a1, *a2 = a
b1, *b2 = b
c1, *c2 = c
d1, *d2 = d
e1, *e2 = e

reveal_type(a2)  # N: Revealed type is "builtins.list[builtins.int]"
reveal_type(b2)  # N: Revealed type is "builtins.list[builtins.int]"
reveal_type(c2)  # N: Revealed type is "builtins.list[builtins.int]"
reveal_type(d2)  # N: Revealed type is "builtins.list[builtins.int]"
reveal_type(e2)  # N: Revealed type is "builtins.list[builtins.int]"
[builtins fixtures/tuple.pyi]

-- Nested tuple assignment
-- ----------------------------


[case testNestedTupleAssignment1]
a1: A
a2: A
b1: B
b2: B
c1: C
c2: C

if int():
    a1, (b1, c1) = a2, (b2, c2)
if int():
    a1, (a1, (b1, c1)) = a2, (a2, (b2, c2))
if int():
    a1, (a1, (a1, b1)) = a1, (a1, (a1, c1))  # E: Incompatible types in assignment (expression has type "C", variable has type "B")

class A: pass
class B: pass
class C: pass
[builtins fixtures/tuple.pyi]

[case testNestedTupleAssignment2]
a1: A
a2: A
b1: B
b2: B
c1: C
c2: C
t = a1, b1

if int():
    a2, b2 = t
if int():
    (a2, b2), c2 = t, c1
if int():
    (a2, c2), c2 = t, c1  # E: Incompatible types in assignment (expression has type "B", variable has type "C")
if int():
    t, c2 = (a2, b2), c2
if int():
    t, c2 = (a2, a2), c2  # E: Incompatible types in assignment (expression has type "tuple[A, A]", variable has type "tuple[A, B]")
if int():
    t = a1, a1, a1  # E: Incompatible types in assignment (expression has type "tuple[A, A, A]", variable has type "tuple[A, B]")
if int():
    t = a1  # E: Incompatible types in assignment (expression has type "A", variable has type "tuple[A, B]")
if int():
    a2, a2, a2 = t  # E: Need more than 2 values to unpack (3 expected)
if int():
    a2, = t  # E: Too many values to unpack (1 expected, 2 provided)
if int():
    a2 = t  # E: Incompatible types in assignment (expression has type "tuple[A, B]", variable has type "A")

class A: pass
class B: pass
class C: pass
[builtins fixtures/tuple.pyi]


-- Error messages
-- --------------


[case testTupleErrorMessages]
class A:
    def __add__(self, x: 'A') -> 'A': pass
def f(x: 'A') -> None: pass

a: A

(a, a) + a  # E: Unsupported operand types for + ("tuple[A, A]" and "A")
a + (a, a)  # E: Unsupported operand types for + ("A" and "tuple[A, A]")
f((a, a))   # E: Argument 1 to "f" has incompatible type "tuple[A, A]"; expected "A"
(a, a).foo  # E: "tuple[A, A]" has no attribute "foo"
[builtins fixtures/tuple.pyi]

[case testLargeTuplesInErrorMessages]

a: LongTypeName
a + (a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a) # Fail

class LongTypeName:
    def __add__(self, x: 'LongTypeName') -> 'LongTypeName': pass
[builtins fixtures/tuple.pyi]
[out]
main:3: error: Unsupported operand types for + ("LongTypeName" and "tuple[LongTypeName, LongTypeName, LongTypeName, LongTypeName, LongTypeName, LongTypeName, LongTypeName, LongTypeName, LongTypeName, LongTypeName, LongTypeName, LongTypeName, LongTypeName, LongTypeName, LongTypeName, LongTypeName, LongTypeName, LongTypeName, LongTypeName, LongTypeName, LongTypeName, LongTypeName, LongTypeName, LongTypeName, LongTypeName, LongTypeName, LongTypeName, LongTypeName, LongTypeName, LongTypeName, LongTypeName, LongTypeName, LongTypeName, LongTypeName, LongTypeName, LongTypeName, LongTypeName, LongTypeName, LongTypeName, LongTypeName, LongTypeName, LongTypeName, LongTypeName, LongTypeName, LongTypeName, LongTypeName, LongTypeName, LongTypeName, LongTypeName, LongTypeName]")


-- Tuple methods
-- -------------


[case testTupleMethods]
from typing import Tuple
t: Tuple[int, str]
i = 0
s = ''
b = bool()

if int():
    s = t.__len__()  # E: Incompatible types in assignment (expression has type "int", variable has type "str")
if int():
    i = t.__str__()  # E: Incompatible types in assignment (expression has type "str", variable has type "int")
if int():
    i = s in t       # E: Incompatible types in assignment (expression has type "bool", variable has type "int")
t.foo            # E: "tuple[int, str]" has no attribute "foo"

if int():
    i = t.__len__()
if int():
    s = t.__str__()
if int():
    b = s in t

[file builtins.py]
from typing import TypeVar, Generic
_T = TypeVar('_T')
class object:
    def __init__(self) -> None: pass
class tuple(Generic[_T]):
    def __len__(self) -> int: pass
    def __str__(self) -> str: pass
    def __contains__(self, o: object) -> bool: pass
class int: pass
class str: pass
class bool: pass
class type: pass
class function: pass
class dict: pass


-- For loop over tuple
-- -------------------


[case testForLoopOverTuple]
import typing
t = 1, 2
for x in t:
    x = 1
    x = '' # E: Incompatible types in assignment (expression has type "str", variable has type "int")
[builtins fixtures/for.pyi]

[case testForLoopOverEmptyTuple]
import typing
t = ()
for x in t: pass  # E: Need type annotation for "x"
[builtins fixtures/for.pyi]

[case testForLoopOverNoneValuedTuple]
import typing
for x in None, None: pass
[builtins fixtures/for.pyi]

[case testForLoopOverTupleAndSubtyping]
import typing
class A: pass
class B(A): pass
for x in B(), A():
    x = A()
    x = B()
    x = '' # E: Incompatible types in assignment (expression has type "str", variable has type "A")
[builtins fixtures/for.pyi]

[case testTupleIterable]
from typing import Iterable, Optional, TypeVar

T = TypeVar("T")

def sum(iterable: Iterable[T], start: Optional[T] = None) -> T: pass

y = 'a'
x = sum((1,2))
if int():
    y = x # E: Incompatible types in assignment (expression has type "int", variable has type "str")
[builtins fixtures/tuple.pyi]


-- Tuple as a base type
-- --------------------


[case testTupleBaseClass]
import m
[file m.pyi]
from typing import Tuple
class A(Tuple[int, str]):
    def f(self, x: int) -> None:
        a, b = 1, ''
        if int():
            a, b = self
            b, a = self  # Error
        self.f('')   # Error
[builtins fixtures/tuple.pyi]
[out]
tmp/m.pyi:7: error: Incompatible types in assignment (expression has type "int", variable has type "str")
tmp/m.pyi:7: error: Incompatible types in assignment (expression has type "str", variable has type "int")
tmp/m.pyi:8: error: Argument 1 to "f" of "A" has incompatible type "str"; expected "int"

[case testValidTupleBaseClass2]
from typing import Tuple
class A(Tuple[int, str]): pass

x, y = A()
reveal_type(x) # N: Revealed type is "builtins.int"
reveal_type(y) # N: Revealed type is "builtins.str"

x1 = A()[0] # type: int
x2 = A()[1] # type: int # E: Incompatible types in assignment (expression has type "str", variable has type "int")
A()[2] # E: Tuple index out of range

class B(Tuple[int, ...]): pass

z1 = B()[0] # type: int
z2 = B()[1] # type: str # E: Incompatible types in assignment (expression has type "int", variable has type "str")
B()[100]
[builtins fixtures/tuple.pyi]
[out]

[case testValidTupleBaseClass]
from typing import Tuple
class A(tuple): pass
[builtins fixtures/tuple.pyi]
[out]

[case testTupleBaseClass2]
import m
[file m.pyi]
from typing import Tuple
a: A
class A(Tuple[int, str]): pass
x, y = a
x() # E: "int" not callable
y() # E: "str" not callable
[builtins fixtures/tuple.pyi]
[out]

[case testGenericClassWithTupleBaseClass]
from typing import TypeVar, Generic, Tuple
T = TypeVar('T')
class Test(Generic[T], Tuple[T]): pass
x = Test() # type: Test[int]
reveal_type(x)  # N: Revealed type is "tuple[builtins.int, fallback=__main__.Test[builtins.int]]"
[builtins fixtures/tuple.pyi]
[out]


-- Variable-length tuples (Tuple[t, ...] with literal '...')
-- ---------------------------------------------------------


[case testIndexingVariableLengthTuple]
from typing import Tuple
x = () # type: Tuple[str, ...]
n = 5
x[n]() # E: "str" not callable
x[3]() # E: "str" not callable
[builtins fixtures/tuple.pyi]

[case testSubtypingVariableLengthTuple]
from typing import Tuple
class A: pass
class B(A): pass
def fa(t: Tuple[A, ...]) -> None: pass
def fb(t: Tuple[B, ...]) -> None: pass
ta = () # type: Tuple[A, ...]
tb = () # type: Tuple[B, ...]
fa(ta)
fa(tb)
fb(tb)
fb(ta) # E: Argument 1 to "fb" has incompatible type "tuple[A, ...]"; expected "tuple[B, ...]"
[builtins fixtures/tuple.pyi]

[case testSubtypingFixedAndVariableLengthTuples]
from typing import Tuple
class A: pass
class B(A): pass
def fa(t: Tuple[A, ...]) -> None: pass
def fb(t: Tuple[B, ...]) -> None: pass
aa = (A(), A())
ab = (A(), B())
bb = (B(), B())
fa(aa)
fa(ab)
fa(bb)
fb(bb)
fb(ab) # E: Argument 1 to "fb" has incompatible type "tuple[A, B]"; expected "tuple[B, ...]"
fb(aa) # E: Argument 1 to "fb" has incompatible type "tuple[A, A]"; expected "tuple[B, ...]"
[builtins fixtures/tuple.pyi]

[case testSubtypingTupleIsContainer]
from typing import Container
a: Container[str]
a = ()
[typing fixtures/typing-full.pyi]
[builtins fixtures/tuple.pyi]

[case testSubtypingTupleIsSized]
from typing import Sized
a: Sized
a = ()
[typing fixtures/typing-medium.pyi]
[builtins fixtures/tuple.pyi]

[case testTupleWithStarExpr1]

a = (1, 2)
b = (*a, '')
reveal_type(b)  # N: Revealed type is "tuple[builtins.int, builtins.int, builtins.str]"
[builtins fixtures/tuple.pyi]

[case testTupleWithStarExpr2]
a = [1]
b = (0, *a)
reveal_type(b)  # N: Revealed type is "builtins.tuple[builtins.int, ...]"
[builtins fixtures/tuple.pyi]

[case testTupleWithStarExpr2Precise]
# flags: --enable-incomplete-feature=PreciseTupleTypes
a = [1]
b = (0, *a)
reveal_type(b)  # N: Revealed type is "tuple[builtins.int, Unpack[builtins.tuple[builtins.int, ...]]]"
[builtins fixtures/tuple.pyi]

[case testTupleWithStarExpr3]
a = ['']
b = (0, *a)
reveal_type(b)  # N: Revealed type is "builtins.tuple[builtins.object, ...]"
c = (*a, '')
reveal_type(c)  # N: Revealed type is "builtins.tuple[builtins.str, ...]"
[builtins fixtures/tuple.pyi]

[case testTupleWithStarExpr3Precise]
# flags: --enable-incomplete-feature=PreciseTupleTypes
a = ['']
b = (0, *a)
reveal_type(b)  # N: Revealed type is "tuple[builtins.int, Unpack[builtins.tuple[builtins.str, ...]]]"
c = (*a, '')
reveal_type(c)  # N: Revealed type is "tuple[Unpack[builtins.tuple[builtins.str, ...]], builtins.str]"
[builtins fixtures/tuple.pyi]

[case testTupleWithStarExpr4]
a = (1, 1, 'x', 'x')
b = (1, 'x')
a = (0, *b, '')
[builtins fixtures/tuple.pyi]

[case testUnpackSyntaxError]
*foo  # E: can't use starred expression here
[builtins fixtures/tuple.pyi]

[case testUnpackBases]
class A: ...
class B: ...
bases = (A, B)
class C(*bases): ...  # E: Invalid base class
[builtins fixtures/tuple.pyi]

[case testTupleMeetTupleAny]
from typing import Union, Tuple
class A: pass
class B: pass

def f(x: Union[B, Tuple[A, A]]) -> None:
    if isinstance(x, tuple):
        reveal_type(x) # N: Revealed type is "tuple[__main__.A, __main__.A]"
    else:
        reveal_type(x) # N: Revealed type is "__main__.B"

def g(x: Union[str, Tuple[str, str]]) -> None:
    if isinstance(x, tuple):
        reveal_type(x) # N: Revealed type is "tuple[builtins.str, builtins.str]"
    else:
        reveal_type(x) # N: Revealed type is "builtins.str"

[builtins fixtures/tuple.pyi]
[out]

[case testTupleMeetTupleAnyComplex]
from typing import Tuple, Union

Pair = Tuple[int, int]
Variant = Union[int, Pair]
def tuplify(v: Variant) -> None:
    reveal_type(v) # N: Revealed type is "Union[builtins.int, tuple[builtins.int, builtins.int]]"
    if not isinstance(v, tuple):
        reveal_type(v) # N: Revealed type is "builtins.int"
        v = (v, v)
        reveal_type(v) # N: Revealed type is "tuple[builtins.int, builtins.int]"
    reveal_type(v) # N: Revealed type is "tuple[builtins.int, builtins.int]"
    reveal_type(v[0]) # N: Revealed type is "builtins.int"

Pair2 = Tuple[int, str]
Variant2 = Union[int, Pair2]
def tuplify2(v: Variant2) -> None:
    if isinstance(v, tuple):
        reveal_type(v) # N: Revealed type is "tuple[builtins.int, builtins.str]"
    else:
        reveal_type(v) # N: Revealed type is "builtins.int"
[builtins fixtures/tuple.pyi]
[out]

[case testTupleMeetTupleAnyAfter]
from typing import Tuple, Union

def good(blah: Union[Tuple[int, int], int]) -> None:
    reveal_type(blah) # N: Revealed type is "Union[tuple[builtins.int, builtins.int], builtins.int]"
    if isinstance(blah, tuple):
        reveal_type(blah) # N: Revealed type is "tuple[builtins.int, builtins.int]"
    reveal_type(blah) # N: Revealed type is "Union[tuple[builtins.int, builtins.int], builtins.int]"
[builtins fixtures/tuple.pyi]
[out]

[case testTupleMeetTupleVariable]
from typing import Tuple, TypeVar, Generic, Union
T = TypeVar('T')

class A: pass
class B1(A): pass
class B2(A): pass
class C: pass

x: Tuple[A, ...]
y: Tuple[Union[B1, C], Union[B2, C]]

def g(x: T) -> Tuple[T, T]:
    return (x, x)

z = 1
x, y = g(z) # E: Argument 1 to "g" has incompatible type "int"; expected "tuple[B1, B2]"
[builtins fixtures/tuple.pyi]
[out]

[case testFixedTupleJoinVarTuple]
from typing import Tuple, TypeVar

class A: pass
class B(A): pass

fixtup: Tuple[B, B]

T = TypeVar("T")
def join(x: T, y: T) -> T: ...

vartup_b: Tuple[B, ...]
reveal_type(join(fixtup, vartup_b))  # N: Revealed type is "builtins.tuple[__main__.B, ...]"
reveal_type(join(vartup_b, fixtup))  # N: Revealed type is "builtins.tuple[__main__.B, ...]"

vartup_a: Tuple[A, ...]
reveal_type(join(fixtup, vartup_a))  # N: Revealed type is "builtins.tuple[__main__.A, ...]"
reveal_type(join(vartup_a, fixtup))  # N: Revealed type is "builtins.tuple[__main__.A, ...]"

[builtins fixtures/tuple.pyi]
[out]

[case testFixedTupleJoinList]
from typing import Tuple, List, TypeVar

class A: pass
class B(A): pass

fixtup: Tuple[B, B]

T = TypeVar("T")
def join(x: T, y: T) -> T: ...

lst_b: List[B]
reveal_type(join(fixtup, lst_b))  # N: Revealed type is "typing.Sequence[__main__.B]"
reveal_type(join(lst_b, fixtup))  # N: Revealed type is "typing.Sequence[__main__.B]"

lst_a: List[A]
reveal_type(join(fixtup, lst_a))  # N: Revealed type is "typing.Sequence[__main__.A]"
reveal_type(join(lst_a, fixtup))  # N: Revealed type is "typing.Sequence[__main__.A]"

[builtins fixtures/tuple.pyi]
[out]

[case testEmptyTupleJoin]
from typing import Tuple, List, TypeVar

class A: pass

empty = ()

T = TypeVar("T")
def join(x: T, y: T) -> T: ...

fixtup: Tuple[A]
reveal_type(join(fixtup, empty))  # N: Revealed type is "builtins.tuple[__main__.A, ...]"
reveal_type(join(empty, fixtup))  # N: Revealed type is "builtins.tuple[__main__.A, ...]"

vartup: Tuple[A, ...]
reveal_type(join(vartup, empty))  # N: Revealed type is "builtins.tuple[__main__.A, ...]"
reveal_type(join(empty, vartup))  # N: Revealed type is "builtins.tuple[__main__.A, ...]"

lst: List[A]
reveal_type(join(empty, lst))  # N: Revealed type is "typing.Sequence[__main__.A]"
reveal_type(join(lst, empty))  # N: Revealed type is "typing.Sequence[__main__.A]"

[builtins fixtures/tuple.pyi]
[out]

[case testTupleSubclassJoin]
from typing import Tuple, NamedTuple, TypeVar

class NTup(NamedTuple):
    a: bool
    b: bool

class SubTuple(Tuple[bool]): ...
class SubVarTuple(Tuple[int, ...]): ...

ntup: NTup
subtup: SubTuple
vartup: SubVarTuple

T = TypeVar("T")
def join(x: T, y: T) -> T: ...

reveal_type(join(ntup, vartup))  # N: Revealed type is "builtins.tuple[builtins.int, ...]"
reveal_type(join(subtup, vartup))  # N: Revealed type is "builtins.tuple[builtins.int, ...]"

[builtins fixtures/tuple.pyi]
[out]

[case testTupleJoinIrregular]
from typing import Tuple, TypeVar

tup1: Tuple[bool, int]
tup2: Tuple[bool]

T = TypeVar("T")
def join(x: T, y: T) -> T: ...

reveal_type(join(tup1, tup2))  # N: Revealed type is "builtins.tuple[builtins.int, ...]"
reveal_type(join(tup2, tup1))  # N: Revealed type is "builtins.tuple[builtins.int, ...]"

reveal_type(join(tup1, ()))  # N: Revealed type is "builtins.tuple[builtins.int, ...]"
reveal_type(join((), tup1))  # N: Revealed type is "builtins.tuple[builtins.int, ...]"

reveal_type(join(tup2, ()))  # N: Revealed type is "builtins.tuple[builtins.bool, ...]"
reveal_type(join((), tup2))  # N: Revealed type is "builtins.tuple[builtins.bool, ...]"

[builtins fixtures/tuple.pyi]
[out]

[case testTupleSubclassJoinIrregular]
from typing import Tuple, NamedTuple, TypeVar

class NTup1(NamedTuple):
    a: bool

class NTup2(NamedTuple):
    a: bool
    b: bool

class SubTuple(Tuple[bool, int, int]): ...

tup1: NTup1
tup2: NTup2
subtup: SubTuple

T = TypeVar("T")
def join(x: T, y: T) -> T: ...

reveal_type(join(tup1, tup2))  # N: Revealed type is "builtins.tuple[builtins.bool, ...]"
reveal_type(join(tup2, tup1))  # N: Revealed type is "builtins.tuple[builtins.bool, ...]"

reveal_type(join(tup1, subtup))  # N: Revealed type is "builtins.tuple[builtins.int, ...]"
reveal_type(join(subtup, tup1))  # N: Revealed type is "builtins.tuple[builtins.int, ...]"

reveal_type(join(tup2, subtup))  # N: Revealed type is "builtins.tuple[builtins.int, ...]"
reveal_type(join(subtup, tup2))  # N: Revealed type is "builtins.tuple[builtins.int, ...]"

[builtins fixtures/tuple.pyi]
[out]

[case testTupleWithUndersizedContext]
a = ([1], 'x')
if int():
    a = ([], 'x', 1)  # E: Incompatible types in assignment (expression has type "tuple[list[Never], str, int]", variable has type "tuple[list[int], str]")
[builtins fixtures/tuple.pyi]

[case testTupleWithOversizedContext]
a = (1, [1], 'x')
if int():
    a = (1, [])  # E: Incompatible types in assignment (expression has type "tuple[int, list[int]]", variable has type "tuple[int, list[int], str]")
[builtins fixtures/tuple.pyi]

[case testTupleWithoutContext]
a = (1, [])  # E: Need type annotation for "a"
[builtins fixtures/tuple.pyi]

[case testTupleWithUnionContext]
from typing import List, Union, Tuple
def f() -> Union[int, Tuple[List[str]]]:
    return ([],)
[builtins fixtures/tuple.pyi]

[case testTupleWithVariableSizedTupleContext]
from typing import List, Tuple
def f() -> Tuple[List[str], ...]:
    return ([],)
[builtins fixtures/tuple.pyi]

[case testTupleWithoutArgs]
from typing import Tuple
def f(a: Tuple) -> None: pass
f(())
f((1,))
f(('', ''))
f(0)  # E: Argument 1 to "f" has incompatible type "int"; expected "tuple[Any, ...]"
[builtins fixtures/tuple.pyi]

[case testTupleSingleton]

from typing import Tuple
def f(a: Tuple[()]) -> None: pass
f(())
f((1,))  # E: Argument 1 to "f" has incompatible type "tuple[int]"; expected "tuple[()]"
f(('', ''))  # E: Argument 1 to "f" has incompatible type "tuple[str, str]"; expected "tuple[()]"
f(0)  # E: Argument 1 to "f" has incompatible type "int"; expected "tuple[()]"
[builtins fixtures/tuple.pyi]

[case testNonliteralTupleIndex]
t = (0, "")
x = 0
y = ""
reveal_type(t[x])  # N: Revealed type is "Union[builtins.int, builtins.str]"
t[y]  # E: No overload variant of "__getitem__" of "tuple" matches argument type "str" \
      # N: Possible overload variants: \
      # N:     def __getitem__(self, int, /) -> Union[int, str] \
      # N:     def __getitem__(self, slice, /) -> tuple[Union[int, str], ...]

[builtins fixtures/tuple.pyi]

[case testNonliteralTupleSlice]
t = (0, "")
x = 0
y = ""
reveal_type(t[x:])  # N: Revealed type is "builtins.tuple[Union[builtins.int, builtins.str], ...]"
t[y:]  # E: Slice index must be an integer, SupportsIndex or None
[builtins fixtures/tuple.pyi]

[case testTupleSliceStepZeroNoCrash]
# This was crashing: https://github.com/python/mypy/issues/18062
# TODO: emit better error when 0 is used for step
()[::0]  # E: Ambiguous slice of a variadic tuple
[builtins fixtures/tuple.pyi]

[case testInferTupleTypeFallbackAgainstInstance]
from typing import TypeVar, Generic, Tuple
T = TypeVar('T')

class Base(Generic[T]): pass
def f(x: Base[T]) -> T: pass

class DT(Tuple[str, str], Base[int]):
    pass

reveal_type(f(DT())) # N: Revealed type is "builtins.int"

[builtins fixtures/tuple.pyi]
[out]

[case testTypeTupleClassmethod]
from typing import Tuple, Type

class C(Tuple[int, str]):
    @classmethod
    def f(cls) -> None: pass

t: Type[C]
t.g()  # E: "type[C]" has no attribute "g"
t.f()
[builtins fixtures/classmethod.pyi]

[case testTypeTupleCall]
from typing import Tuple

def foo(o: CallableTuple) -> int:
    reveal_type(o)  # N: Revealed type is "tuple[builtins.str, builtins.int, fallback=__main__.CallableTuple]"
    return o(1, 2)

class CallableTuple(Tuple[str, int]):
    def __call__(self, n: int, m: int) -> int:
        return n
[builtins fixtures/tuple.pyi]

[case testTypeTupleGenericCall]
from typing import Generic, Tuple, TypeVar

T = TypeVar('T')

def foo(o: CallableTuple[int]) -> int:
    reveal_type(o)  # N: Revealed type is "tuple[builtins.str, builtins.int, fallback=__main__.CallableTuple[builtins.int]]"
    reveal_type(o.count(3))  # N: Revealed type is "builtins.int"
    return o(1, 2)

class CallableTuple(Tuple[str, T]):
    def __call__(self, n: int, m: int) -> int:
        return n
[builtins fixtures/tuple.pyi]

[case testTupleCompatibleWithSequence]
from typing import Sequence
s: Sequence[str]
s = tuple()
reveal_type(s) # N: Revealed type is "builtins.tuple[builtins.str, ...]"

[builtins fixtures/tuple.pyi]

[case testTupleInstanceCompatibleWithIterable]
from typing import Iterable, Tuple
x: Iterable[int] = ()
y: Tuple[int, ...] = (1, 2, 3)
x = y
reveal_type(x) # N: Revealed type is "builtins.tuple[builtins.int, ...]"

[builtins fixtures/tuple.pyi]

[case testTupleTypeCompatibleWithIterable]
from typing import Iterable, Tuple
x: Iterable[int] = ()
y: Tuple[int, int] = (1, 2)
x = y
reveal_type(x) # N: Revealed type is "tuple[builtins.int, builtins.int]"
[builtins fixtures/tuple.pyi]

[case testTupleOverlapDifferentTuples]
from typing import Optional, Tuple
class A: pass
class B: pass

possibles: Tuple[int, Tuple[A]]
x: Optional[Tuple[B]]

if x in possibles:
    reveal_type(x) # N: Revealed type is "tuple[__main__.B]"
else:
    reveal_type(x) # N: Revealed type is "Union[tuple[__main__.B], None]"

[builtins fixtures/tuple.pyi]

[case testUnionOfTupleIndex]
from typing import Union, Tuple

tup: Union[Tuple[int, str], Tuple[int, int, str]]
reveal_type(tup[0])  # N: Revealed type is "builtins.int"
reveal_type(tup[1])  # N: Revealed type is "Union[builtins.str, builtins.int]"
reveal_type(tup[2])  # E: Tuple index out of range \
                     # N: Revealed type is "Union[Any, builtins.str]"
reveal_type(tup[:])  # N: Revealed type is "Union[tuple[builtins.int, builtins.str], tuple[builtins.int, builtins.int, builtins.str]]"

[builtins fixtures/tuple.pyi]

[case testUnionOfTupleIndexMixed]
from typing import Union, Tuple, List

tup: Union[Tuple[int, str], List[int]]
reveal_type(tup[0])  # N: Revealed type is "builtins.int"
reveal_type(tup[1])  # N: Revealed type is "Union[builtins.str, builtins.int]"
reveal_type(tup[2])  # E: Tuple index out of range \
                     # N: Revealed type is "Union[Any, builtins.int]"
reveal_type(tup[:])  # N: Revealed type is "Union[tuple[builtins.int, builtins.str], builtins.list[builtins.int]]"

[builtins fixtures/tuple.pyi]

[case testFixedLengthTupleConcatenation]
a = (1, "foo", 3)
b = ("bar", 7)

reveal_type(a + b)  # N: Revealed type is "tuple[builtins.int, builtins.str, builtins.int, builtins.str, builtins.int]"

[builtins fixtures/tuple.pyi]

[case testAssigningWithLongTupleInitializer]
from typing import Tuple

# long initializer assignment with few mismatches
t: Tuple[int, ...] = (1, 2, 3, 4, 5, 6, 7, 8, "str", "str", "str", 11) # E: Incompatible types in assignment (3 tuple items are incompatible) \
                                                                       # N: Expression tuple item 8 has type "str"; "int" expected;  \
                                                                       # N: Expression tuple item 9 has type "str"; "int" expected;  \
                                                                       # N: Expression tuple item 10 has type "str"; "int" expected;

# long initializer assignment with more mismatches
t1: Tuple[int, ...] = (1, 2, 3, 4, 5, 6, 7, 8, "str", "str", "str", "str") # E: Incompatible types in assignment (4 tuple items are incompatible; 1 items are omitted) \
                                                                           # N: Expression tuple item 8 has type "str"; "int" expected;  \
                                                                           # N: Expression tuple item 9 has type "str"; "int" expected;  \
                                                                           # N: Expression tuple item 10 has type "str"; "int" expected;

# short tuple initializer assignment
t2: Tuple[int, ...] = (1, 2, "s", 4) # E: Incompatible types in assignment (expression has type "tuple[int, int, str, int]", variable has type "tuple[int, ...]")

# long initializer assignment with few mismatches, no ellipsis
t3: Tuple[int, int, int, int, int, int, int, int, int, int, int, int] = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, "str", "str") # E: Incompatible types in assignment (2 tuple items are incompatible) \
                                                                                                                      # N: Expression tuple item 10 has type "str"; "int" expected;  \
                                                                                                                      # N: Expression tuple item 11 has type "str"; "int" expected;

# long initializer assignment with more mismatches, no ellipsis
t4: Tuple[int, int, int, int, int, int, int, int, int, int, int, int] = (1, 2, 3, 4, 5, 6, 7, 8, "str", "str", "str", "str") # E: Incompatible types in assignment (4 tuple items are incompatible; 1 items are omitted) \
                                                                                                                             # N: Expression tuple item 8 has type "str"; "int" expected;  \
                                                                                                                             # N: Expression tuple item 9 has type "str"; "int" expected;  \
                                                                                                                             # N: Expression tuple item 10 has type "str"; "int" expected;

# short tuple initializer assignment, no ellipsis
t5: Tuple[int, int] = (1, 2, "s", 4)  # E: Incompatible types in assignment (expression has type "tuple[int, int, str, int]", variable has type "tuple[int, int]")

# long initializer assignment with mismatched pairs
t6: Tuple[int, int, int, int, int, int, int, int, int, int, int, int] = (1, 2, 3, 4, 5, 6, 7, 8, "str", "str", "str", "str", 1, 1, 1, 1, 1) # E: Incompatible types in assignment (expression has type "tuple[int, int, ... <15 more items>]", variable has type "tuple[int, int, ... <10 more items>]")

[builtins fixtures/tuple.pyi]

[case testPropertyLongTupleReturnTypeMismatchUnion]
from typing import Tuple, Union
class A:
    a: str
    b: str
    c: str
    d: str
    e: str
    f: str
    g: Union[str, int]
    h: Union[str, float]
    i: Union[str, None]
    j: Union[str, None]
    k: Union[str, None]
    l: Union[str, None]

    @property
    def x(self) -> Tuple[str, str, str, str, str, str, str, str, str, str, str, str]:
        return (
            self.a,
            self.b,
            self.c,
            self.d,
            self.e,
            self.f,
            self.g,
            self.h,
            self.i,
            self.j,
            self.k,
            self.l,
        )
[out]
main:18: error: Incompatible return value type (6 tuple items are incompatible; 3 items are omitted)
main:18: note: Expression tuple item 6 has type "Union[str, int]"; "str" expected;
main:18: note: Expression tuple item 7 has type "Union[str, float]"; "str" expected;
main:18: note: Expression tuple item 8 has type "Optional[str]"; "str" expected;
[builtins fixtures/property.pyi]

[case testPropertyLongTupleReturnTypeMismatchUnionWiderExpected]
from typing import Tuple, Union
class A:
    a: str
    b: str
    c: str
    d: str
    e: str
    f: str
    g: str
    h: str
    i: str
    j: str
    k: str
    l: Union[float, int]

    @property
    def x(self) -> Tuple[Union[str, int], Union[str, float], int, Union[str, None], Union[str, None], Union[str, None], str, str, str, str, str, str]:
        return (
            self.a,
            self.b,
            self.c,
            self.d,
            self.e,
            self.f,
            self.g,
            self.h,
            self.i,
            self.j,
            self.k,
            self.l,
        )
[out]
main:18: error: Incompatible return value type (2 tuple items are incompatible)
main:18: note: Expression tuple item 2 has type "str"; "int" expected;
main:18: note: Expression tuple item 11 has type "Union[float, int]"; "str" expected;
[builtins fixtures/property.pyi]

[case testTupleWithStarExpr]
from typing import Tuple, List
points = (1, "test")  # type: Tuple[int, str]
x, y, z = *points, 0
reveal_type(x) # N: Revealed type is "builtins.int"
reveal_type(y) # N: Revealed type is "builtins.str"
reveal_type(z) # N: Revealed type is "builtins.int"

points2 = [1,2]
x2, y2, z2= *points2, "test"

reveal_type(x2) # N: Revealed type is "builtins.int"
reveal_type(y2) # N: Revealed type is "builtins.int"
reveal_type(z2) # N: Revealed type is "builtins.str"

x3, x4, y3, y4, z3 = *points, *points2, "test"

reveal_type(x3) # N: Revealed type is "builtins.int"
reveal_type(x4) # N: Revealed type is "builtins.str"
reveal_type(y3) # N: Revealed type is "builtins.int"
reveal_type(y4) # N: Revealed type is "builtins.int"
reveal_type(z3) # N: Revealed type is "builtins.str"

x5, x6, y5, y6, z4 = *points2, *points2, "test"

reveal_type(x5) # N: Revealed type is "builtins.int"
reveal_type(x6) # N: Revealed type is "builtins.int"
reveal_type(y5) # N: Revealed type is "builtins.int"
reveal_type(y6) # N: Revealed type is "builtins.int"
reveal_type(z4) # N: Revealed type is "builtins.str"

points3 = ["test1", "test2"]
x7, x8, y7, y8 = *points2, *points3 # E: Contiguous iterable with same type expected

x9, y9, x10, y10, z5 = *points2, 1, *points2 # E: Contiguous iterable with same type expected
[builtins fixtures/tuple.pyi]

[case testAssignEmpty]
() = []

[case testAssignEmptyBogus]
() = 1  # E: "int" object is not iterable
[builtins fixtures/tuple.pyi]

[case testMultiplyTupleByIntegerLiteral]
from typing import Tuple
t = ('',) * 2
reveal_type(t)  # N: Revealed type is "tuple[builtins.str, builtins.str]"
t2 = ('',) * -1
reveal_type(t2)  # N: Revealed type is "tuple[()]"
t3 = ('', 1) * 2
reveal_type(t3)  # N: Revealed type is "tuple[builtins.str, builtins.int, builtins.str, builtins.int]"
def f() -> Tuple[str, ...]:
    return ('', )
reveal_type(f() * 2)  # N: Revealed type is "builtins.tuple[builtins.str, ...]"
[builtins fixtures/tuple.pyi]

[case testEmptyTupleTypeRepr]
from typing import Tuple

def f() -> Tuple[()]: ...

reveal_type(f)    # N: Revealed type is "def () -> tuple[()]"
reveal_type(f())  # N: Revealed type is "tuple[()]"
[builtins fixtures/tuple.pyi]

[case testMultiplyTupleByIntegerLiteralReverse]
from typing import Tuple
t = 2 * ('',)
reveal_type(t)  # N: Revealed type is "tuple[builtins.str, builtins.str]"
t2 = -1 * ('',)
reveal_type(t2)  # N: Revealed type is "tuple[()]"
t3 = 2 * ('', 1)
reveal_type(t3)  # N: Revealed type is "tuple[builtins.str, builtins.int, builtins.str, builtins.int]"
def f() -> Tuple[str, ...]:
    return ('', )
reveal_type(2 * f())  # N: Revealed type is "builtins.tuple[builtins.str, ...]"
[builtins fixtures/tuple.pyi]

[case testSingleUndefinedTypeAndTuple]
from typing import Tuple

class Foo:
    ...

class Bar(aaaaaaaaaa):  # E: Name "aaaaaaaaaa" is not defined
    ...

class FooBarTuple(Tuple[Foo, Bar]):
    ...
[builtins fixtures/tuple.pyi]

[case testMultipleUndefinedTypeAndTuple]
from typing import Tuple

class Foo(aaaaaaaaaa):  # E: Name "aaaaaaaaaa" is not defined
    ...

class Bar(aaaaaaaaaa):  # E: Name "aaaaaaaaaa" is not defined
    ...

class FooBarTuple(Tuple[Foo, Bar]):
    ...
[builtins fixtures/tuple.pyi]


[case testTupleOverloadZipAny]
from typing import Any, Iterable, Iterator, Tuple, TypeVar, overload

T = TypeVar("T")

@overload
def zip(__i: Iterable[T]) -> Iterator[Tuple[T]]: ...
@overload
def zip(*i: Iterable[Any]) -> Iterator[Tuple[Any, ...]]: ...
def zip(i): ...

def g(t: Tuple):
    reveal_type(zip(*t))  # N: Revealed type is "typing.Iterator[builtins.tuple[Any, ...]]"
    reveal_type(zip(t))  # N: Revealed type is "typing.Iterator[tuple[Any]]"
[builtins fixtures/tuple.pyi]

[case testTupleSubclassSlice]
from typing import Tuple

class A: ...

class tuple_aa_subclass(Tuple[A, A]): ...

inst_tuple_aa_subclass: tuple_aa_subclass = tuple_aa_subclass((A(), A()))[:]  # E: Incompatible types in assignment (expression has type "tuple[A, A]", variable has type "tuple_aa_subclass")
[builtins fixtures/tuple.pyi]
