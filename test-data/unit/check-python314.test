[case testTemplateStringBasics]
reveal_type(t"foobar")  # N: Revealed type is "string.templatelib.Template"
t"{'foobar'}"
t"foo{'bar'}"
t".{1}."
t"{type(1)}"
t"{1!r}"
t"{1:03d}"
t"{1!r:03d}"

from string.templatelib import Template
a: Template
a = t"foobar"
a = t"{'foobar'}"
[builtins fixtures/f_string.pyi]

[case testTemplateStringWithoutExplicitImport]
reveal_type(t"implicit import works")  # N: Revealed type is "string.templatelib.Template"
[builtins fixtures/f_string.pyi]

[case testTemplateStringExpressionsOk]
t".{1 + 1}."
t".{1 + 1}.{'foo' + 'bar'}"
[builtins fixtures/f_string.pyi]

[case testTemplateStringExpressionsErrors]
t"{1 + ''}"   # E: Unsupported operand types for + ("int" and "str")
t".{1 + ''}"  # E: Unsupported operand types for + ("int" and "str")
[builtins fixtures/f_string.pyi]

[case testTemplateStringParseFormatOptions]
value = 10.5142
width = 10
precision = 4
t"result: {value:{width}.{precision}}"
[builtins fixtures/f_string.pyi]

[case testTemplateStringNestedExpressionsTypeChecked]
t"{2:{3 + ''}}"  # E: Unsupported operand types for + ("int" and "str")
[builtins fixtures/f_string.pyi]

[case testIncrementalTemplateStringImplicitDependency]
import m
reveal_type(m.x)
[file m.py]
x = "foo"
[file m.py.2]
x = t"foo"
[out1]
main:2: note: Revealed type is "builtins.str"
[out2]
main:2: note: Revealed type is "string.templatelib.Template"
[builtins fixtures/f_string.pyi]
