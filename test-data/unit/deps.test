-- Test cases for generating dependencies between ASTs nodes.
--
-- The dependencies are used for fined-grained incremental checking.


[case testCallFunction]
def f() -> None:
    g()
def g() -> None:
    pass
[out]
<m.g> -> m.f

[case testCallMethod]
def f(a: A) -> None:
    a.g()
class A:
    def g(self) -> None: pass
[out]
<m.A.g> -> m.f
<m.A> -> <m.f>, m.A, m.f

[case testAccessAttribute]
def f(a: A) -> None:
    a.x
class A:
    def g(self) -> None:
        self.x = 1
[out]
<m.A.x> -> m.A.g, m.f
<m.A> -> <m.f>, m.A, m.f

[case testConstructInstance]
def f() -> None:
    A()
class A: pass
[out]
<m.A.__init__> -> m.f
<m.A> -> m.A, m.f

[case testAccessModuleAttribute]
class A: pass
x = A()
def f() -> None:
    x
[out]
<m.A.__init__> -> m
<m.A> -> <m.x>, m, m.A
<m.x> -> m, m.f

[case testAccessModuleAttribute2]
import n
def f() -> None:
    n.x
[file n.py]
x = 1
[out]
<n.x> -> m.f
<n> -> m, m.f

[case testImport]
import n
[file n.py]
x = 1
[out]
<n> -> m

[case testCallImportedFunction]
import n
n.f()
[file n.py]
def f() -> None: pass
[out]
<n.f> -> m
<n> -> m

[case testImportModuleAs]
import n as x
x.f()
[file n.py]
def f() -> None: pass
[out]
<n.f> -> m
<n> -> m

[case testCallImportedFunctionInFunction]
import n
def g() -> None:
    n.f()
[file n.py]
def f() -> None: pass
[out]
<n.f> -> m.g
<n> -> m, m.g

[case testInheritanceSimple]
class A:
    pass
class B(A):
    pass
[out]
<m.A.__init__> -> <m.B.__init__>
<m.A> -> m, m.A, m.B
<m.B> -> m.B

[case testInheritanceWithMethodAndAttribute]
class A:
    pass
class B(A):
    def f(self) -> None:
        self.x = 1
[out]
<m.A.__init__> -> <m.B.__init__>
<m.A.f> -> m.B.f
<m.A.x> -> <m.B.x>
<m.A> -> m, m.A, m.B
<m.B.x> -> m.B.f
<m.B> -> m.B

[case testInheritanceWithMethodAndAttributeAndDeepHierarchy]
class A:
    pass
class B(A):
    pass
class C(B):
    def f(self) -> None:
        self.x = 1
[out]
<m.A.__init__> -> <m.B.__init__>, <m.C.__init__>
<m.A.f> -> m.C.f
<m.A.x> -> <m.C.x>
<m.A> -> m, m.A, m.B
<m.B.__init__> -> <m.C.__init__>
<m.B.f> -> m.C.f
<m.B.x> -> <m.C.x>
<m.B> -> m, m.B, m.C
<m.C.x> -> m.C.f
<m.C> -> m.C

[case testInheritAttribute]
import n
class B(n.A):
    def f(self) -> None:
        a = 1
        a = self.x
[file n.py]
class A:
    def g(self) -> None:
        self.x = 1
[out]
<m.B.x> -> m.B.f
<m.B> -> m.B
<n.A.__init__> -> <m.B.__init__>
<n.A.f> -> m.B.f
<n.A.g> -> <m.B.g>
<n.A.x> -> <m.B.x>
<n.A> -> m, m.B
<n> -> m

[case testInheritMethod]
class A:
    def g(self) -> None: pass
class B(A):
    def f(self) -> None:
        self.g()
[out]
<m.A.__init__> -> <m.B.__init__>
<m.A.f> -> m.B.f
<m.A.g> -> <m.B.g>
<m.A> -> m, m.A, m.B
<m.B.g> -> m.B.f
<m.B> -> m.B

[case testPackage]
import a.b
def f() -> None:
    a.b.g()
[file a/__init__.py]
[file a/b.py]
def g() -> None: pass
[out]
<a.b.g> -> m.f
<a.b> -> m, m.f
<a> -> m.f

[case testClassInPackage]
import a.b
def f(x: a.b.A) -> None:
    x.g()
    x.y
[file a/__init__.py]
[file a/b.py]
class A:
    def g(self) -> None:
        self.y = 1
[out]
<a.b.A.g> -> m.f
<a.b.A.y> -> m.f
<a.b.A> -> <m.f>, m.f
<a.b> -> m

[case testPackage__init__]
import a
def f() -> None:
    a.g()
[file a/__init__.py]
def g() -> None: pass
[out]
<a.g> -> m.f
<a> -> m, m.f

[case testClassInPackage__init__]
import a
def f(x: a.A) -> None:
    x.g()
    x.y
[file a/__init__.py]
class A:
    def g(self) -> None:
        self.y = 1
[out]
<a.A.g> -> m.f
<a.A.y> -> m.f
<a.A> -> <m.f>, m.f
<a> -> m

[case testConstructor]
class A:
    def __init__(self, x: C) -> None: pass
class C: pass
def f() -> None:
    A(C())
[out]
<m.A.__init__> -> m.f
<m.A> -> m.A, m.f
<m.C.__init__> -> m.f
<m.C> -> <m.A.__init__>, m.A.__init__, m.C, m.f

[case testNonTrivialConstructor]
class C:
    def __init__(self) -> None:
        self.x = 1
[out]
<m.C.x> -> m.C.__init__
<m.C> -> m.C

[case testImportFrom]
from n import f

def g() -> None:
    f()
[file n.py]
def f() -> None: pass
[out]
<n.f> -> m, m.g

[case testImportFromAs]
from n import f as ff

def g() -> None:
    ff()
[file n.py]
def f() -> None: pass
[out]
<n.f> -> m, m.g

[case testNestedClass]
def f() -> None:
    b = A.B()
    b.f()
class A:
    class B:
        def f(self) -> None: pass
[out]
<m.A.B.__init__> -> m.f
<m.A.B.f> -> m.f
<m.A.B> -> m.A.B, m.f
<m.A> -> m.A, m.f

[case testNestedClassAttribute]
def f() -> None:
    b = A.B()
    b.x
class A:
    class B:
        def f(self) -> None:
            self.x = 1
[out]
<m.A.B.__init__> -> m.f
<m.A.B.x> -> m.A.B.f, m.f
<m.A.B> -> m.A.B, m.f
<m.A> -> m.A, m.f

[case testNestedClassInAnnotation]
def f(x: A.B) -> None:
    pass
class A:
    class B: pass
[out]
<m.A.B> -> <m.f>, m.A.B, m.f
<m.A> -> m.A

[case testNestedClassInAnnotation2]
def f(x: A.B) -> None:
    x.f()
class A:
    class B:
        def f(self) -> None: pass
[out]
<m.A.B.f> -> m.f
<m.A.B> -> <m.f>, m.A.B, m.f
<m.A> -> m.A

[case testDefaultArgValue]
def f1(x: int) -> int: pass
def f2() -> int: pass
def g(x: int = f1(f2())) -> None: pass
[out]
<m.f1> -> m.g
<m.f2> -> m.g

[case testIsInstance]
class A:
    def g(self) -> None: pass

def f(x: object) -> None:
    if isinstance(x, A):
        x.g()
[builtins fixtures/isinstancelist.pyi]
[out]
<m.A.g> -> m.f
<m.A> -> m.A, m.f

[case testUnreachableIsInstance]
class A:
    x: int

class B:
    y: int

def f(x: A) -> None:
    if isinstance(x, B):
        x.y
[builtins fixtures/isinstancelist.pyi]
[out]
<m.A> -> <m.f>, m.A, m.f
<m.B> -> m.B, m.f

[case testAttributeWithClassType1]
from n import A

class B:
    def h(self, z: A) -> None:
        self.z = z
[file n.py]
class A: pass
[out]
<m.B.z> -> m.B.h
<m.B> -> m.B
<n.A> -> <m.B.h>, <m.B.z>, m, m.B.h

[case testAttributeWithClassType2]
from m import A

class B:
    def f(self) -> None:
        self.x = A()
[file m.py]
class A: pass
[out]
<m.B.x> -> m.B.f
<m.B> -> m.B
<m.A.__init__> -> m.B.f
<m.A> -> <m.B.x>, m, m.B.f

[case testAttributeWithClassType3]
from n import A, x

class B:
    def g(self) -> None:
        self.x = x
[file n.py]
class A: pass

x = A()
[out]
<m.B.x> -> m.B.g
<m.B> -> m.B
<n.A> -> <m.B.x>, m
<n.x> -> m, m.B.g

[case testAttributeWithClassType4]
from n import A

class B:
    def g(self) -> None:
        self.x: A
[file n.py]
class A: pass
[out]
<m.B.x> -> m.B.g
<m.B> -> m.B
<n.A> -> <m.B.x>, m, m.B.g

[case testClassBody]
def f() -> int: pass
def g() -> int: pass
def h() -> int: pass

class A:
    h()
    if f():
        g()
[out]
<m.A> -> m.A
<m.f> -> m
<m.g> -> m
<m.h> -> m

[case testVariableInitializedInClass]
from n import A

class B:
    x = None  # type: A
[file n.py]
class A: pass
[out]
<m.B> -> m.B
<n.A> -> <m.B.x>, m

[case testVariableAnnotationInClass]
from n import A

class B:
    x: A

    def f(self) -> None:
        y = self.x
[file n.py]
class A: pass
[out]
<m.B.x> -> m.B.f
<m.B> -> m.B
<n.A> -> <m.B.x>, m

[case testGlobalVariableInitialized]
from n import A

x = A()
[file n.py]
class A: pass
[out]
<m.x> -> m
<n.A.__init__> -> m
<n.A> -> <m.x>, m

[case testGlobalVariableAnnotation]
from n import A

x: A
[file n.py]
class A: pass
[out]
<m.x> -> m
<n.A> -> <m.x>, m

[case testProperty]
class B: pass

class A:
    @property
    def x(self) -> B: pass

def f(a: A) -> None:
    b = a.x
[builtins fixtures/property.pyi]
[out]
<m.A.x> -> m, m.f
<m.A> -> <m.f>, m.A, m.f
<m.B> -> <m.A.x>, m.A.x, m.B

[case testUnreachableAssignment]
from typing import List, Tuple

def f() -> None: pass

class C:
    def __init__(self, x: int) -> None:
        if isinstance(x, int):
            self.y = 1
        else:
            self.y = f()
[builtins fixtures/isinstancelist.pyi]
[out]
<m.C.y> -> m.C.__init__
<m.C> -> m.C
<m.f> -> m.C.__init__

[case testPartialNoneTypeAttributeCrash1]
class C: pass

class A:
    x = None

    def f(self) -> None:
        self.x = C()
[out]
<m.A.x> -> m.A.f
<m.A> -> m.A
<m.C.__init__> -> m.A.f
<m.C> -> <m.A.x>, m.A.f, m.C

[case testPartialNoneTypeAttributeCrash2]
# flags: --strict-optional
class C: pass

class A:
    x = None

    def f(self) -> None:
        self.x = C()
[out]
<m.A.x> -> m.A.f
<m.A> -> m.A
<m.C.__init__> -> m.A.f
<m.C> -> <m.A.x>, m.A.f, m.C
