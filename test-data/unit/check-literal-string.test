-- LiteralString tests
-- See https://peps.python.org/pep-0675/

[case testLiteralStringInference]
from typing_extensions import LiteralString

x: LiteralString = 'a'
reveal_type(x)  # N: Revealed type is "LiteralString"
raw_str: str = x   # Ok, can be narrowed
reveal_type(raw_str)  # N: Revealed type is "builtins.str"

some_str: str
y: LiteralString = some_str  # E: Incompatible types in assignment (expression has type "str", variable has type "LiteralString")

z: LiteralString = 1  # E: Incompatible types in assignment (expression has type "int", variable has type "LiteralString")
[builtins fixtures/literal_string.pyi]


[case testLiteralStringAndFString]
from typing_extensions import LiteralString
x: LiteralString = f'Value: {1}'  # E: Incompatible types in assignment (expression has type "str", variable has type "LiteralString")
[builtins fixtures/literal_string.pyi]


[case testLiteralStringAndStrImplicitTypes]
reveal_type('a')  # N: Revealed type is "Literal['a']?"

x = 'a'
reveal_type(x)  # N: Revealed type is "builtins.str"
x = f'Value: {x}'
reveal_type(x)  # N: Revealed type is "builtins.str"

if int():
    cond = 'abc'  # Literal
else:
    cond = ','.join(['a', 'b'])  # Dynamic

literal_names = ["native"]
reveal_type(literal_names)  # N: Revealed type is "builtins.list[builtins.str]"
literal_names.append(str())
[builtins fixtures/literal_string.pyi]


[case testLiteralTypeAndLiteralString]
from typing_extensions import LiteralString, Literal

l1: Literal['a']
l2: Literal[1]

ls1: LiteralString = l1
ls2: LiteralString = l2  # E: Incompatible types in assignment (expression has type "Literal[1]", variable has type "LiteralString")

ls3: LiteralString
l3: Literal['a'] = ls3  # E: Incompatible types in assignment (expression has type "LiteralString", variable has type "Literal['a']")

def expects_literal_string(x: LiteralString): ...
def expects_literal_a(x: Literal['a']): ...

expects_literal_string(l1)
expects_literal_string(ls1)

expects_literal_a(l1)
expects_literal_a(ls1)  # E: Argument 1 to "expects_literal_a" has incompatible type "LiteralString"; expected "Literal['a']"
[builtins fixtures/literal_string.pyi]


[case testLiteralStringFallbackToString]
from typing_extensions import LiteralString
def expects_literal_string(x: LiteralString): ...

x: LiteralString
expects_literal_string(x.format(1))  # E: Argument 1 to "expects_literal_string" has incompatible type "str"; expected "LiteralString"
[builtins fixtures/literal_string.pyi]


-- TODO: this is not supported yet
-- All cases here must pass
-- But, we need literal type math for this
[case testLiteralStringTypeMath-skip]
from typing_extensions import LiteralString
def expects_literal_string(x: LiteralString): ...

expects_literal_string('a')
expects_literal_string('a' + 'b')
expects_literal_string('a' * 2)
[builtins fixtures/literal_string.pyi]


[case testLiteralStringBoundTypeVar]
from typing_extensions import LiteralString
from typing import TypeVar

T = TypeVar('T', bound=LiteralString)
def expects_literal_string(x: T): ...

expects_literal_string('a')

x: LiteralString
y: str
expects_literal_string(x)
expects_literal_string(y)  # E: Value of type variable "T" of "expects_literal_string" cannot be "str"
[builtins fixtures/literal_string.pyi]


[case testLiteralStringAsMethodSig]
from typing_extensions import LiteralString

class Base:
    def method1(self, arg: LiteralString) -> str: ...
    def method2(self, arg: str) -> LiteralString: ...
    def method3(self, arg: LiteralString) -> LiteralString: ...
    def method4(self, arg: str) -> str: ...

class Correct(Base):
    def method1(self, arg: str) -> LiteralString: ...
    def method3(self, arg: str) -> LiteralString: ...
    def method4(self, arg: str) -> LiteralString: ...

class Wrong(Base):
    def method2(self, arg: LiteralString) -> str: ...
    def method3(self, arg: str) -> str: ...
    def method4(self, arg: LiteralString) -> LiteralString: ...
[out]
main:15: error: Argument 1 of "method2" is incompatible with supertype "Base"; supertype defines the argument type as "str"
main:15: note: This violates the Liskov substitution principle
main:15: note: See https://mypy.readthedocs.io/en/stable/common_issues.html#incompatible-overrides
main:15: error: Return type "str" of "method2" incompatible with return type "LiteralString" in supertype "Base"
main:16: error: Return type "str" of "method3" incompatible with return type "LiteralString" in supertype "Base"
main:17: error: Argument 1 of "method4" is incompatible with supertype "Base"; supertype defines the argument type as "str"
main:17: note: This violates the Liskov substitution principle
main:17: note: See https://mypy.readthedocs.io/en/stable/common_issues.html#incompatible-overrides
[builtins fixtures/literal_string.pyi]


[case testLiteralStringErrorMessages]
from typing_extensions import LiteralString

class Base:
    x: int
class Sub(Base):
    x = 'a'  # E: Incompatible types in assignment (expression has type "str", base class "Base" defined the type as "int")
class ExcplicitSub1(Base):
    x: LiteralString = 'a'  # E: Incompatible types in assignment (expression has type "LiteralString", base class "Base" defined the type as "int")
class ExcplicitSub2(Base):
    x: LiteralString  # E: Incompatible types in assignment (expression has type "LiteralString", base class "Base" defined the type as "int")

def accepts_int(arg: int): ...
accepts_int('b')  # E: Argument 1 to "accepts_int" has incompatible type "str"; expected "int"
ls1: LiteralString
ls2: LiteralString = 'a'
accepts_int(ls1)  # E: Argument 1 to "accepts_int" has incompatible type "LiteralString"; expected "int"
accepts_int(ls2)  # E: Argument 1 to "accepts_int" has incompatible type "LiteralString"; expected "int"
[builtins fixtures/literal_string.pyi]


[case testConditionalLiteralString]
from typing_extensions import LiteralString
if int():
    cond: LiteralString = 'abc'
else:
    cond = ','.join(['a', 'b'])  # E: Incompatible types in assignment (expression has type "str", variable has type "LiteralString")
[builtins fixtures/literal_string.pyi]


[case testUnionOfLiteralString]
from typing_extensions import LiteralString
from typing import Union

x: Union[str, LiteralString] = 'a'
y: Union[str, LiteralString] = str()
z: Union[str, LiteralString] = 1  # E: Incompatible types in assignment (expression has type "int", variable has type "Union[str, LiteralString]")
[builtins fixtures/literal_string.pyi]


[case testTypeAliasOfLiteralString]
from typing_extensions import LiteralString, TypeAlias

LS1: TypeAlias = LiteralString
LS2 = LiteralString

def ls1(arg: LS1) -> LS1: ...
def ls2(arg: LS2) -> LS2: ...

reveal_type(ls1('abc'))  # N: Revealed type is "LiteralString"
reveal_type(ls2("abc"))  # N: Revealed type is "LiteralString"

x: LiteralString
reveal_type(ls1(x))  # N: Revealed type is "LiteralString"
reveal_type(ls2(x))  # N: Revealed type is "LiteralString"
y: str
ls1(y)  # E: Argument 1 to "ls1" has incompatible type "str"; expected "LiteralString"
ls2(y)  # E: Argument 1 to "ls2" has incompatible type "str"; expected "LiteralString"
[builtins fixtures/literal_string.pyi]


[case testOverloadsWithLiteralString]
from over import some

x: str
y: str
reveal_type(some('a', 'b'))  # N: Revealed type is "LiteralString"
reveal_type(some(x, y))      # N: Revealed type is "builtins.str"
reveal_type(some('a', y))    # N: Revealed type is "builtins.str"
reveal_type(some(x, 'b'))    # N: Revealed type is "builtins.str"

[file over.pyi]
from typing_extensions import LiteralString
from typing import Union, overload

@overload
def some(x: LiteralString, y: LiteralString) -> LiteralString: ...
@overload
def some(x: str, y: str) -> str: ...
[builtins fixtures/literal_string.pyi]


[case testLiteralStringInsideList]
from typing_extensions import LiteralString
from typing import List

literal_names: List[LiteralString] = ["native", "literal"]
literal_names.append(str())  # E: Argument 1 to "append" of "list" has incompatible type "str"; expected "LiteralString"

literal_names2: List[LiteralString] = ["literal", str()]  # E: List item 1 has incompatible type "str"; expected "LiteralString"
[builtins fixtures/list.pyi]

[case testLiteralStringInsideTuple]
from typing_extensions import LiteralString
from typing import Tuple

literal_names: Tuple[LiteralString, ...] = ("native", "literal")
literal_names2: Tuple[LiteralString, ...] = ("literal", str())  # E: Incompatible types in assignment (expression has type "Tuple[str, str]", variable has type "Tuple[LiteralString, ...]")
[builtins fixtures/tuple.pyi]

[case testLiteralStringInsideSet]
from typing_extensions import LiteralString
from typing import Set

literal_names: Set[LiteralString] = {"native", "literal"}
literal_names2: Set[LiteralString] = {"literal", str()}  # E: Argument 2 to <set> has incompatible type "str"; expected "LiteralString"
[builtins fixtures/set.pyi]

[case testLiteralStringInsideDict]
from typing_extensions import LiteralString
from typing import Dict

literal_names: Dict[LiteralString, LiteralString] = {"native": "literal"}
literal_names2: Dict[LiteralString, int] = {"literal": 1, str(): 2}  # E: Dict entry 1 has incompatible type "str": "int"; expected "LiteralString": "int"
literal_names3: Dict[int, LiteralString] = {2: str(), 1: "literal"}  # E: Dict entry 0 has incompatible type "int": "str"; expected "int": "LiteralString"
[builtins fixtures/dict.pyi]
