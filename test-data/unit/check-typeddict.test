-- Create Instance

[case testCanCreateTypedDictInstanceWithKeywordArguments]
from typing import TypedDict
Point = TypedDict('Point', {'x': int, 'y': int})
p = Point(x=42, y=1337)
reveal_type(p)  # N: Revealed type is "TypedDict('__main__.Point', {'x': builtins.int, 'y': builtins.int})"
# Use values() to check fallback value type.
reveal_type(p.values()) # N: Revealed type is "typing.Iterable[builtins.object]"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]
[targets __main__]

[case testCanCreateTypedDictInstanceWithDictCall]
from typing import TypedDict
Point = TypedDict('Point', {'x': int, 'y': int})
p = Point(dict(x=42, y=1337))
reveal_type(p)  # N: Revealed type is "TypedDict('__main__.Point', {'x': builtins.int, 'y': builtins.int})"
# Use values() to check fallback value type.
reveal_type(p.values()) # N: Revealed type is "typing.Iterable[builtins.object]"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testCanCreateTypedDictInstanceWithDictLiteral]
from typing import TypedDict
Point = TypedDict('Point', {'x': int, 'y': int})
p = Point({'x': 42, 'y': 1337})
reveal_type(p)  # N: Revealed type is "TypedDict('__main__.Point', {'x': builtins.int, 'y': builtins.int})"
# Use values() to check fallback value type.
reveal_type(p.values()) # N: Revealed type is "typing.Iterable[builtins.object]"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testCanCreateTypedDictInstanceWithNoArguments]
from typing import TypedDict, TypeVar, Union
EmptyDict = TypedDict('EmptyDict', {})
p = EmptyDict()
reveal_type(p)  # N: Revealed type is "TypedDict('__main__.EmptyDict', {})"
reveal_type(p.values()) # N: Revealed type is "typing.Iterable[builtins.object]"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]


-- Create Instance (Errors)

[case testCannotCreateTypedDictInstanceWithUnknownArgumentPattern]
from typing import TypedDict
Point = TypedDict('Point', {'x': int, 'y': int})
p = Point(42, 1337)  # E: Expected keyword arguments, {...}, or dict(...) in TypedDict constructor
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testCannotCreateTypedDictInstanceNonLiteralItemName]
from typing import TypedDict
Point = TypedDict('Point', {'x': int, 'y': int})
x = 'x'
p = Point({x: 42, 'y': 1337})  # E: Expected TypedDict key to be string literal
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testCannotCreateTypedDictInstanceWithExtraItems]
from typing import TypedDict
Point = TypedDict('Point', {'x': int, 'y': int})
p = Point(x=42, y=1337, z=666)  # E: Extra key "z" for TypedDict "Point"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testCannotCreateTypedDictInstanceWithMissingItems]
from typing import TypedDict
Point = TypedDict('Point', {'x': int, 'y': int})
p = Point(x=42)  # E: Missing key "y" for TypedDict "Point"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testCannotCreateTypedDictInstanceWithIncompatibleItemType]
from typing import TypedDict
Point = TypedDict('Point', {'x': int, 'y': int})
p = Point(x='meaning_of_life', y=1337)  # E: Incompatible types (expression has type "str", TypedDict item "x" has type "int")
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testCannotCreateTypedDictInstanceWithInlineTypedDict]
from typing import TypedDict
D = TypedDict('D', {
    'x': TypedDict('E', {  # E: Use dict literal for nested TypedDict
        'y': int
    })
})
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

-- Define TypedDict (Class syntax)

[case testCanCreateTypedDictWithClass]
from typing import TypedDict

class Point(TypedDict):
    x: int
    y: int

p = Point(x=42, y=1337)
reveal_type(p)  # N: Revealed type is "TypedDict('__main__.Point', {'x': builtins.int, 'y': builtins.int})"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testCanCreateTypedDictWithSubclass]
from typing import TypedDict

class Point1D(TypedDict):
    x: int
class Point2D(Point1D):
    y: int
r: Point1D
p: Point2D
reveal_type(r)  # N: Revealed type is "TypedDict('__main__.Point1D', {'x': builtins.int})"
reveal_type(p)  # N: Revealed type is "TypedDict('__main__.Point2D', {'x': builtins.int, 'y': builtins.int})"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testCanCreateTypedDictWithSubclass2]
from typing import TypedDict

class Point1D(TypedDict):
    x: int
class Point2D(TypedDict, Point1D): # We also allow to include TypedDict in bases, it is simply ignored at runtime
    y: int

p: Point2D
reveal_type(p)  # N: Revealed type is "TypedDict('__main__.Point2D', {'x': builtins.int, 'y': builtins.int})"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testCanCreateTypedDictClassEmpty]
from typing import TypedDict

class EmptyDict(TypedDict):
    pass

p = EmptyDict()
reveal_type(p)  # N: Revealed type is "TypedDict('__main__.EmptyDict', {})"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]


[case testCanCreateTypedDictWithClassOldVersion]
# Test that we can use class-syntax to merge function-based TypedDicts
from typing import TypedDict

MovieBase1 = TypedDict(
    'MovieBase1', {'name': str, 'year': int})
MovieBase2 = TypedDict(
    'MovieBase2', {'based_on': str}, total=False)

class Movie(MovieBase1, MovieBase2):
    pass

def foo(x):
    # type: (Movie) -> None
    pass

foo({})  # E: Missing keys ("name", "year") for TypedDict "Movie"
foo({'name': 'lol', 'year': 2009, 'based_on': 0})  # E: Incompatible types (expression has type "int", TypedDict item "based_on" has type "str")
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

-- Define TypedDict (Class syntax errors)

[case testCannotCreateTypedDictWithClassOtherBases]
from typing import TypedDict

class A: pass

class Point1D(TypedDict, A): # E: All bases of a new TypedDict must be TypedDict types
    x: int
class Point2D(Point1D, A): # E: All bases of a new TypedDict must be TypedDict types
    y: int

p: Point2D
reveal_type(p)  # N: Revealed type is "TypedDict('__main__.Point2D', {'x': builtins.int, 'y': builtins.int})"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testCannotCreateTypedDictWithDuplicateBases]
# https://github.com/python/mypy/issues/3673
from typing import TypedDict

class A(TypedDict):
    x: str
    y: int

class B(A, A): # E: Duplicate base class "A"
    z: str

class C(TypedDict, TypedDict): # E: Duplicate base class "TypedDict"
    c1: int
[typing fixtures/typing-typeddict.pyi]

[case testCannotCreateTypedDictWithClassWithOtherStuff]
from typing import TypedDict

class Point(TypedDict):
    x: int
    y: int = 1 # E: Right hand side values are not supported in TypedDict
    def f(): pass # E: Invalid statement in TypedDict definition; expected "field_name: field_type"
    z = int # E: Invalid statement in TypedDict definition; expected "field_name: field_type"

p = Point(x=42, y=1337, z='whatever')
reveal_type(p)  # N: Revealed type is "TypedDict('__main__.Point', {'x': builtins.int, 'y': builtins.int, 'z': Any})"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testCannotCreateTypedDictWithClassWithFunctionUsedToCrash]
# https://github.com/python/mypy/issues/11079
from typing import TypedDict
class D(TypedDict):
    y: int
    def x(self, key: int):  # E: Invalid statement in TypedDict definition; expected "field_name: field_type"
        pass

d = D(y=1)
reveal_type(d)  # N: Revealed type is "TypedDict('__main__.D', {'y': builtins.int})"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testCannotCreateTypedDictWithDecoratedFunction]
# flags: --disallow-any-expr
# https://github.com/python/mypy/issues/13066
from typing import TypedDict
class D(TypedDict):
    @classmethod  # E: Invalid statement in TypedDict definition; expected "field_name: field_type"
    def m(self) -> D:
        pass
d = D()
reveal_type(d)  # N: Revealed type is "TypedDict('__main__.D', {})"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictWithClassmethodAlternativeConstructorDoesNotCrash]
# https://github.com/python/mypy/issues/5653
from typing import TypedDict

class Foo(TypedDict):
    bar: str
    @classmethod  # E: Invalid statement in TypedDict definition; expected "field_name: field_type"
    def baz(cls) -> "Foo": ...
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testCanCreateTypedDictTypeWithUnderscoreItemName]
from typing import TypedDict
Point = TypedDict('Point', {'x': int, 'y': int, '_fallback': object})
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testCanCreateTypedDictWithClassUnderscores]
from typing import TypedDict

class Point(TypedDict):
    x: int
    _y: int

p: Point
reveal_type(p) # N: Revealed type is "TypedDict('__main__.Point', {'x': builtins.int, '_y': builtins.int})"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testCannotCreateTypedDictWithDuplicateKey1]
from typing import TypedDict

class Bad(TypedDict):
    x: int
    x: str # E: Duplicate TypedDict key "x"

b: Bad
reveal_type(b) # N: Revealed type is "TypedDict('__main__.Bad', {'x': builtins.int})"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testCannotCreateTypedDictWithDuplicateKey2]
from typing import TypedDict

D1 = TypedDict("D1", {
    "x": int,
    "x": int,  # E: Duplicate TypedDict key "x"
})
D2 = TypedDict("D2", {"x": int, "x": str})  # E: Duplicate TypedDict key "x"

d1: D1
d2: D2
reveal_type(d1) # N: Revealed type is "TypedDict('__main__.D1', {'x': builtins.int})"
reveal_type(d2) # N: Revealed type is "TypedDict('__main__.D2', {'x': builtins.str})"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testCanCreateTypedDictWithClassOverwriting]
from typing import TypedDict

class Point1(TypedDict):
    x: int
class Point2(TypedDict):
    x: float
class Bad(Point1, Point2): # E: Overwriting TypedDict field "x" while merging
    pass

b: Bad
reveal_type(b) # N: Revealed type is "TypedDict('__main__.Bad', {'x': builtins.int})"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testCanCreateTypedDictWithClassOverwriting2]
from typing import TypedDict

class Point1(TypedDict):
    x: int
class Point2(Point1):
    x: float # E: Overwriting TypedDict field "x" while extending

p2: Point2
reveal_type(p2) # N: Revealed type is "TypedDict('__main__.Point2', {'x': builtins.float})"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]


-- Subtyping

[case testCanConvertTypedDictToItself]
from typing import TypedDict
Point = TypedDict('Point', {'x': int, 'y': int})
def identity(p: Point) -> Point:
    return p
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testCanConvertTypedDictToEquivalentTypedDict]
from typing import TypedDict
PointA = TypedDict('PointA', {'x': int, 'y': int})
PointB = TypedDict('PointB', {'x': int, 'y': int})
def identity(p: PointA) -> PointB:
    return p
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testCannotConvertTypedDictToSimilarTypedDictWithNarrowerItemTypes]
from typing import TypedDict
Point = TypedDict('Point', {'x': int, 'y': int})
ObjectPoint = TypedDict('ObjectPoint', {'x': object, 'y': object})
def convert(op: ObjectPoint) -> Point:
    return op  # E: Incompatible return value type (got "ObjectPoint", expected "Point")
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testCannotConvertTypedDictToSimilarTypedDictWithWiderItemTypes]
from typing import TypedDict
Point = TypedDict('Point', {'x': int, 'y': int})
ObjectPoint = TypedDict('ObjectPoint', {'x': object, 'y': object})
def convert(p: Point) -> ObjectPoint:
    return p  # E: Incompatible return value type (got "Point", expected "ObjectPoint")
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testCannotConvertTypedDictToSimilarTypedDictWithIncompatibleItemTypes]
from typing import TypedDict
Point = TypedDict('Point', {'x': int, 'y': int})
Chameleon = TypedDict('Chameleon', {'x': str, 'y': str})
def convert(p: Point) -> Chameleon:
    return p  # E: Incompatible return value type (got "Point", expected "Chameleon")
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testCanConvertTypedDictToNarrowerTypedDict]
from typing import TypedDict
Point = TypedDict('Point', {'x': int, 'y': int})
Point1D = TypedDict('Point1D', {'x': int})
def narrow(p: Point) -> Point1D:
    return p
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testCannotConvertTypedDictToWiderTypedDict]
from typing import TypedDict
Point = TypedDict('Point', {'x': int, 'y': int})
Point3D = TypedDict('Point3D', {'x': int, 'y': int, 'z': int})
def widen(p: Point) -> Point3D:
    return p  # E: Incompatible return value type (got "Point", expected "Point3D")
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testCanConvertTypedDictToCompatibleMapping]
from typing import Mapping, TypedDict
Point = TypedDict('Point', {'x': int, 'y': int})
def as_mapping(p: Point) -> Mapping[str, object]:
    return p
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testCannotConvertTypedDictToIncompatibleMapping]
from typing import Mapping, TypedDict
Point = TypedDict('Point', {'x': int, 'y': int})
def as_mapping(p: Point) -> Mapping[str, int]:
    return p  # E: Incompatible return value type (got "Point", expected "Mapping[str, int]")
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictAcceptsIntForFloatDuckTypes]
from typing import Any, Mapping, TypedDict
Point = TypedDict('Point', {'x': float, 'y': float})
def create_point() -> Point:
    return Point(x=1, y=2)
reveal_type(Point(x=1, y=2))  # N: Revealed type is "TypedDict('__main__.Point', {'x': builtins.float, 'y': builtins.float})"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictDoesNotAcceptsFloatForInt]
from typing import Any, Mapping, TypedDict
Point = TypedDict('Point', {'x': int, 'y': int})
def create_point() -> Point:
    return Point(x=1.2, y=2.5)
[out]
main:4: error: Incompatible types (expression has type "float", TypedDict item "x" has type "int")
main:4: error: Incompatible types (expression has type "float", TypedDict item "y" has type "int")
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictAcceptsAnyType]
from typing import Any, Mapping, TypedDict
Point = TypedDict('Point', {'x': float, 'y': float})
def create_point(something: Any) -> Point:
    return Point({
      'x': something.x,
      'y': something.y
    })
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictValueTypeContext]
from typing import List, TypedDict
D = TypedDict('D', {'x': List[int]})
reveal_type(D(x=[]))  # N: Revealed type is "TypedDict('__main__.D', {'x': builtins.list[builtins.int]})"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testCannotConvertTypedDictToDictOrMutableMapping]
from typing import Dict, MutableMapping, TypedDict
Point = TypedDict('Point', {'x': int, 'y': int})
def as_dict(p: Point) -> Dict[str, int]:
    return p  # E: Incompatible return value type (got "Point", expected "Dict[str, int]")
def as_mutable_mapping(p: Point) -> MutableMapping[str, object]:
    return p  # E: Incompatible return value type (got "Point", expected "MutableMapping[str, object]")
[builtins fixtures/dict.pyi]
[typing fixtures/typing-full.pyi]

[case testCanConvertTypedDictToAny]
from typing import Any, TypedDict
Point = TypedDict('Point', {'x': int, 'y': int})
def unprotect(p: Point) -> Any:
    return p
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testAnonymousTypedDictInErrorMessages]
from typing import TypedDict

A = TypedDict('A', {'x': int, 'y': str})
B = TypedDict('B', {'x': int, 'z': str, 'a': int})
C = TypedDict('C', {'x': int, 'z': str, 'a': str})
a: A
b: B
c: C

def f(a: A) -> None: pass

l = [a, b]  # Join generates an anonymous TypedDict
f(l) # E: Argument 1 to "f" has incompatible type "List[TypedDict({'x': int})]"; expected "A"
ll = [b, c]
f(ll) # E: Argument 1 to "f" has incompatible type "List[TypedDict({'x': int, 'z': str})]"; expected "A"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictWithSimpleProtocol]
from typing_extensions import Protocol, TypedDict

class StrObjectMap(Protocol):
    def __getitem__(self, key: str) -> object: ...
class StrIntMap(Protocol):
    def __getitem__(self, key: str) -> int: ...

A = TypedDict('A', {'x': int, 'y': int})
B = TypedDict('B', {'x': int, 'y': str})

def fun(arg: StrObjectMap) -> None: ...
def fun2(arg: StrIntMap) -> None: ...
a: A
b: B
fun(a)
fun(b)
fun2(a) # Error
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]
[out]
main:17: error: Argument 1 to "fun2" has incompatible type "A"; expected "StrIntMap"
main:17: note: Following member(s) of "A" have conflicts:
main:17: note:     Expected:
main:17: note:         def __getitem__(self, str, /) -> int
main:17: note:     Got:
main:17: note:         def __getitem__(self, str, /) -> object

[case testTypedDictWithSimpleProtocolInference]
from typing_extensions import Protocol, TypedDict
from typing import TypeVar

T_co = TypeVar('T_co', covariant=True)
T = TypeVar('T')

class StrMap(Protocol[T_co]):
    def __getitem__(self, key: str) -> T_co: ...

A = TypedDict('A', {'x': int, 'y': int})
B = TypedDict('B', {'x': int, 'y': str})

def fun(arg: StrMap[T]) -> T:
    return arg['whatever']
a: A
b: B
reveal_type(fun(a))  # N: Revealed type is "builtins.object"
reveal_type(fun(b))  # N: Revealed type is "builtins.object"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

-- Join

[case testJoinOfTypedDictHasOnlyCommonKeysAndNewFallback]
from typing import TypedDict
TaggedPoint = TypedDict('TaggedPoint', {'type': str, 'x': int, 'y': int})
Point3D = TypedDict('Point3D', {'x': int, 'y': int, 'z': int})
p1 = TaggedPoint(type='2d', x=0, y=0)
p2 = Point3D(x=1, y=1, z=1)
joined_points = [p1, p2][0]
reveal_type(p1.values())   # N: Revealed type is "typing.Iterable[builtins.object]"
reveal_type(p2.values())   # N: Revealed type is "typing.Iterable[builtins.object]"
reveal_type(joined_points)  # N: Revealed type is "TypedDict({'x': builtins.int, 'y': builtins.int})"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testJoinOfTypedDictRemovesNonequivalentKeys]
from typing import TypedDict
CellWithInt = TypedDict('CellWithInt', {'value': object, 'meta': int})
CellWithObject = TypedDict('CellWithObject', {'value': object, 'meta': object})
c1 = CellWithInt(value=1, meta=42)
c2 = CellWithObject(value=2, meta='turtle doves')
joined_cells = [c1, c2]
reveal_type(c1)             # N: Revealed type is "TypedDict('__main__.CellWithInt', {'value': builtins.object, 'meta': builtins.int})"
reveal_type(c2)             # N: Revealed type is "TypedDict('__main__.CellWithObject', {'value': builtins.object, 'meta': builtins.object})"
reveal_type(joined_cells)   # N: Revealed type is "builtins.list[TypedDict({'value': builtins.object})]"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testJoinOfDisjointTypedDictsIsEmptyTypedDict]
from typing import TypedDict
Point = TypedDict('Point', {'x': int, 'y': int})
Cell = TypedDict('Cell', {'value': object})
d1 = Point(x=0, y=0)
d2 = Cell(value='pear tree')
joined_dicts = [d1, d2]
reveal_type(d1)             # N: Revealed type is "TypedDict('__main__.Point', {'x': builtins.int, 'y': builtins.int})"
reveal_type(d2)             # N: Revealed type is "TypedDict('__main__.Cell', {'value': builtins.object})"
reveal_type(joined_dicts)   # N: Revealed type is "builtins.list[TypedDict({})]"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testJoinOfTypedDictWithCompatibleMappingIsMapping]
from typing import Mapping, TypedDict
Cell = TypedDict('Cell', {'value': int})
left = Cell(value=42)
right = {'score': 999}  # type: Mapping[str, int]
joined1 = [left, right]
joined2 = [right, left]
reveal_type(joined1)  # N: Revealed type is "builtins.list[typing.Mapping[builtins.str, builtins.object]]"
reveal_type(joined2)  # N: Revealed type is "builtins.list[typing.Mapping[builtins.str, builtins.object]]"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testJoinOfTypedDictWithCompatibleMappingSupertypeIsSupertype]
from typing import Sized, TypedDict
Cell = TypedDict('Cell', {'value': int})
left = Cell(value=42)
right = {'score': 999}  # type: Sized
joined1 = [left, right]
joined2 = [right, left]
reveal_type(joined1)  # N: Revealed type is "builtins.list[typing.Sized]"
reveal_type(joined2)  # N: Revealed type is "builtins.list[typing.Sized]"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testJoinOfTypedDictWithIncompatibleTypeIsObject]
from typing import Mapping, TypedDict
Cell = TypedDict('Cell', {'value': int})
left = Cell(value=42)
right = 42
joined1 = [left, right]
joined2 = [right, left]
reveal_type(joined1)  # N: Revealed type is "builtins.list[builtins.object]"
reveal_type(joined2)  # N: Revealed type is "builtins.list[builtins.object]"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]


-- Meet

[case testMeetOfTypedDictsWithCompatibleCommonKeysHasAllKeysAndNewFallback]
from typing import TypedDict, TypeVar, Callable
XY = TypedDict('XY', {'x': int, 'y': int})
YZ = TypedDict('YZ', {'y': int, 'z': int})
T = TypeVar('T')
def f(x: Callable[[T, T], None]) -> T: pass
def g(x: XY, y: YZ) -> None: pass
reveal_type(f(g))  # N: Revealed type is "TypedDict({'x': builtins.int, 'y': builtins.int, 'z': builtins.int})"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testMeetOfTypedDictsWithIncompatibleCommonKeysIsUninhabited]
from typing import TypedDict, TypeVar, Callable
XYa = TypedDict('XYa', {'x': int, 'y': int})
YbZ = TypedDict('YbZ', {'y': object, 'z': int})
T = TypeVar('T')
def f(x: Callable[[T, T], None]) -> T: pass
def g(x: XYa, y: YbZ) -> None: pass
reveal_type(f(g))  # N: Revealed type is "Never"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testMeetOfTypedDictsWithNoCommonKeysHasAllKeysAndNewFallback]
from typing import TypedDict, TypeVar, Callable
X = TypedDict('X', {'x': int})
Z = TypedDict('Z', {'z': int})
T = TypeVar('T')
def f(x: Callable[[T, T], None]) -> T: pass
def g(x: X, y: Z) -> None: pass
reveal_type(f(g))  # N: Revealed type is "TypedDict({'x': builtins.int, 'z': builtins.int})"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

# TODO: It would be more accurate for the meet to be TypedDict instead.
[case testMeetOfTypedDictWithCompatibleMappingIsUninhabitedForNow]
from typing import TypedDict, TypeVar, Callable, Mapping
X = TypedDict('X', {'x': int})
M = Mapping[str, int]
T = TypeVar('T')
def f(x: Callable[[T, T], None]) -> T: pass
def g(x: X, y: M) -> None: pass
reveal_type(f(g))  # N: Revealed type is "Never"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testMeetOfTypedDictWithIncompatibleMappingIsUninhabited]
from typing import TypedDict, TypeVar, Callable, Mapping
X = TypedDict('X', {'x': int})
M = Mapping[str, str]
T = TypeVar('T')
def f(x: Callable[[T, T], None]) -> T: pass
def g(x: X, y: M) -> None: pass
reveal_type(f(g))  # N: Revealed type is "Never"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testMeetOfTypedDictWithCompatibleMappingSuperclassIsUninhabitedForNow]
from typing import TypedDict, TypeVar, Callable, Iterable
X = TypedDict('X', {'x': int})
I = Iterable[str]
T = TypeVar('T')
def f(x: Callable[[T, T], None]) -> T: pass
def g(x: X, y: I) -> None: pass
reveal_type(f(g))  # N: Revealed type is "TypedDict('__main__.X', {'x': builtins.int})"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testMeetOfTypedDictsWithNonTotal]
from typing import TypedDict, TypeVar, Callable
XY = TypedDict('XY', {'x': int, 'y': int}, total=False)
YZ = TypedDict('YZ', {'y': int, 'z': int}, total=False)
T = TypeVar('T')
def f(x: Callable[[T, T], None]) -> T: pass
def g(x: XY, y: YZ) -> None: pass
reveal_type(f(g))  # N: Revealed type is "TypedDict({'x'?: builtins.int, 'y'?: builtins.int, 'z'?: builtins.int})"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testMeetOfTypedDictsWithNonTotalAndTotal]
from typing import TypedDict, TypeVar, Callable
XY = TypedDict('XY', {'x': int}, total=False)
YZ = TypedDict('YZ', {'y': int, 'z': int})
T = TypeVar('T')
def f(x: Callable[[T, T], None]) -> T: pass
def g(x: XY, y: YZ) -> None: pass
reveal_type(f(g))  # N: Revealed type is "TypedDict({'x'?: builtins.int, 'y': builtins.int, 'z': builtins.int})"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testMeetOfTypedDictsWithIncompatibleNonTotalAndTotal]
from typing import TypedDict, TypeVar, Callable
XY = TypedDict('XY', {'x': int, 'y': int}, total=False)
YZ = TypedDict('YZ', {'y': int, 'z': int})
T = TypeVar('T')
def f(x: Callable[[T, T], None]) -> T: pass
def g(x: XY, y: YZ) -> None: pass
reveal_type(f(g)) # N: Revealed type is "Never"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]


-- Constraint Solver

[case testTypedDictConstraintsAgainstIterable]
from typing import TypedDict, TypeVar, Iterable
T = TypeVar('T')
def f(x: Iterable[T]) -> T: pass
A = TypedDict('A', {'x': int})
a: A
reveal_type(f(a)) # N: Revealed type is "builtins.str"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

-- TODO: Figure out some way to trigger the ConstraintBuilderVisitor.visit_typeddict_type() path.


-- Special Method: __getitem__

[case testCanGetItemOfTypedDictWithValidStringLiteralKey]
from typing import TypedDict
TaggedPoint = TypedDict('TaggedPoint', {'type': str, 'x': int, 'y': int})
p = TaggedPoint(type='2d', x=42, y=1337)
reveal_type(p['type'])  # N: Revealed type is "builtins.str"
reveal_type(p['x'])     # N: Revealed type is "builtins.int"
reveal_type(p['y'])     # N: Revealed type is "builtins.int"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testCannotGetItemOfTypedDictWithInvalidStringLiteralKey]
from typing import TypedDict
TaggedPoint = TypedDict('TaggedPoint', {'type': str, 'x': int, 'y': int})
p: TaggedPoint
p['typ']  # E: TypedDict "TaggedPoint" has no key "typ" \
          # N: Did you mean "type"?
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testCannotGetItemOfAnonymousTypedDictWithInvalidStringLiteralKey]
from typing import TypedDict, TypeVar
A = TypedDict('A', {'x': str, 'y': int, 'z': str})
B = TypedDict('B', {'x': str, 'z': int})
C = TypedDict('C', {'x': str, 'y': int, 'z': int})
T = TypeVar('T')
def join(x: T, y: T) -> T: return x
ab = join(A(x='', y=1, z=''), B(x='', z=1))
ac = join(A(x='', y=1, z=''), C(x='', y=0, z=1))
ab['y']  # E: "y" is not a valid TypedDict key; expected one of ("x")
ac['a']  # E: "a" is not a valid TypedDict key; expected one of ("x", "y")
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testCannotGetItemOfTypedDictWithNonLiteralKey]
from typing import TypedDict, Union
TaggedPoint = TypedDict('TaggedPoint', {'type': str, 'x': int, 'y': int})
p = TaggedPoint(type='2d', x=42, y=1337)
def get_coordinate(p: TaggedPoint, key: str) -> Union[str, int]:
    return p[key]  # E: TypedDict key must be a string literal; expected one of ("type", "x", "y")
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]


-- Special Method: __setitem__

[case testCanSetItemOfTypedDictWithValidStringLiteralKeyAndCompatibleValueType]
from typing import TypedDict
TaggedPoint = TypedDict('TaggedPoint', {'type': str, 'x': int, 'y': int})
p = TaggedPoint(type='2d', x=42, y=1337)
p['type'] = 'two_d'
p['x'] = 1
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testCannotSetItemOfTypedDictWithIncompatibleValueType]
from typing import TypedDict
TaggedPoint = TypedDict('TaggedPoint', {'type': str, 'x': int, 'y': int})
p = TaggedPoint(type='2d', x=42, y=1337)
p['x'] = 'y'  # E: Value of "x" has incompatible type "str"; expected "int"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testCannotSetItemOfTypedDictWithInvalidStringLiteralKey]
from typing import TypedDict
TaggedPoint = TypedDict('TaggedPoint', {'type': str, 'x': int, 'y': int})
p = TaggedPoint(type='2d', x=42, y=1337)
p['z'] = 1  # E: TypedDict "TaggedPoint" has no key "z"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testCannotSetItemOfTypedDictWithNonLiteralKey]
from typing import TypedDict, Union
TaggedPoint = TypedDict('TaggedPoint', {'type': str, 'x': int, 'y': int})
p = TaggedPoint(type='2d', x=42, y=1337)
def set_coordinate(p: TaggedPoint, key: str, value: int) -> None:
    p[key] = value  # E: TypedDict key must be a string literal; expected one of ("type", "x", "y")
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]


-- isinstance

[case testTypedDictWithIsInstanceAndIsSubclass]
from typing import TypedDict
D = TypedDict('D', {'x': int})
d: object
if isinstance(d, D):   # E: Cannot use isinstance() with TypedDict type
    reveal_type(d)     # N: Revealed type is "TypedDict('__main__.D', {'x': builtins.int})"
issubclass(object, D)  # E: Cannot use issubclass() with TypedDict type
[builtins fixtures/isinstancelist.pyi]
[typing fixtures/typing-typeddict.pyi]


-- Scoping

[case testTypedDictInClassNamespace]
# https://github.com/python/mypy/pull/2553#issuecomment-266474341
from typing import TypedDict
class C:
    def f(self):
        A = TypedDict('A', {'x': int})
    def g(self):
        A = TypedDict('A', {'y': int})
C.A  # E: "Type[C]" has no attribute "A"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictInFunction]
from typing import TypedDict
def f() -> None:
    A = TypedDict('A', {'x': int})
A  # E: Name "A" is not defined
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]


-- Union simplification / proper subtype checks

[case testTypedDictUnionSimplification]
from typing import TypedDict, TypeVar, Union, Any, cast

T = TypeVar('T')
S = TypeVar('S')
def u(x: T, y: S) -> Union[S, T]: pass

C = TypedDict('C', {'a': int})
D = TypedDict('D', {'a': int, 'b': int})
E = TypedDict('E', {'a': str})
F = TypedDict('F', {'x': int})
G = TypedDict('G', {'a': Any})

c = C(a=1)
d = D(a=1, b=1)
e = E(a='')
f = F(x=1)
g = G(a=cast(Any, 1))  # Work around #2610

reveal_type(u(d, d)) # N: Revealed type is "TypedDict('__main__.D', {'a': builtins.int, 'b': builtins.int})"
reveal_type(u(c, d)) # N: Revealed type is "TypedDict('__main__.C', {'a': builtins.int})"
reveal_type(u(d, c)) # N: Revealed type is "TypedDict('__main__.C', {'a': builtins.int})"
reveal_type(u(c, e)) # N: Revealed type is "Union[TypedDict('__main__.E', {'a': builtins.str}), TypedDict('__main__.C', {'a': builtins.int})]"
reveal_type(u(e, c)) # N: Revealed type is "Union[TypedDict('__main__.C', {'a': builtins.int}), TypedDict('__main__.E', {'a': builtins.str})]"
reveal_type(u(c, f)) # N: Revealed type is "Union[TypedDict('__main__.F', {'x': builtins.int}), TypedDict('__main__.C', {'a': builtins.int})]"
reveal_type(u(f, c)) # N: Revealed type is "Union[TypedDict('__main__.C', {'a': builtins.int}), TypedDict('__main__.F', {'x': builtins.int})]"
reveal_type(u(c, g)) # N: Revealed type is "Union[TypedDict('__main__.G', {'a': Any}), TypedDict('__main__.C', {'a': builtins.int})]"
reveal_type(u(g, c)) # N: Revealed type is "Union[TypedDict('__main__.C', {'a': builtins.int}), TypedDict('__main__.G', {'a': Any})]"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictUnionSimplification2]
from typing import TypedDict, TypeVar, Union, Mapping, Any

T = TypeVar('T')
S = TypeVar('S')
def u(x: T, y: S) -> Union[S, T]: pass

C = TypedDict('C', {'a': int, 'b': int})

c = C(a=1, b=1)
m_s_o: Mapping[str, object]
m_s_s: Mapping[str, str]
m_i_i: Mapping[int, int]
m_s_a: Mapping[str, Any]

reveal_type(u(c, m_s_o)) # N: Revealed type is "typing.Mapping[builtins.str, builtins.object]"
reveal_type(u(m_s_o, c)) # N: Revealed type is "typing.Mapping[builtins.str, builtins.object]"
reveal_type(u(c, m_s_s)) # N: Revealed type is "Union[typing.Mapping[builtins.str, builtins.str], TypedDict('__main__.C', {'a': builtins.int, 'b': builtins.int})]"
reveal_type(u(c, m_i_i)) # N: Revealed type is "Union[typing.Mapping[builtins.int, builtins.int], TypedDict('__main__.C', {'a': builtins.int, 'b': builtins.int})]"
reveal_type(u(c, m_s_a)) # N: Revealed type is "Union[typing.Mapping[builtins.str, Any], TypedDict('__main__.C', {'a': builtins.int, 'b': builtins.int})]"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictUnionUnambiguousCase]
from typing import Union, Mapping, Any, cast
from typing_extensions import TypedDict, Literal

A = TypedDict('A', {'@type': Literal['a-type'], 'a': str})
B = TypedDict('B', {'@type': Literal['b-type'], 'b': int})

c: Union[A, B] = {'@type': 'a-type', 'a': 'Test'}
reveal_type(c) # N: Revealed type is "Union[TypedDict('__main__.A', {'@type': Literal['a-type'], 'a': builtins.str}), TypedDict('__main__.B', {'@type': Literal['b-type'], 'b': builtins.int})]"
[builtins fixtures/dict.pyi]

[case testTypedDictUnionAmbiguousCaseBothMatch]
from typing import Union, Mapping, Any, cast
from typing_extensions import TypedDict, Literal

A = TypedDict('A', {'@type': Literal['a-type'], 'value': str})
B = TypedDict('B', {'@type': Literal['b-type'], 'value': str})

c: Union[A, B] = {'@type': 'a-type', 'value': 'Test'}
[builtins fixtures/dict.pyi]

[case testTypedDictUnionAmbiguousCaseNoMatch]
from typing import Union, Mapping, Any, cast
from typing_extensions import TypedDict, Literal

A = TypedDict('A', {'@type': Literal['a-type'], 'value': int})
B = TypedDict('B', {'@type': Literal['b-type'], 'value': int})

c: Union[A, B] = {'@type': 'a-type', 'value': 'Test'}  # E: Type of TypedDict is ambiguous, none of ("A", "B") matches cleanly \
                                                       # E: Incompatible types in assignment (expression has type "Dict[str, str]", variable has type "Union[A, B]")
[builtins fixtures/dict.pyi]

-- Use dict literals

[case testTypedDictDictLiterals]
from typing import TypedDict

Point = TypedDict('Point', {'x': int, 'y': int})

def f(p: Point) -> None:
    if int():
        p = {'x': 2, 'y': 3}
        p = {'x': 2}  # E: Missing key "y" for TypedDict "Point"
        p = dict(x=2, y=3)

f({'x': 1, 'y': 3})
f({'x': 1, 'y': 'z'})  # E: Incompatible types (expression has type "str", TypedDict item "y" has type "int")

f(dict(x=1, y=3))
f(dict(x=1, y=3, z=4))  # E: Extra key "z" for TypedDict "Point"
f(dict(x=1, y=3, z=4, a=5))  # E: Extra keys ("z", "a") for TypedDict "Point"

[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictExplicitTypes]
from typing import TypedDict

Point = TypedDict('Point', {'x': int, 'y': int})

p1a: Point = {'x': 'hi'}  # E: Missing key "y" for TypedDict "Point"
p1b: Point = {}           # E: Missing keys ("x", "y") for TypedDict "Point"

p2: Point
p2 = dict(x='bye')  # E: Missing key "y" for TypedDict "Point"

p3 = Point(x=1, y=2)
if int():
    p3 = {'x': 'hi'}  # E: Missing key "y" for TypedDict "Point"

p4: Point = {'x': 1, 'y': 2}

[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testCannotCreateAnonymousTypedDictInstanceUsingDictLiteralWithExtraItems]
from typing import TypedDict, TypeVar
A = TypedDict('A', {'x': int, 'y': int})
B = TypedDict('B', {'x': int, 'y': str})
T = TypeVar('T')
def join(x: T, y: T) -> T: return x
ab = join(A(x=1, y=1), B(x=1, y=''))
if int():
    ab = {'x': 1, 'z': 1} # E: Expected TypedDict key "x" but found keys ("x", "z")
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testCannotCreateAnonymousTypedDictInstanceUsingDictLiteralWithMissingItems]
from typing import TypedDict, TypeVar
A = TypedDict('A', {'x': int, 'y': int, 'z': int})
B = TypedDict('B', {'x': int, 'y': int, 'z': str})
T = TypeVar('T')
def join(x: T, y: T) -> T: return x
ab = join(A(x=1, y=1, z=1), B(x=1, y=1, z=''))
if int():
    ab = {} # E: Expected TypedDict keys ("x", "y") but found no keys
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]


-- Other TypedDict methods

[case testTypedDictGetMethod]
from typing import TypedDict
class A: pass
D = TypedDict('D', {'x': int, 'y': str})
d: D
reveal_type(d.get('x')) # N: Revealed type is "Union[builtins.int, None]"
reveal_type(d.get('y')) # N: Revealed type is "Union[builtins.str, None]"
reveal_type(d.get('x', A())) # N: Revealed type is "Union[builtins.int, __main__.A]"
reveal_type(d.get('x', 1)) # N: Revealed type is "builtins.int"
reveal_type(d.get('y', None)) # N: Revealed type is "Union[builtins.str, None]"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictGetMethodTypeContext]
from typing import List, TypedDict
class A: pass
D = TypedDict('D', {'x': List[int], 'y': int})
d: D
reveal_type(d.get('x', [])) # N: Revealed type is "builtins.list[builtins.int]"
d.get('x', ['x']) # E: List item 0 has incompatible type "str"; expected "int"
a = ['']
reveal_type(d.get('x', a)) # N: Revealed type is "Union[builtins.list[builtins.int], builtins.list[builtins.str]]"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictGetMethodInvalidArgs]
from typing import TypedDict
D = TypedDict('D', {'x': int, 'y': str})
d: D
d.get() # E: All overload variants of "get" of "Mapping" require at least one argument \
        # N: Possible overload variants: \
        # N:     def get(self, k: str) -> object \
        # N:     def [V] get(self, k: str, default: object) -> object
d.get('x', 1, 2) # E: No overload variant of "get" of "Mapping" matches argument types "str", "int", "int" \
                 # N: Possible overload variants: \
                 # N:     def get(self, k: str) -> object \
                 # N:     def [V] get(self, k: str, default: Union[int, V]) -> object
x = d.get('z')
reveal_type(x) # N: Revealed type is "builtins.object"
s = ''
y = d.get(s)
reveal_type(y) # N: Revealed type is "builtins.object"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictMissingMethod]
from typing import TypedDict
D = TypedDict('D', {'x': int, 'y': str})
d: D
d.bad(1) # E: "D" has no attribute "bad"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictChainedGetMethodWithDictFallback]
from typing import TypedDict
D = TypedDict('D', {'x': int, 'y': str})
E = TypedDict('E', {'d': D})
p = E(d=D(x=0, y=''))
reveal_type(p.get('d', {'x': 1, 'y': ''})) # N: Revealed type is "TypedDict('__main__.D', {'x': builtins.int, 'y': builtins.str})"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictGetDefaultParameterStillTypeChecked]
from typing import TypedDict
TaggedPoint = TypedDict('TaggedPoint', {'type': str, 'x': int, 'y': int})
p = TaggedPoint(type='2d', x=42, y=1337)
p.get('x', 1 + 'y')     # E: Unsupported operand types for + ("int" and "str")
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictChainedGetWithEmptyDictDefault]
from typing import TypedDict
C = TypedDict('C', {'a': int})
D = TypedDict('D', {'x': C, 'y': str})
d: D
reveal_type(d.get('x', {})) \
    # N: Revealed type is "TypedDict('__main__.C', {'a'?: builtins.int})"
reveal_type(d.get('x', None)) \
    # N: Revealed type is "Union[TypedDict('__main__.C', {'a': builtins.int}), None]"
reveal_type(d.get('x', {}).get('a')) # N: Revealed type is "Union[builtins.int, None]"
reveal_type(d.get('x', {})['a']) # N: Revealed type is "builtins.int"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]


-- Totality (the "total" keyword argument)

[case testTypedDictWithTotalTrue]
from typing import TypedDict
D = TypedDict('D', {'x': int, 'y': str}, total=True)
d: D
reveal_type(d) \
    # N: Revealed type is "TypedDict('__main__.D', {'x': builtins.int, 'y': builtins.str})"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictWithInvalidTotalArgument]
from typing import TypedDict
A = TypedDict('A', {'x': int}, total=0) # E: "total" argument must be a True or False literal
B = TypedDict('B', {'x': int}, total=bool) # E: "total" argument must be a True or False literal
C = TypedDict('C', {'x': int}, x=False) # E: Unexpected keyword argument "x" for "TypedDict"
D = TypedDict('D', {'x': int}, False) # E: Unexpected arguments to TypedDict()
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictWithTotalFalse]
from typing import TypedDict
D = TypedDict('D', {'x': int, 'y': str}, total=False)
def f(d: D) -> None:
    reveal_type(d) # N: Revealed type is "TypedDict('__main__.D', {'x'?: builtins.int, 'y'?: builtins.str})"
f({})
f({'x': 1})
f({'y': ''})
f({'x': 1, 'y': ''})
f({'x': 1, 'z': ''}) # E: Extra key "z" for TypedDict "D"
f({'x': ''}) # E: Incompatible types (expression has type "str", TypedDict item "x" has type "int")
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictConstructorWithTotalFalse]
from typing import TypedDict
D = TypedDict('D', {'x': int, 'y': str}, total=False)
def f(d: D) -> None: pass
reveal_type(D()) # N: Revealed type is "TypedDict('__main__.D', {'x'?: builtins.int, 'y'?: builtins.str})"
reveal_type(D(x=1)) # N: Revealed type is "TypedDict('__main__.D', {'x'?: builtins.int, 'y'?: builtins.str})"
f(D(y=''))
f(D(x=1, y=''))
f(D(x=1, z='')) # E: Extra key "z" for TypedDict "D"
f(D(x='')) # E: Incompatible types (expression has type "str", TypedDict item "x" has type "int")
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictIndexingWithNonRequiredKey]
from typing import TypedDict
D = TypedDict('D', {'x': int, 'y': str}, total=False)
d: D
reveal_type(d['x']) # N: Revealed type is "builtins.int"
reveal_type(d['y']) # N: Revealed type is "builtins.str"
reveal_type(d.get('x')) # N: Revealed type is "Union[builtins.int, None]"
reveal_type(d.get('y')) # N: Revealed type is "Union[builtins.str, None]"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictSubtypingWithTotalFalse]
from typing import TypedDict
A = TypedDict('A', {'x': int})
B = TypedDict('B', {'x': int}, total=False)
C = TypedDict('C', {'x': int, 'y': str}, total=False)
def fa(a: A) -> None: pass
def fb(b: B) -> None: pass
def fc(c: C) -> None: pass
a: A
b: B
c: C
fb(b)
fc(c)
fb(c)
fb(a) # E: Argument 1 to "fb" has incompatible type "A"; expected "B"
fa(b) # E: Argument 1 to "fa" has incompatible type "B"; expected "A"
fc(b) # E: Argument 1 to "fc" has incompatible type "B"; expected "C"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictJoinWithTotalFalse]
from typing import TypedDict, TypeVar
A = TypedDict('A', {'x': int})
B = TypedDict('B', {'x': int}, total=False)
C = TypedDict('C', {'x': int, 'y': str}, total=False)
T = TypeVar('T')
def j(x: T, y: T) -> T: return x
a: A
b: B
c: C
reveal_type(j(a, b)) \
    # N: Revealed type is "TypedDict({})"
reveal_type(j(b, b)) \
    # N: Revealed type is "TypedDict({'x'?: builtins.int})"
reveal_type(j(c, c)) \
    # N: Revealed type is "TypedDict({'x'?: builtins.int, 'y'?: builtins.str})"
reveal_type(j(b, c)) \
    # N: Revealed type is "TypedDict({'x'?: builtins.int})"
reveal_type(j(c, b)) \
    # N: Revealed type is "TypedDict({'x'?: builtins.int})"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictClassWithTotalArgument]
from typing import TypedDict
class D(TypedDict, total=False):
    x: int
    y: str
d: D
reveal_type(d) # N: Revealed type is "TypedDict('__main__.D', {'x'?: builtins.int, 'y'?: builtins.str})"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictClassWithInvalidTotalArgument]
from typing import TypedDict
class D(TypedDict, total=1): # E: "total" argument must be a True or False literal
    x: int
class E(TypedDict, total=bool): # E: "total" argument must be a True or False literal
    x: int
class F(TypedDict, total=xyz): # E: Name "xyz" is not defined \
                               # E: "total" argument must be a True or False literal
    x: int
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictClassInheritanceWithTotalArgument]
from typing import TypedDict
class A(TypedDict):
    x: int
class B(TypedDict, A, total=False):
    y: int
class C(TypedDict, B, total=True):
    z: str
c: C
reveal_type(c) # N: Revealed type is "TypedDict('__main__.C', {'x': builtins.int, 'y'?: builtins.int, 'z': builtins.str})"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testNonTotalTypedDictInErrorMessages]
from typing import TypedDict

A = TypedDict('A', {'x': int, 'y': str}, total=False)
B = TypedDict('B', {'x': int, 'z': str, 'a': int}, total=False)
C = TypedDict('C', {'x': int, 'z': str, 'a': str}, total=False)
a: A
b: B
c: C

def f(a: A) -> None: pass

l = [a, b]  # Join generates an anonymous TypedDict
f(l) # E: Argument 1 to "f" has incompatible type "List[TypedDict({'x'?: int})]"; expected "A"
ll = [b, c]
f(ll) # E: Argument 1 to "f" has incompatible type "List[TypedDict({'x'?: int, 'z'?: str})]"; expected "A"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testNonTotalTypedDictCanBeEmpty]
# flags: --warn-unreachable
from typing import TypedDict

class A(TypedDict):
    ...

class B(TypedDict, total=False):
    x: int

a: A = {}
b: B = {}

if not a:
    reveal_type(a) # N: Revealed type is "TypedDict('__main__.A', {})"

if not b:
    reveal_type(b) # N: Revealed type is "TypedDict('__main__.B', {'x'?: builtins.int})"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

-- Create Type (Errors)

[case testCannotCreateTypedDictTypeWithTooFewArguments]
from typing import TypedDict
Point = TypedDict('Point')  # E: Too few arguments for TypedDict()
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testCannotCreateTypedDictTypeWithTooManyArguments]
from typing import TypedDict
Point = TypedDict('Point', {'x': int, 'y': int}, dict)  # E: Unexpected arguments to TypedDict()
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testCannotCreateTypedDictTypeWithInvalidName]
from typing import TypedDict
Point = TypedDict(dict, {'x': int, 'y': int})  # E: TypedDict() expects a string literal as the first argument
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testCannotCreateTypedDictTypeWithInvalidItems]
from typing import TypedDict
Point = TypedDict('Point', {'x'})  # E: TypedDict() expects a dictionary literal as the second argument
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testCannotCreateTypedDictTypeWithKwargs]
from typing import TypedDict
d = {'x': int, 'y': int}
Point = TypedDict('Point', {**d})  # E: Invalid TypedDict() field name
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testCannotCreateTypedDictTypeWithBytes]
from typing import TypedDict
Point = TypedDict(b'Point', {'x': int, 'y': int})  # E: TypedDict() expects a string literal as the first argument
# This technically works at runtime but doesn't make sense.
Point2 = TypedDict('Point2', {b'x': int})  # E: Invalid TypedDict() field name
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

-- NOTE: The following code works at runtime but is not yet supported by mypy.
--       Keyword arguments may potentially be supported in the future.
[case testCannotCreateTypedDictTypeWithNonpositionalArgs]
from typing import TypedDict
Point = TypedDict(typename='Point', fields={'x': int, 'y': int})  # E: Unexpected arguments to TypedDict()
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testCannotCreateTypedDictTypeWithInvalidItemName]
from typing import TypedDict
Point = TypedDict('Point', {int: int, int: int})  # E: Invalid TypedDict() field name
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testCannotCreateTypedDictTypeWithInvalidItemType]
from typing import TypedDict
Point = TypedDict('Point', {'x': 1, 'y': 1})  # E: Invalid type: try using Literal[1] instead?
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testCannotCreateTypedDictTypeWithInvalidName2]
from typing import TypedDict
X = TypedDict('Y', {'x': int})  # E: First argument "Y" to TypedDict() does not match variable name "X"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]


-- Overloading

[case testTypedDictOverloading]
from typing import overload, Iterable, TypedDict

A = TypedDict('A', {'x': int})

@overload
def f(x: Iterable[str]) -> str: ...
@overload
def f(x: int) -> int: ...
def f(x): pass

a: A
reveal_type(f(a))  # N: Revealed type is "builtins.str"
reveal_type(f(1))  # N: Revealed type is "builtins.int"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictOverloading2]
from typing import overload, Iterable, TypedDict

A = TypedDict('A', {'x': int})

@overload
def f(x: Iterable[int]) -> None: ...
@overload
def f(x: int) -> None: ...
def f(x): pass

a: A
f(a)
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]
[out]
main:12: error: Argument 1 to "f" has incompatible type "A"; expected "Iterable[int]"
main:12: note: Following member(s) of "A" have conflicts:
main:12: note:     Expected:
main:12: note:         def __iter__(self) -> Iterator[int]
main:12: note:     Got:
main:12: note:         def __iter__(self) -> Iterator[str]

[case testTypedDictOverloading3]
from typing import TypedDict, overload

A = TypedDict('A', {'x': int})

@overload
def f(x: str) -> None: ...
@overload
def f(x: int) -> None: ...
def f(x): pass

a: A
f(a)  # E: No overload variant of "f" matches argument type "A" \
      # N: Possible overload variants: \
      # N:     def f(x: str) -> None \
      # N:     def f(x: int) -> None
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictOverloading4]
from typing import TypedDict, overload

A = TypedDict('A', {'x': int})
B = TypedDict('B', {'x': str})

@overload
def f(x: A) -> int: ...
@overload
def f(x: int) -> str: ...
def f(x): pass

a: A
b: B
reveal_type(f(a)) # N: Revealed type is "builtins.int"
reveal_type(f(1)) # N: Revealed type is "builtins.str"
f(b) # E: Argument 1 to "f" has incompatible type "B"; expected "A"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictOverloading5]
from typing import TypedDict, overload

A = TypedDict('A', {'x': int})
B = TypedDict('B', {'y': str})
C = TypedDict('C', {'y': int})

@overload
def f(x: A) -> None: ...
@overload
def f(x: B) -> None: ...
def f(x): pass

a: A
b: B
c: C
f(a)
f(b)
f(c) # E: Argument 1 to "f" has incompatible type "C"; expected "A"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictOverloading6]
from typing import TypedDict, overload

A = TypedDict('A', {'x': int})
B = TypedDict('B', {'y': str})

@overload
def f(x: A) -> int: ...
@overload
def f(x: B) -> str: ...
def f(x): pass

a: A
b: B
reveal_type(f(a)) # N: Revealed type is "builtins.int"
reveal_type(f(b)) # N: Revealed type is "builtins.str"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]


-- Special cases

[case testForwardReferenceInTypedDict]
from typing import TypedDict, Mapping
X = TypedDict('X', {'b': 'B', 'c': 'C'})
class B: pass
class C(B): pass
x: X
reveal_type(x) # N: Revealed type is "TypedDict('__main__.X', {'b': __main__.B, 'c': __main__.C})"
m1: Mapping[str, object] = x
m2: Mapping[str, B] = x # E: Incompatible types in assignment (expression has type "X", variable has type "Mapping[str, B]")
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testForwardReferenceInClassTypedDict]
from typing import TypedDict, Mapping
class X(TypedDict):
    b: 'B'
    c: 'C'
class B: pass
class C(B): pass
x: X
reveal_type(x) # N: Revealed type is "TypedDict('__main__.X', {'b': __main__.B, 'c': __main__.C})"
m1: Mapping[str, object] = x
m2: Mapping[str, B] = x # E: Incompatible types in assignment (expression has type "X", variable has type "Mapping[str, B]")
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testForwardReferenceToTypedDictInTypedDict]
from typing import TypedDict, Mapping
X = TypedDict('X', {'a': 'A'})
A = TypedDict('A', {'b': int})
x: X
reveal_type(x) # N: Revealed type is "TypedDict('__main__.X', {'a': TypedDict('__main__.A', {'b': builtins.int})})"
reveal_type(x['a']['b']) # N: Revealed type is "builtins.int"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testSelfRecursiveTypedDictInheriting]
from typing import TypedDict

def test() -> None:
    class MovieBase(TypedDict):
        name: str
        year: int

    class Movie(MovieBase):
        director: 'Movie' # E: Cannot resolve name "Movie" (possible cyclic definition) \
                          # N: Recursive types are not allowed at function scope
    m: Movie
    reveal_type(m['director']['name']) # N: Revealed type is "Any"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testSubclassOfRecursiveTypedDict]
from typing import List, TypedDict

def test() -> None:
    class Command(TypedDict):
        subcommands: List['Command']  # E: Cannot resolve name "Command" (possible cyclic definition) \
                                      # N: Recursive types are not allowed at function scope

    class HelpCommand(Command):
        pass

    hc = HelpCommand(subcommands=[])
    reveal_type(hc)  # N: Revealed type is "TypedDict('__main__.HelpCommand@7', {'subcommands': builtins.list[Any]})"
[builtins fixtures/list.pyi]
[typing fixtures/typing-typeddict.pyi]
[out]

[case testTypedDictForwardAsUpperBound]
from typing import TypedDict, TypeVar, Generic
T = TypeVar('T', bound='M')
class G(Generic[T]):
    x: T

yb: G[int] # E: Type argument "int" of "G" must be a subtype of "M"
yg: G[M]
z: int = G[M]().x['x']  # type: ignore[used-before-def]

class M(TypedDict):
    x: int
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]
[out]

[case testTypedDictWithImportCycleForward]
import a
[file a.py]
from typing import TypedDict
from b import f

N = TypedDict('N', {'a': str})
[file b.py]
import a

def f(x: a.N) -> None:
    reveal_type(x)
    reveal_type(x['a'])
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]
[out]
tmp/b.py:4: note: Revealed type is "TypedDict('a.N', {'a': builtins.str})"
tmp/b.py:5: note: Revealed type is "builtins.str"

[case testTypedDictImportCycle]

import b
[file a.py]
class C:
    pass

from b import tp
x: tp
reveal_type(x['x'])  # N: Revealed type is "builtins.int"

reveal_type(tp)  # N: Revealed type is "def (*, x: builtins.int) -> TypedDict('b.tp', {'x': builtins.int})"
tp(x='no')  # E: Incompatible types (expression has type "str", TypedDict item "x" has type "int")

[file b.py]
from a import C
from typing import TypedDict

tp = TypedDict('tp', {'x': int})
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]
[out]

[case testTypedDictAsStarStarArg]
from typing import TypedDict

A = TypedDict('A', {'x': int, 'y': str})
class B: pass

def f1(x: int, y: str) -> None: ...
def f2(x: int, y: int) -> None: ...
def f3(x: B, y: str) -> None: ...
def f4(x: int) -> None: pass
def f5(x: int, y: str, z: int) -> None: pass
def f6(x: int, z: str) -> None: pass

a: A
f1(**a)
f2(**a) # E: Argument "y" to "f2" has incompatible type "str"; expected "int"
f3(**a) # E: Argument "x" to "f3" has incompatible type "int"; expected "B"
f4(**a) # E: Extra argument "y" from **args for "f4"
f5(**a) # E: Missing positional arguments "y", "z" in call to "f5"
f6(**a) # E: Extra argument "y" from **args for "f6"
f1(1, **a) # E: "f1" gets multiple values for keyword argument "x"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictAsStarStarArgConstraints]
from typing import TypedDict, TypeVar, Union

T = TypeVar('T')
S = TypeVar('S')
def f1(x: T, y: S) -> Union[T, S]: ...

A = TypedDict('A', {'y': int, 'x': str})
a: A
reveal_type(f1(**a)) # N: Revealed type is "Union[builtins.str, builtins.int]"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictAsStarStarArgCalleeKwargs]
from typing import TypedDict

A = TypedDict('A', {'x': int, 'y': str})
B = TypedDict('B', {'x': str, 'y': str})

def f(**kwargs: str) -> None: ...
def g(x: int, **kwargs: str) -> None: ...

a: A
b: B
f(**a) # E: Argument 1 to "f" has incompatible type "**A"; expected "str"
f(**b)
g(**a)
g(**b) # E: Argument "x" to "g" has incompatible type "str"; expected "int"
g(1, **a) # E: "g" gets multiple values for keyword argument "x"
g(1, **b) # E: "g" gets multiple values for keyword argument "x" \
          # E: Argument "x" to "g" has incompatible type "str"; expected "int"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictAsStarStarTwice]
from typing import TypedDict

A = TypedDict('A', {'x': int, 'y': str})
B = TypedDict('B', {'z': bytes})
C = TypedDict('C', {'x': str, 'z': bytes})

def f1(x: int, y: str, z: bytes) -> None: ...
def f2(x: int, y: float, z: bytes) -> None: ...
def f3(x: int, y: str, z: float) -> None: ...

a: A
b: B
c: C
f1(**a, **b)
f1(**b, **a)
f2(**a, **b) # E: Argument "y" to "f2" has incompatible type "str"; expected "float"
f3(**a, **b) # E: Argument "z" to "f3" has incompatible type "bytes"; expected "float"
f3(**b, **a) # E: Argument "z" to "f3" has incompatible type "bytes"; expected "float"
f1(**a, **c) # E: "f1" gets multiple values for keyword argument "x" \
             # E: Argument "x" to "f1" has incompatible type "str"; expected "int"
f1(**c, **a) # E: "f1" gets multiple values for keyword argument "x" \
             # E: Argument "x" to "f1" has incompatible type "str"; expected "int"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictAsStarStarAndDictAsStarStar]
from typing import Any, Dict, TypedDict

TD = TypedDict('TD', {'x': int, 'y': str})

def f1(x: int, y: str, z: bytes) -> None: ...
def f2(x: int, y: str) -> None: ...

td: TD
d: Dict[Any, Any]

f1(**td, **d)
f1(**d, **td)
f2(**td, **d)
f2(**d, **td)
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictNonMappingMethods]
from typing import List, TypedDict

A = TypedDict('A', {'x': int, 'y': List[int]})
a: A

reveal_type(a.copy()) # N: Revealed type is "TypedDict('__main__.A', {'x': builtins.int, 'y': builtins.list[builtins.int]})"
a.has_key('x') # E: "A" has no attribute "has_key"
# TODO: Better error message
a.clear() # E: "A" has no attribute "clear"

a.setdefault('invalid', 1) # E: TypedDict "A" has no key "invalid"
reveal_type(a.setdefault('x', 1)) # N: Revealed type is "builtins.int"
reveal_type(a.setdefault('y', [])) # N: Revealed type is "builtins.list[builtins.int]"
a.setdefault('y', '') # E: Argument 2 to "setdefault" of "TypedDict" has incompatible type "str"; expected "List[int]"
x = ''
a.setdefault(x, 1) # E: Expected TypedDict key to be string literal
alias = a.setdefault
alias(x, 1) # E: Argument 1 has incompatible type "str"; expected "Never"

a.update({})
a.update({'x': 1})
a.update({'x': ''}) # E: Incompatible types (expression has type "str", TypedDict item "x" has type "int")
a.update({'x': 1, 'y': []})
a.update({'x': 1, 'y': [1]})
a.update({'z': 1}) # E: Unexpected TypedDict key "z"
a.update({'z': 1, 'zz': 1}) # E: Unexpected TypedDict keys ("z", "zz")
a.update({'z': 1, 'x': 1}) # E: Expected TypedDict key "x" but found keys ("z", "x")
d = {'x': 1}
a.update(d) # E: Argument 1 to "update" of "TypedDict" has incompatible type "Dict[str, int]"; expected "TypedDict({'x'?: int, 'y'?: List[int]})"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictPopMethod]
from typing import List, TypedDict

A = TypedDict('A', {'x': int, 'y': List[int]}, total=False)
B = TypedDict('B', {'x': int})
a: A
b: B

reveal_type(a.pop('x')) # N: Revealed type is "builtins.int"
reveal_type(a.pop('y', [])) # N: Revealed type is "builtins.list[builtins.int]"
reveal_type(a.pop('x', '')) # N: Revealed type is "Union[builtins.int, Literal['']?]"
reveal_type(a.pop('x', (1, 2))) # N: Revealed type is "Union[builtins.int, Tuple[Literal[1]?, Literal[2]?]]"
a.pop('invalid', '') # E: TypedDict "A" has no key "invalid"
b.pop('x') # E: Key "x" of TypedDict "B" cannot be deleted
x = ''
b.pop(x) # E: Expected TypedDict key to be string literal
pop = b.pop
pop('x') # E: Argument 1 has incompatible type "str"; expected "Never"
pop('invalid') # E: Argument 1 has incompatible type "str"; expected "Never"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictDel]
from typing import List, TypedDict

A = TypedDict('A', {'x': int, 'y': List[int]}, total=False)
B = TypedDict('B', {'x': int})
a: A
b: B

del a['x']
del a['invalid'] # E: TypedDict "A" has no key "invalid"
del b['x'] # E: Key "x" of TypedDict "B" cannot be deleted
s = ''
del a[s] # E: Expected TypedDict key to be string literal
del b[s] # E: Expected TypedDict key to be string literal
alias = b.__delitem__
alias('x')
alias(s)
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testPluginUnionsOfTypedDicts]
from typing import TypedDict, Union

class TDA(TypedDict):
    a: int
    b: str

class TDB(TypedDict):
    a: int
    b: int
    c: int

td: Union[TDA, TDB]

reveal_type(td.get('a'))  # N: Revealed type is "Union[builtins.int, None]"
reveal_type(td.get('b'))  # N: Revealed type is "Union[builtins.str, None, builtins.int]"
reveal_type(td.get('c'))  # N: Revealed type is "builtins.object"

reveal_type(td['a'])  # N: Revealed type is "builtins.int"
reveal_type(td['b'])  # N: Revealed type is "Union[builtins.str, builtins.int]"
reveal_type(td['c'])  # N: Revealed type is "Union[Any, builtins.int]" \
                      # E: TypedDict "TDA" has no key "c"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testPluginUnionsOfTypedDictsNonTotal]
from typing import TypedDict, Union

class TDA(TypedDict, total=False):
    a: int
    b: str

class TDB(TypedDict, total=False):
    a: int
    b: int
    c: int

td: Union[TDA, TDB]

reveal_type(td.pop('a'))  # N: Revealed type is "builtins.int"
reveal_type(td.pop('b'))  # N: Revealed type is "Union[builtins.str, builtins.int]"
reveal_type(td.pop('c'))  # N: Revealed type is "Union[Any, builtins.int]" \
                          # E: TypedDict "TDA" has no key "c"

[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testCanCreateTypedDictWithTypingExtensions]
from typing_extensions import TypedDict

class Point(TypedDict):
    x: int
    y: int

p = Point(x=42, y=1337)
reveal_type(p)  # N: Revealed type is "TypedDict('__main__.Point', {'x': builtins.int, 'y': builtins.int})"
[builtins fixtures/dict.pyi]

[case testCanCreateTypedDictWithTypingProper]
from typing import TypedDict

class Point(TypedDict):
    x: int
    y: int

p = Point(x=42, y=1337)
reveal_type(p)  # N: Revealed type is "TypedDict('__main__.Point', {'x': builtins.int, 'y': builtins.int})"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictOptionalUpdate]
from typing import TypedDict, Union

class A(TypedDict):
    x: int

d: A
d.update({'x': 1})
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictOverlapWithDict]
# mypy: strict-equality
from typing import TypedDict, Dict

class Config(TypedDict):
    a: str
    b: str

x: Dict[str, str]
y: Config

x == y
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictOverlapWithDictNonOverlapping]
# mypy: strict-equality
from typing import TypedDict, Dict

class Config(TypedDict):
    a: str
    b: int

x: Dict[str, str]
y: Config

x == y  # E: Non-overlapping equality check (left operand type: "Dict[str, str]", right operand type: "Config")
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictOverlapWithDictNonTotal]
# mypy: strict-equality
from typing import TypedDict, Dict

class Config(TypedDict, total=False):
    a: str
    b: int

x: Dict[str, str]
y: Config

x == y
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictOverlapWithDictNonTotalNonOverlapping]
# mypy: strict-equality
from typing import TypedDict, Dict

class Config(TypedDict, total=False):
    a: int
    b: int

x: Dict[str, str]
y: Config

x == y  # E: Non-overlapping equality check (left operand type: "Dict[str, str]", right operand type: "Config")
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictOverlapWithDictEmpty]
# mypy: strict-equality
from typing import TypedDict

class Config(TypedDict):
    a: str
    b: str

x: Config
x == {}  # E: Non-overlapping equality check (left operand type: "Config", right operand type: "Dict[Never, Never]")
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictOverlapWithDictNonTotalEmpty]
# mypy: strict-equality
from typing import TypedDict

class Config(TypedDict, total=False):
    a: str
    b: str

x: Config
x == {}
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictOverlapWithDictNonStrKey]
# mypy: strict-equality
from typing import TypedDict, Dict, Union

class Config(TypedDict):
    a: str
    b: str

x: Config
y: Dict[Union[str, int], str]
x == y
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictOverlapWithDictOverload]
from typing import overload, TypedDict, Dict

class Map(TypedDict):
    x: int
    y: str

@overload
def func(x: Map) -> int: ...
@overload
def func(x: Dict[str, str]) -> str: ...
def func(x):
    pass
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictOverlapWithDictOverloadBad]
from typing import overload, TypedDict, Dict

class Map(TypedDict, total=False):
    x: int
    y: str

@overload
def func(x: Map) -> int: ...  # E: Overloaded function signatures 1 and 2 overlap with incompatible return types
@overload
def func(x: Dict[str, str]) -> str: ...
def func(x):
    pass
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictOverlapWithDictOverloadMappingBad]
from typing import overload, TypedDict, Mapping

class Map(TypedDict, total=False):
    x: int
    y: str

@overload
def func(x: Map) -> int: ...  # E: Overloaded function signatures 1 and 2 overlap with incompatible return types
@overload
def func(x: Mapping[str, str]) -> str: ...
def func(x):
    pass
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictOverlapWithDictOverloadNonStrKey]
from typing import overload, TypedDict, Dict

class Map(TypedDict):
    x: str
    y: str

@overload
def func(x: Map) -> int: ...
@overload
def func(x: Dict[int, str]) -> str: ...
def func(x):
    pass
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictIsInstance]
from typing import TypedDict, Union

class User(TypedDict):
    id: int
    name: str

u: Union[str, User]
u2: User

if isinstance(u, dict):
    reveal_type(u)  # N: Revealed type is "TypedDict('__main__.User', {'id': builtins.int, 'name': builtins.str})"
else:
    reveal_type(u)  # N: Revealed type is "builtins.str"

assert isinstance(u2, dict)
reveal_type(u2)  # N: Revealed type is "TypedDict('__main__.User', {'id': builtins.int, 'name': builtins.str})"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictIsInstanceABCs]
from typing import TypedDict, Union, Mapping, Iterable

class User(TypedDict):
    id: int
    name: str

u: Union[int, User]
u2: User

if isinstance(u, Iterable):
    reveal_type(u)  # N: Revealed type is "TypedDict('__main__.User', {'id': builtins.int, 'name': builtins.str})"
else:
    reveal_type(u)  # N: Revealed type is "builtins.int"

assert isinstance(u2, Mapping)
reveal_type(u2)  # N: Revealed type is "TypedDict('__main__.User', {'id': builtins.int, 'name': builtins.str})"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-full.pyi]

[case testTypedDictLiteralTypeKeyInCreation]
from typing import TypedDict, Final, Literal

class Value(TypedDict):
    num: int

num: Final = 'num'
v: Value = {num: 5}
v = {num: ''}  # E: Incompatible types (expression has type "str", TypedDict item "num" has type "int")

bad: Final = 2
v = {bad: 3}  # E: Expected TypedDict key to be string literal
union: Literal['num', 'foo']
v = {union: 2} # E: Expected TypedDict key to be string literal
num2: Literal['num']
v = {num2: 2}
bad2: Literal['bad']
v = {bad2: 2}  # E: Missing key "num" for TypedDict "Value" \
               # E: Extra key "bad" for TypedDict "Value"

[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testOperatorContainsNarrowsTypedDicts_unionWithList]
from __future__ import annotations
from typing import assert_type, TypedDict, Union
from typing_extensions import final

@final
class D(TypedDict):
    foo: int


d_or_list: D | list[str]

if 'foo' in d_or_list:
    assert_type(d_or_list, Union[D, list[str]])
elif 'bar' in d_or_list:
    assert_type(d_or_list, list[str])
else:
    assert_type(d_or_list, list[str])

[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testOperatorContainsNarrowsTypedDicts_total]
from __future__ import annotations
from typing import assert_type, Literal, TypedDict, TypeVar, Union
from typing_extensions import final

@final
class D1(TypedDict):
    foo: int


@final
class D2(TypedDict):
    bar: int


d: D1 | D2

if 'foo' in d:
    assert_type(d, D1)
else:
    assert_type(d, D2)

foo_or_bar: Literal['foo', 'bar']
if foo_or_bar in d:
    assert_type(d, Union[D1, D2])
else:
    assert_type(d, Union[D1, D2])

foo_or_invalid: Literal['foo', 'invalid']
if foo_or_invalid in d:
    assert_type(d, D1)
    # won't narrow 'foo_or_invalid'
    assert_type(foo_or_invalid, Literal['foo', 'invalid'])
else:
    assert_type(d, Union[D1, D2])
    # won't narrow 'foo_or_invalid'
    assert_type(foo_or_invalid, Literal['foo', 'invalid'])

TD = TypeVar('TD', D1, D2)

def f(arg: TD) -> None:
    value: int
    if 'foo' in arg:
        assert_type(arg['foo'], int)
    else:
        assert_type(arg['bar'], int)


[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testOperatorContainsNarrowsTypedDicts_final]
# flags: --warn-unreachable
from __future__ import annotations
from typing import assert_type, TypedDict, Union
from typing_extensions import final

@final
class DFinal(TypedDict):
    foo: int


class DNotFinal(TypedDict):
    bar: int


d_not_final: DNotFinal

if 'bar' in d_not_final:
    assert_type(d_not_final, DNotFinal)
else:
    spam = 'ham'  # E: Statement is unreachable

if 'spam' in d_not_final:
    assert_type(d_not_final, DNotFinal)
else:
    assert_type(d_not_final, DNotFinal)

d_final: DFinal

if 'spam' in d_final:
    spam = 'ham'  # E: Statement is unreachable
else:
    assert_type(d_final, DFinal)

d_union: DFinal | DNotFinal

if 'foo' in d_union:
    assert_type(d_union, Union[DFinal, DNotFinal])
else:
    assert_type(d_union, DNotFinal)

[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testOperatorContainsNarrowsTypedDicts_partialThroughTotalFalse]
from __future__ import annotations
from typing import assert_type, Literal, TypedDict, Union
from typing_extensions import final

@final
class DTotal(TypedDict):
    required_key: int


@final
class DNotTotal(TypedDict, total=False):
    optional_key: int


d: DTotal | DNotTotal

if 'required_key' in d:
    assert_type(d, DTotal)
else:
    assert_type(d, DNotTotal)

if 'optional_key' in d:
    assert_type(d, DNotTotal)
else:
    assert_type(d, Union[DTotal, DNotTotal])

key: Literal['optional_key', 'required_key']
if key in d:
    assert_type(d, Union[DTotal, DNotTotal])
else:
    assert_type(d, Union[DTotal, DNotTotal])

[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testOperatorContainsNarrowsTypedDicts_partialThroughNotRequired]
from __future__ import annotations
from typing import assert_type, Required, NotRequired, TypedDict, Union
from typing_extensions import final

@final
class D1(TypedDict):
    required_key: Required[int]
    optional_key: NotRequired[int]


@final
class D2(TypedDict):
    abc: int
    xyz: int


d: D1 | D2

if 'required_key' in d:
    assert_type(d, D1)
else:
    assert_type(d, D2)

if 'optional_key' in d:
    assert_type(d, D1)
else:
    assert_type(d, Union[D1, D2])

[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testCannotSubclassFinalTypedDict]
from typing import TypedDict
from typing_extensions import final

@final
class DummyTypedDict(TypedDict):
    int_val: int
    float_val: float
    str_val: str

class SubType(DummyTypedDict): # E: Cannot inherit from final class "DummyTypedDict"
    pass

[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testCannotSubclassFinalTypedDictWithForwardDeclarations]
from typing import TypedDict
from typing_extensions import final

@final
class DummyTypedDict(TypedDict):
    forward_declared: "ForwardDeclared"

class SubType(DummyTypedDict): # E: Cannot inherit from final class "DummyTypedDict"
    pass

class ForwardDeclared: pass

[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictTypeNarrowingWithFinalKey]
from typing import Final, Optional, TypedDict

KEY_NAME: Final = "bar"
class Foo(TypedDict):
    bar: Optional[str]

foo = Foo(bar="hello")
if foo["bar"] is not None:
    reveal_type(foo["bar"])     # N: Revealed type is "builtins.str"
    reveal_type(foo[KEY_NAME])  # N: Revealed type is "builtins.str"
if foo[KEY_NAME] is not None:
    reveal_type(foo["bar"])     # N: Revealed type is "builtins.str"
    reveal_type(foo[KEY_NAME])  # N: Revealed type is "builtins.str"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictDoubleForwardClass]
from typing import Any, List, TypedDict

class Foo(TypedDict):
    bar: Bar
    baz: Bar

Bar = List[Any]

foo: Foo
reveal_type(foo['bar'])  # N: Revealed type is "builtins.list[Any]"
reveal_type(foo['baz'])  # N: Revealed type is "builtins.list[Any]"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictDoubleForwardFunc]
from typing import Any, List, TypedDict

Foo = TypedDict('Foo', {'bar': 'Bar', 'baz': 'Bar'})

Bar = List[Any]

foo: Foo
reveal_type(foo['bar'])   # N: Revealed type is "builtins.list[Any]"
reveal_type(foo['baz'])  # N: Revealed type is "builtins.list[Any]"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictDoubleForwardMixed]
from typing import Any, List, TypedDict

Bar = List[Any]

class Foo(TypedDict):
    foo: Toto
    bar: Bar
    baz: Bar

Toto = int

foo: Foo
reveal_type(foo['foo'])  # N: Revealed type is "builtins.int"
reveal_type(foo['bar'])  # N: Revealed type is "builtins.list[Any]"
reveal_type(foo['baz'])  # N: Revealed type is "builtins.list[Any]"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testAssignTypedDictAsAttribute]
from typing import TypedDict

class A:
    def __init__(self) -> None:
        self.b = TypedDict('b', {'x': int, 'y': str})  # E: TypedDict type as attribute is not supported

reveal_type(A().b)  # N: Revealed type is "Any"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictAsUpperBoundAndIndexedAssign]
from typing import TypeVar, Generic, TypedDict


class BaseDict(TypedDict, total=False):
    foo: int


_DICT_T = TypeVar('_DICT_T', bound=BaseDict)


class SomeGeneric(Generic[_DICT_T]):
    def __init__(self, data: _DICT_T) -> None:
        self._data: _DICT_T = data

    def set_state(self) -> None:
        self._data['foo'] = 1
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictCreatedWithEmptyDict]
from typing import TypedDict

class TD(TypedDict, total=False):
    foo: int
    bar: int

d: TD = dict()
d2: TD = dict(foo=1)
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictBytesKey]
from typing import TypedDict

class TD(TypedDict):
    foo: int

d: TD = {b'foo': 2} # E: Expected TypedDict key to be string literal
d[b'foo'] = 3 # E: TypedDict key must be a string literal; expected one of ("foo") \
    # E: Argument 1 to "__setitem__" has incompatible type "bytes"; expected "str"
d[b'foo'] # E: TypedDict key must be a string literal; expected one of ("foo")
d[3] # E: TypedDict key must be a string literal; expected one of ("foo")
d[True] # E: TypedDict key must be a string literal; expected one of ("foo")
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictUppercaseKey]
from typing import TypedDict

Foo = TypedDict('Foo', {'camelCaseKey': str})
value: Foo = {}  # E: Missing key "camelCaseKey" for TypedDict "Foo"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictWithDeferredFieldTypeEval]
from typing import Generic, TypeVar, TypedDict, NotRequired

class Foo(TypedDict):
    y: NotRequired[int]
    x: Outer[Inner[ForceDeferredEval]]

var: Foo
reveal_type(var)  # N: Revealed type is "TypedDict('__main__.Foo', {'y'?: builtins.int, 'x': __main__.Outer[__main__.Inner[__main__.ForceDeferredEval]]})"

T1 = TypeVar("T1")
class Outer(Generic[T1]): pass

T2 = TypeVar("T2", bound="ForceDeferredEval")
class Inner(Generic[T2]): pass

class ForceDeferredEval: pass
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictRequiredUnimportedAny]
# flags: --disallow-any-unimported
from typing import NotRequired, TypedDict, ReadOnly
from nonexistent import Foo  # type: ignore[import-not-found]
class Bar(TypedDict):
    foo: NotRequired[Foo]  # E: Type of variable becomes "Any" due to an unfollowed import
    bar: ReadOnly[Foo]  # E: Type of variable becomes "Any" due to an unfollowed import
    baz: NotRequired[ReadOnly[Foo]]  # E: Type of variable becomes "Any" due to an unfollowed import
[typing fixtures/typing-typeddict.pyi]

-- Required[]

[case testDoesRecognizeRequiredInTypedDictWithClass]
from typing import TypedDict
from typing import Required
class Movie(TypedDict, total=False):
    title: Required[str]
    year: int
m = Movie(title='The Matrix')
m = Movie()  # E: Missing key "title" for TypedDict "Movie"
[typing fixtures/typing-typeddict.pyi]

[case testDoesRecognizeRequiredInTypedDictWithAssignment]
from typing import TypedDict
from typing import Required
Movie = TypedDict('Movie', {
    'title': Required[str],
    'year': int,
}, total=False)
m = Movie(title='The Matrix')
m = Movie()  # E: Missing key "title" for TypedDict "Movie"
[typing fixtures/typing-typeddict.pyi]

[case testDoesDisallowRequiredOutsideOfTypedDict]
from typing import Required
x: Required[int] = 42  # E: Required[] can be only used in a TypedDict definition
[typing fixtures/typing-typeddict.pyi]

[case testDoesOnlyAllowRequiredInsideTypedDictAtTopLevel]
from typing import TypedDict
from typing import Union
from typing import Required
Movie = TypedDict('Movie', {
    'title': Union[
        Required[str],  # E: Required[] can be only used in a TypedDict definition
        bytes
    ],
    'year': int,
}, total=False)
[typing fixtures/typing-typeddict.pyi]

[case testDoesDisallowRequiredInsideRequired]
from typing import TypedDict
from typing import Union
from typing import Required
Movie = TypedDict('Movie', {
    'title': Required[Union[
        Required[str],  # E: Required[] can be only used in a TypedDict definition
        bytes
    ]],
    'year': int,
}, total=False)
[typing fixtures/typing-typeddict.pyi]

[case testRequiredOnlyAllowsOneItem]
from typing import TypedDict
from typing import Required
class Movie(TypedDict, total=False):
    title: Required[str, bytes]  # E: Required[] must have exactly one type argument
    year: int
[typing fixtures/typing-typeddict.pyi]

[case testRequiredExplicitAny]
# flags: --disallow-any-explicit
from typing import TypedDict
from typing import Required
Foo = TypedDict("Foo", {"a.x": Required[int]})
[typing fixtures/typing-typeddict.pyi]

-- NotRequired[]

[case testDoesRecognizeNotRequiredInTypedDictWithClass]
from typing import TypedDict
from typing import NotRequired
class Movie(TypedDict):
    title: str
    year: NotRequired[int]
m = Movie(title='The Matrix')
m = Movie()  # E: Missing key "title" for TypedDict "Movie"
[typing fixtures/typing-typeddict.pyi]

[case testDoesRecognizeNotRequiredInTypedDictWithAssignment]
from typing import TypedDict
from typing import NotRequired
Movie = TypedDict('Movie', {
    'title': str,
    'year': NotRequired[int],
})
m = Movie(title='The Matrix')
m = Movie()  # E: Missing key "title" for TypedDict "Movie"
[typing fixtures/typing-typeddict.pyi]

[case testDoesDisallowNotRequiredOutsideOfTypedDict]
from typing import NotRequired
x: NotRequired[int] = 42  # E: NotRequired[] can be only used in a TypedDict definition
[typing fixtures/typing-typeddict.pyi]

[case testDoesOnlyAllowNotRequiredInsideTypedDictAtTopLevel]
from typing import TypedDict
from typing import Union
from typing import NotRequired
Movie = TypedDict('Movie', {
    'title': Union[
        NotRequired[str],  # E: NotRequired[] can be only used in a TypedDict definition
        bytes
    ],
    'year': int,
})
[typing fixtures/typing-typeddict.pyi]

[case testDoesDisallowNotRequiredInsideNotRequired]
from typing import TypedDict
from typing import Union
from typing import NotRequired
Movie = TypedDict('Movie', {
    'title': NotRequired[Union[
        NotRequired[str],  # E: NotRequired[] can be only used in a TypedDict definition
        bytes
    ]],
    'year': int,
})
[typing fixtures/typing-typeddict.pyi]

[case testNotRequiredOnlyAllowsOneItem]
from typing import TypedDict
from typing import NotRequired
class Movie(TypedDict):
    title: NotRequired[str, bytes]  # E: NotRequired[] must have exactly one type argument
    year: int
[typing fixtures/typing-typeddict.pyi]

[case testNotRequiredExplicitAny]
# flags: --disallow-any-explicit
from typing import TypedDict
from typing import NotRequired
Foo = TypedDict("Foo", {"a.x": NotRequired[int]})
[typing fixtures/typing-typeddict.pyi]

-- Union dunders

[case testTypedDictUnionGetItem]
from typing import TypedDict, Union

class Foo1(TypedDict):
    z: str
    a: int
class Foo2(TypedDict):
    z: str
    b: int

def func(foo: Union[Foo1, Foo2]) -> str:
    reveal_type(foo["z"])  # N: Revealed type is "builtins.str"
    # ok, but type is incorrect:
    reveal_type(foo.__getitem__("z"))  # N: Revealed type is "builtins.object"

    reveal_type(foo["a"])  # N: Revealed type is "Union[builtins.int, Any]" \
                           # E: TypedDict "Foo2" has no key "a"
    reveal_type(foo["b"])  # N: Revealed type is "Union[Any, builtins.int]" \
                           # E: TypedDict "Foo1" has no key "b"
    reveal_type(foo["missing"])  # N: Revealed type is "Any" \
                                 # E: TypedDict "Foo1" has no key "missing" \
                                 # E: TypedDict "Foo2" has no key "missing"
    reveal_type(foo[1])  # N: Revealed type is "Any" \
                         # E: TypedDict key must be a string literal; expected one of ("z", "a") \
                         # E: TypedDict key must be a string literal; expected one of ("z", "b")

    return foo["z"]
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]


[case testTypedDictUnionSetItem]
from typing import TypedDict, Union

class Foo1(TypedDict):
    z: str
    a: int
class Foo2(TypedDict):
    z: str
    b: int

def func(foo: Union[Foo1, Foo2]):
    foo["z"] = "a"  # ok
    foo.__setitem__("z", "a")  # ok

    foo["z"] = 1  # E: Value of "z" has incompatible type "int"; expected "str"

    foo["a"] = 1  # E: TypedDict "Foo2" has no key "a"
    foo["b"] = 2  # E: TypedDict "Foo1" has no key "b"

    foo["missing"] = 1  # E: TypedDict "Foo1" has no key "missing" \
                        # E: TypedDict "Foo2" has no key "missing"
    foo[1] = "m"  # E: TypedDict key must be a string literal; expected one of ("z", "a") \
                  # E: TypedDict key must be a string literal; expected one of ("z", "b") \
                  # E: Argument 1 to "__setitem__" has incompatible type "int"; expected "str"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]


[case testTypedDictUnionDelItem]
from typing import TypedDict, Union

class Foo1(TypedDict):
    z: str
    a: int
class Foo2(TypedDict):
    z: str
    b: int

def func(foo: Union[Foo1, Foo2]):
    del foo["z"]  # E: Key "z" of TypedDict "Foo1" cannot be deleted \
                  # E: Key "z" of TypedDict "Foo2" cannot be deleted
    foo.__delitem__("z")  # E: Key "z" of TypedDict "Foo1" cannot be deleted \
                          # E: Key "z" of TypedDict "Foo2" cannot be deleted

    del foo["a"]  # E: Key "a" of TypedDict "Foo1" cannot be deleted \
                  # E: TypedDict "Foo2" has no key "a"
    del foo["b"]  # E: TypedDict "Foo1" has no key "b" \
                  # E: Key "b" of TypedDict "Foo2" cannot be deleted

    del foo["missing"]  # E: TypedDict "Foo1" has no key "missing" \
                        # E: TypedDict "Foo2" has no key "missing"
    del foo[1]  # E: Argument 1 to "__delitem__" has incompatible type "int"; expected "str" \
                # E: Expected TypedDict key to be string literal

[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]


[case testTypedDictTypeVarUnionSetItem]
from typing import TypedDict, Union, TypeVar

F1 = TypeVar('F1', bound='Foo1')
F2 = TypeVar('F2', bound='Foo2')

class Foo1(TypedDict):
    z: str
    a: int
class Foo2(TypedDict):
    z: str
    b: int

def func(foo: Union[F1, F2]):
    foo["z"] = "a"  # ok
    foo["z"] = 1  # E: Value of "z" has incompatible type "int"; expected "str"

    foo["a"] = 1  # E: TypedDict "Foo2" has no key "a"
    foo["b"] = 2  # E: TypedDict "Foo1" has no key "b"

    foo["missing"] = 1  # E: TypedDict "Foo1" has no key "missing" \
                        # E: TypedDict "Foo2" has no key "missing"
    foo[1] = "m"  # E: TypedDict key must be a string literal; expected one of ("z", "a") \
                  # E: TypedDict key must be a string literal; expected one of ("z", "b") \
                  # E: Argument 1 to "__setitem__" has incompatible type "int"; expected "str"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testGenericTypedDictCreation]
from typing import TypedDict, Generic, TypeVar

T = TypeVar("T")

class TD(TypedDict, Generic[T]):
    key: int
    value: T

tds: TD[str]
reveal_type(tds)  # N: Revealed type is "TypedDict('__main__.TD', {'key': builtins.int, 'value': builtins.str})"

tdi = TD(key=0, value=0)
reveal_type(tdi)  # N: Revealed type is "TypedDict('__main__.TD', {'key': builtins.int, 'value': builtins.int})"
TD[str](key=0, value=0)  # E: Incompatible types (expression has type "int", TypedDict item "value" has type "str")
TD[str]({"key": 0, "value": 0})  # E: Incompatible types (expression has type "int", TypedDict item "value" has type "str")
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testGenericTypedDictInference]
from typing import TypedDict, Generic, TypeVar, List

T = TypeVar("T")

class TD(TypedDict, Generic[T]):
    key: int
    value: T

def foo(x: TD[T]) -> List[T]: ...

reveal_type(foo(TD(key=1, value=2)))  # N: Revealed type is "builtins.list[builtins.int]"
reveal_type(foo({"key": 1, "value": 2}))  # N: Revealed type is "builtins.list[builtins.int]"
reveal_type(foo(dict(key=1, value=2)))  # N: Revealed type is "builtins.list[builtins.int]"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testGenericTypedDictExtending]
from typing import TypedDict, Generic, TypeVar, List

T = TypeVar("T")
class TD(TypedDict, Generic[T]):
    key: int
    value: T

S = TypeVar("S")
class STD(TD[List[S]]):
    other: S

std: STD[str]
reveal_type(std)  # N: Revealed type is "TypedDict('__main__.STD', {'key': builtins.int, 'value': builtins.list[builtins.str], 'other': builtins.str})"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testGenericTypedDictExtendingErrors]
from typing import TypedDict, Generic, TypeVar

T = TypeVar("T")
class Base(TypedDict, Generic[T]):
    x: T
class Sub(Base[{}]):  # E: Invalid TypedDict type argument \
                      # E: Type expected within [...] \
                      # E: Invalid base class "Base"
    y: int
s: Sub
reveal_type(s)  # N: Revealed type is "TypedDict('__main__.Sub', {'y': builtins.int})"

class Sub2(Base[int, str]):  # E: Invalid number of type arguments for "Base" \
                             # E: "Base" expects 1 type argument, but 2 given
    y: int
s2: Sub2
reveal_type(s2)  # N: Revealed type is "TypedDict('__main__.Sub2', {'x': Any, 'y': builtins.int})"

class Sub3(Base):  # OK
    y: int
s3: Sub3
reveal_type(s3)  # N: Revealed type is "TypedDict('__main__.Sub3', {'x': Any, 'y': builtins.int})"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictAttributeOnClassObject]
from typing import TypedDict

class TD(TypedDict):
    x: str
    y: str

reveal_type(TD.__iter__)  # N: Revealed type is "def (typing._TypedDict) -> typing.Iterator[builtins.str]"
reveal_type(TD.__annotations__)  # N: Revealed type is "typing.Mapping[builtins.str, builtins.object]"
reveal_type(TD.values)  # N: Revealed type is "def (self: typing.Mapping[T`1, T_co`2]) -> typing.Iterable[T_co`2]"
[builtins fixtures/dict-full.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testGenericTypedDictAlias]
# flags: --disallow-any-generics
from typing import TypedDict, Generic, TypeVar, List

T = TypeVar("T")
class TD(TypedDict, Generic[T]):
    key: int
    value: T

Alias = TD[List[T]]

ad: Alias[str]
reveal_type(ad)  # N: Revealed type is "TypedDict('__main__.TD', {'key': builtins.int, 'value': builtins.list[builtins.str]})"
Alias[str](key=0, value=0)  # E: Incompatible types (expression has type "int", TypedDict item "value" has type "List[str]")

# Generic aliases are *always* filled with Any, so this is different from TD(...) call.
Alias(key=0, value=0)  # E: Missing type parameters for generic type "Alias" \
                       # E: Incompatible types (expression has type "int", TypedDict item "value" has type "List[Any]")
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testGenericTypedDictMultipleGenerics]
# See https://github.com/python/mypy/issues/13755
from typing import Generic, TypeVar, TypedDict

T = TypeVar("T")
Foo = TypedDict("Foo", {"bar": T})
class Stack(Generic[T]): pass

a = Foo[str]
b = Foo[int]
reveal_type(a)  # N: Revealed type is "def (*, bar: builtins.str) -> TypedDict('__main__.Foo', {'bar': builtins.str})"
reveal_type(b)  # N: Revealed type is "def (*, bar: builtins.int) -> TypedDict('__main__.Foo', {'bar': builtins.int})"

[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testGenericTypedDictCallSyntax]
from typing import TypedDict, TypeVar

T = TypeVar("T")
TD = TypedDict("TD", {"key": int, "value": T})
reveal_type(TD)  # N: Revealed type is "def [T] (*, key: builtins.int, value: T`1) -> TypedDict('__main__.TD', {'key': builtins.int, 'value': T`1})"

tds: TD[str]
reveal_type(tds)  # N: Revealed type is "TypedDict('__main__.TD', {'key': builtins.int, 'value': builtins.str})"

tdi = TD(key=0, value=0)
reveal_type(tdi)  # N: Revealed type is "TypedDict('__main__.TD', {'key': builtins.int, 'value': builtins.int})"
TD[str](key=0, value=0)  # E: Incompatible types (expression has type "int", TypedDict item "value" has type "str")
TD[str]({"key": 0, "value": 0})  # E: Incompatible types (expression has type "int", TypedDict item "value" has type "str")
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictSelfItemNotAllowed]
from typing import Self, TypedDict, Optional

class TD(TypedDict):
    val: int
    next: Optional[Self]  # E: Self type cannot be used in TypedDict item type
TDC = TypedDict("TDC", {"val": int, "next": Optional[Self]})  # E: Self type cannot be used in TypedDict item type

[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testUnionOfEquivalentTypedDictsInferred]
from typing import TypedDict, Dict

D = TypedDict("D", {"foo": int}, total=False)

def f(d: Dict[str, D]) -> None:
    args = d["a"]
    args.update(d.get("b", {}))  # OK
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testUnionOfEquivalentTypedDictsDeclared]
from typing import TypedDict, Union

class A(TypedDict, total=False):
    name: str
class B(TypedDict, total=False):
    name: str

def foo(data: Union[A, B]) -> None: ...
foo({"name": "Robert"})  # OK
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testUnionOfEquivalentTypedDictsEmpty]
from typing import TypedDict, Union

class Foo(TypedDict, total=False):
    foo: str
class Bar(TypedDict, total=False):
    bar: str

def foo(body: Union[Foo, Bar] = {}) -> None:  # OK
    ...
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testUnionOfEquivalentTypedDictsDistinct]
from typing import TypedDict, Union, Literal

class A(TypedDict):
    type: Literal['a']
    value: bool
class B(TypedDict):
    type: Literal['b']
    value: str

Response = Union[A, B]
def method(message: Response) -> None: ...

method({'type': 'a', 'value': True})  # OK
method({'type': 'b', 'value': 'abc'})  # OK
method({'type': 'a', 'value': 'abc'})  # E: Type of TypedDict is ambiguous, none of ("A", "B") matches cleanly \
                                       # E: Argument 1 to "method" has incompatible type "Dict[str, str]"; expected "Union[A, B]"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testUnionOfEquivalentTypedDictsNested]
from typing import TypedDict, Union

class A(TypedDict, total=False):
    foo: C
class B(TypedDict, total=False):
    foo: D
class C(TypedDict, total=False):
    c: str
class D(TypedDict, total=False):
    d: str

def foo(data: Union[A, B]) -> None: ...
foo({"foo": {"c": "foo"}})  # OK
foo({"foo": {"e": "foo"}})  # E: Type of TypedDict is ambiguous, none of ("A", "B") matches cleanly \
                            # E: Argument 1 to "foo" has incompatible type "Dict[str, Dict[str, str]]"; expected "Union[A, B]"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictMissingEmptyKey]
from typing_extensions import TypedDict

class A(TypedDict):
    my_attr_1: str
    my_attr_2: int

d: A
d['']  # E: TypedDict "A" has no key ""
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictFlexibleUpdate]
from typing import TypedDict

A = TypedDict("A", {"foo": int, "bar": int})
B = TypedDict("B", {"foo": int})

a = A({"foo": 1, "bar": 2})
b = B({"foo": 2})
a.update({"foo": 2})
a.update(b)
a.update(a)
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictStrictUpdate]
# flags: --extra-checks
from typing import TypedDict

A = TypedDict("A", {"foo": int, "bar": int})
B = TypedDict("B", {"foo": int})

a = A({"foo": 1, "bar": 2})
b = B({"foo": 2})
a.update({"foo": 2})  # OK
a.update(b)  # E: Argument 1 to "update" of "TypedDict" has incompatible type "B"; expected "TypedDict({'foo': int, 'bar'?: int})"
a.update(a)  # OK
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictFlexibleUpdateUnion]
from typing import TypedDict, Union

A = TypedDict("A", {"foo": int, "bar": int})
B = TypedDict("B", {"foo": int})
C = TypedDict("C", {"bar": int})

a = A({"foo": 1, "bar": 2})
u: Union[B, C]
a.update(u)
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictFlexibleUpdateUnionExtra]
from typing import TypedDict, Union

A = TypedDict("A", {"foo": int, "bar": int})
B = TypedDict("B", {"foo": int, "extra": int})
C = TypedDict("C", {"bar": int, "extra": int})

a = A({"foo": 1, "bar": 2})
u: Union[B, C]
a.update(u)
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictFlexibleUpdateUnionStrict]
# flags: --extra-checks
from typing import TypedDict, Union, NotRequired

A = TypedDict("A", {"foo": int, "bar": int})
A1 = TypedDict("A1", {"foo": int, "bar": NotRequired[int]})
A2 = TypedDict("A2", {"foo": NotRequired[int], "bar": int})
B = TypedDict("B", {"foo": int})
C = TypedDict("C", {"bar": int})

a = A({"foo": 1, "bar": 2})
u: Union[B, C]
a.update(u)  # E: Argument 1 to "update" of "TypedDict" has incompatible type "Union[B, C]"; expected "Union[TypedDict({'foo': int, 'bar'?: int}), TypedDict({'foo'?: int, 'bar': int})]"
u2: Union[A1, A2]
a.update(u2)  # OK
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictUnpackSame]
# flags: --extra-checks
from typing import TypedDict

class Foo(TypedDict):
    a: int
    b: int

foo1: Foo = {"a": 1, "b": 1}
foo2: Foo = {**foo1, "b": 2}
foo3 = Foo(**foo1, b=2)
foo4 = Foo({**foo1, "b": 2})
foo5 = Foo(dict(**foo1, b=2))
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictUnpackCompatible]
# flags: --extra-checks
from typing import TypedDict

class Foo(TypedDict):
    a: int

class Bar(TypedDict):
    a: int
    b: int

foo: Foo = {"a": 1}
bar: Bar = {**foo, "b": 2}
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictUnpackIncompatible]
from typing import TypedDict

class Foo(TypedDict):
    a: int
    b: str

class Bar(TypedDict):
    a: int
    b: int

foo: Foo = {"a": 1, "b": "a"}
bar1: Bar = {**foo, "b": 2}  # Incompatible item is overridden
bar2: Bar = {**foo, "a": 2}  # E: Incompatible types (expression has type "str", TypedDict item "b" has type "int")
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictUnpackNotRequiredKeyIncompatible]
from typing import TypedDict, NotRequired

class Foo(TypedDict):
    a: NotRequired[str]

class Bar(TypedDict):
    a: NotRequired[int]

foo: Foo = {}
bar: Bar = {**foo}  # E: Incompatible types (expression has type "str", TypedDict item "a" has type "int")
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]


[case testTypedDictUnpackMissingOrExtraKey]
from typing import TypedDict

class Foo(TypedDict):
    a: int

class Bar(TypedDict):
    a: int
    b: int

foo1: Foo = {"a": 1}
bar1: Bar = {"a": 1, "b": 1}
foo2: Foo = {**bar1}  # E: Extra key "b" for TypedDict "Foo"
bar2: Bar = {**foo1}  # E: Missing key "b" for TypedDict "Bar"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictUnpackNotRequiredKeyExtra]
from typing import TypedDict, NotRequired

class Foo(TypedDict):
    a: int

class Bar(TypedDict):
    a: int
    b: NotRequired[int]

foo1: Foo = {"a": 1}
bar1: Bar = {"a": 1}
foo2: Foo = {**bar1}  # E: Extra key "b" for TypedDict "Foo"
bar2: Bar = {**foo1}
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictUnpackRequiredKeyMissing]
from typing import TypedDict, NotRequired

class Foo(TypedDict):
    a: NotRequired[int]

class Bar(TypedDict):
    a: int

foo: Foo = {"a": 1}
bar: Bar = {**foo}  # E: Missing key "a" for TypedDict "Bar"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictUnpackMultiple]
# flags: --extra-checks
from typing import TypedDict

class Foo(TypedDict):
    a: int

class Bar(TypedDict):
    b: int

class Baz(TypedDict):
    a: int
    b: int
    c: int

foo: Foo = {"a": 1}
bar: Bar = {"b": 1}
baz: Baz = {**foo, **bar, "c": 1}
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictUnpackNested]
from typing import TypedDict

class Foo(TypedDict):
    a: int
    b: int

class Bar(TypedDict):
    c: Foo
    d: int

foo: Foo = {"a": 1, "b": 1}
bar: Bar = {"c": foo, "d": 1}
bar2: Bar = {**bar, "c": {**bar["c"], "b": 2}, "d": 2}
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictUnpackNestedError]
from typing import TypedDict

class Foo(TypedDict):
    a: int
    b: int

class Bar(TypedDict):
    c: Foo
    d: int

foo: Foo = {"a": 1, "b": 1}
bar: Bar = {"c": foo, "d": 1}
bar2: Bar = {**bar, "c": {**bar["c"], "b": "wrong"}, "d": 2}  # E: Incompatible types (expression has type "str", TypedDict item "b" has type "int")
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictUnpackOverrideRequired]
from typing import TypedDict

Details = TypedDict('Details', {'first_name': str, 'last_name': str})
DetailsSubset = TypedDict('DetailsSubset', {'first_name': str, 'last_name': str}, total=False)
defaults: Details = {'first_name': 'John', 'last_name': 'Luther'}

def generate(data: DetailsSubset) -> Details:
    return {**defaults, **data}  # OK
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictUnpackUntypedDict]
from typing import Any, Dict, TypedDict

class Bar(TypedDict):
    pass

foo: Dict[str, Any] = {}
bar: Bar = {**foo}  # E: Unsupported type "Dict[str, Any]" for ** expansion in TypedDict
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictUnpackIntoUnion]
from typing import TypedDict, Union

class Foo(TypedDict):
    a: int

class Bar(TypedDict):
    b: int

foo: Foo = {'a': 1}
foo_or_bar: Union[Foo, Bar] = {**foo}
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictUnpackFromUnion]
from typing import TypedDict, Union

class Foo(TypedDict):
    a: int
    b: int

class Bar(TypedDict):
    b: int

foo_or_bar: Union[Foo, Bar] = {'b': 1}
foo: Bar = {**foo_or_bar}  # E: Extra key "a" for TypedDict "Bar"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictUnpackUnionRequiredMissing]
from typing import TypedDict, NotRequired, Union

class Foo(TypedDict):
    a: int
    b: int

class Bar(TypedDict):
    a: int
    b: NotRequired[int]

foo_or_bar: Union[Foo, Bar] = {"a": 1}
foo: Foo = {**foo_or_bar}  # E: Missing key "b" for TypedDict "Foo"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictUnpackInference]
from typing import TypedDict, Generic, TypeVar

class Foo(TypedDict):
    a: int
    b: str

T = TypeVar("T")
class TD(TypedDict, Generic[T]):
    a: T
    b: str

foo: Foo
bar = TD(**foo)
reveal_type(bar)  # N: Revealed type is "TypedDict('__main__.TD', {'a': builtins.int, 'b': builtins.str})"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictUnpackStrictMode]
# flags: --extra-checks
from typing import TypedDict, NotRequired

class Foo(TypedDict):
    a: int

class Bar(TypedDict):
    a: int
    b: NotRequired[int]

foo: Foo
bar: Bar = {**foo}  # E: Non-required key "b" not explicitly found in any ** item
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictUnpackAny]
from typing import Any, TypedDict, NotRequired, Dict, Union

class Foo(TypedDict):
    a: int
    b: NotRequired[int]

x: Any
y: Dict[Any, Any]
z: Union[Any, Dict[Any, Any]]
t1: Foo = {**x}  # E: Missing key "a" for TypedDict "Foo"
t2: Foo = {**y}  # E: Missing key "a" for TypedDict "Foo"
t3: Foo = {**z}  # E: Missing key "a" for TypedDict "Foo"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictUnpackError]
from typing import TypedDict

class Foo(TypedDict):
    a: int

def foo(x: int) -> Foo: ...

f: Foo = {**foo("no")}  # E: Argument 1 to "foo" has incompatible type "str"; expected "int"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]


[case testTypedDictWith__or__method]
from typing import Dict, TypedDict

class Foo(TypedDict):
    key: int

foo1: Foo = {'key': 1}
foo2: Foo = {'key': 2}

reveal_type(foo1 | foo2)  # N: Revealed type is "TypedDict('__main__.Foo', {'key': builtins.int})"
reveal_type(foo1 | {'key': 1})  # N: Revealed type is "TypedDict('__main__.Foo', {'key': builtins.int})"
reveal_type(foo1 | {'key': 'a'})  # N: Revealed type is "builtins.dict[builtins.str, builtins.object]"
reveal_type(foo1 | {})  # N: Revealed type is "TypedDict('__main__.Foo', {'key': builtins.int})"

d1: Dict[str, int]
d2: Dict[int, str]

reveal_type(foo1 | d1)  # N: Revealed type is "builtins.dict[builtins.str, builtins.object]"
foo1 | d2  # E: Unsupported operand types for | ("Foo" and "Dict[int, str]")


class Bar(TypedDict):
    key: int
    value: str

bar: Bar
reveal_type(bar | {})  # N: Revealed type is "TypedDict('__main__.Bar', {'key': builtins.int, 'value': builtins.str})"
reveal_type(bar | {'key': 1, 'value': 'v'})  # N: Revealed type is "TypedDict('__main__.Bar', {'key': builtins.int, 'value': builtins.str})"
reveal_type(bar | {'key': 1})  # N: Revealed type is "TypedDict('__main__.Bar', {'key': builtins.int, 'value': builtins.str})"
reveal_type(bar | {'value': 'v'})  # N: Revealed type is "TypedDict('__main__.Bar', {'key': builtins.int, 'value': builtins.str})"
reveal_type(bar | {'key': 'a'})  # N: Revealed type is "builtins.dict[builtins.str, builtins.object]"
reveal_type(bar | {'value': 1})  # N: Revealed type is "builtins.dict[builtins.str, builtins.object]"
reveal_type(bar | {'key': 'a', 'value': 1})  # N: Revealed type is "builtins.dict[builtins.str, builtins.object]"

reveal_type(bar | foo1)  # N: Revealed type is "TypedDict('__main__.Bar', {'key': builtins.int, 'value': builtins.str})"
reveal_type(bar | d1)  # N: Revealed type is "builtins.dict[builtins.str, builtins.object]"
bar | d2  # E: Unsupported operand types for | ("Bar" and "Dict[int, str]")
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict-iror.pyi]

[case testTypedDictWith__or__method_error]
from typing import TypedDict

class Foo(TypedDict):
    key: int

foo: Foo = {'key': 1}
foo | 1

class SubDict(dict): ...
foo | SubDict()
[out]
main:7: error: No overload variant of "__or__" of "TypedDict" matches argument type "int"
main:7: note: Possible overload variants:
main:7: note:     def __or__(self, TypedDict({'key'?: int}), /) -> Foo
main:7: note:     def __or__(self, Dict[str, Any], /) -> Dict[str, object]
main:10: error: No overload variant of "__ror__" of "dict" matches argument type "Foo"
main:10: note: Possible overload variants:
main:10: note:     def __ror__(self, Dict[Any, Any], /) -> Dict[Any, Any]
main:10: note:     def [T, T2] __ror__(self, Dict[T, T2], /) -> Dict[Union[Any, T], Union[Any, T2]]
[builtins fixtures/dict-full.pyi]
[typing fixtures/typing-typeddict-iror.pyi]

[case testTypedDictWith__ror__method]
from typing import Dict, TypedDict

class Foo(TypedDict):
    key: int

foo: Foo = {'key': 1}

reveal_type({'key': 1} | foo)  # N: Revealed type is "TypedDict('__main__.Foo', {'key': builtins.int})"
reveal_type({'key': 'a'} | foo)  # N: Revealed type is "builtins.dict[builtins.str, builtins.object]"
reveal_type({} | foo)  # N: Revealed type is "TypedDict('__main__.Foo', {'key': builtins.int})"
{1: 'a'} | foo  # E: Dict entry 0 has incompatible type "int": "str"; expected "str": "Any"

d1: Dict[str, int]
d2: Dict[int, str]

reveal_type(d1 | foo)  # N: Revealed type is "builtins.dict[builtins.str, builtins.object]"
d2 | foo  # E: Unsupported operand types for | ("Dict[int, str]" and "Foo")
1 | foo  # E: Unsupported left operand type for | ("int")


class Bar(TypedDict):
    key: int
    value: str

bar: Bar
reveal_type({} | bar)  # N: Revealed type is "TypedDict('__main__.Bar', {'key': builtins.int, 'value': builtins.str})"
reveal_type({'key': 1, 'value': 'v'} | bar)  # N: Revealed type is "TypedDict('__main__.Bar', {'key': builtins.int, 'value': builtins.str})"
reveal_type({'key': 1} | bar)  # N: Revealed type is "TypedDict('__main__.Bar', {'key': builtins.int, 'value': builtins.str})"
reveal_type({'value': 'v'} | bar)  # N: Revealed type is "TypedDict('__main__.Bar', {'key': builtins.int, 'value': builtins.str})"
reveal_type({'key': 'a'} | bar)  # N: Revealed type is "builtins.dict[builtins.str, builtins.object]"
reveal_type({'value': 1} | bar)  # N: Revealed type is "builtins.dict[builtins.str, builtins.object]"
reveal_type({'key': 'a', 'value': 1} | bar)  # N: Revealed type is "builtins.dict[builtins.str, builtins.object]"

reveal_type(d1 | bar)  # N: Revealed type is "builtins.dict[builtins.str, builtins.object]"
d2 | bar  # E: Unsupported operand types for | ("Dict[int, str]" and "Bar")
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict-iror.pyi]

[case testTypedDictWith__ior__method]
from typing import Dict, TypedDict

class Foo(TypedDict):
    key: int

foo: Foo = {'key': 1}
foo |= {'key': 2}

foo |= {}
foo |= {'key': 'a', 'b': 'a'}  # E: Expected TypedDict key "key" but found keys ("key", "b")  \
                               # E: Incompatible types (expression has type "str", TypedDict item "key" has type "int")
foo |= {'b': 2}  # E: Unexpected TypedDict key "b"

d1: Dict[str, int]
d2: Dict[int, str]

foo |= d1  # E: Argument 1 to "__ior__" of "TypedDict" has incompatible type "Dict[str, int]"; expected "TypedDict({'key'?: int})"
foo |= d2  # E: Argument 1 to "__ior__" of "TypedDict" has incompatible type "Dict[int, str]"; expected "TypedDict({'key'?: int})"


class Bar(TypedDict):
    key: int
    value: str

bar: Bar
bar |= {}
bar |= {'key': 1, 'value': 'a'}
bar |= {'key': 'a', 'value': 'a', 'b': 'a'}  # E: Expected TypedDict keys ("key", "value") but found keys ("key", "value", "b") \
                                             # E: Incompatible types (expression has type "str", TypedDict item "key" has type "int")

bar |= foo
bar |= d1  # E: Argument 1 to "__ior__" of "TypedDict" has incompatible type "Dict[str, int]"; expected "TypedDict({'key'?: int, 'value'?: str})"
bar |= d2  # E: Argument 1 to "__ior__" of "TypedDict" has incompatible type "Dict[int, str]"; expected "TypedDict({'key'?: int, 'value'?: str})"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict-iror.pyi]

[case testGenericTypedDictStrictOptionalExtending]
from typing import Generic, TypeVar, TypedDict, Optional

T = TypeVar("T")
class Foo(TypedDict, Generic[T], total=False):
    a: Optional[str]
    g: Optional[T]

class Bar(Foo[T], total=False):
    other: str

b: Bar[int]
reveal_type(b["a"])  # N: Revealed type is "Union[builtins.str, None]"
reveal_type(b["g"])  # N: Revealed type is "Union[builtins.int, None]"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testNoCrashOnUnImportedAnyNotRequired]
# flags: --disallow-any-unimported
from typing import NotRequired, Required, TypedDict
from thismoduledoesntexist import T  # type: ignore[import]

B = TypedDict("B", {  # E: Type of a TypedDict key becomes "Any" due to an unfollowed import
    "T1": NotRequired[T],
    "T2": Required[T],
})
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictWithClassLevelKeywords]
from typing import TypedDict, Generic, TypeVar

T = TypeVar('T')

class Meta(type): ...

class WithMetaKeyword(TypedDict, metaclass=Meta):  # E: Unexpected keyword argument "metaclass" for "__init_subclass__" of "TypedDict"
    ...

class GenericWithMetaKeyword(TypedDict, Generic[T], metaclass=Meta):  # E: Unexpected keyword argument "metaclass" for "__init_subclass__" of "TypedDict"
    ...

# We still don't allow this, because the implementation is much easier
# and it does not make any practical sense to do it:
class WithTypeMeta(TypedDict, metaclass=type):  # E: Unexpected keyword argument "metaclass" for "__init_subclass__" of "TypedDict"
    ...

class OtherKeywords(TypedDict, a=1, b=2, c=3, total=True):  # E: Unexpected keyword argument "a" for "__init_subclass__" of "TypedDict" \
                                                            # E: Unexpected keyword argument "b" for "__init_subclass__" of "TypedDict" \
                                                            # E: Unexpected keyword argument "c" for "__init_subclass__" of "TypedDict"
    ...

class TotalInTheMiddle(TypedDict, a=1, total=True, b=2, c=3):  # E: Unexpected keyword argument "a" for "__init_subclass__" of "TypedDict" \
                                                            # E: Unexpected keyword argument "b" for "__init_subclass__" of "TypedDict" \
                                                            # E: Unexpected keyword argument "c" for "__init_subclass__" of "TypedDict"
    ...
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testCanCreateClassWithFunctionBasedTypedDictBase]
from typing import TypedDict

class Params(TypedDict("Params", {'x': int})):
    pass

p: Params = {'x': 2}
reveal_type(p) # N: Revealed type is "TypedDict('__main__.Params', {'x': builtins.int})"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testInitTypedDictFromType]
from typing import TypedDict, Type
from typing_extensions import Required

class Point(TypedDict, total=False):
    x: Required[int]
    y: int

def func(cls: Type[Point]) -> None:
    reveal_type(cls)  # N: Revealed type is "Type[TypedDict('__main__.Point', {'x': builtins.int, 'y'?: builtins.int})]"
    cls(x=1, y=2)
    cls(1, 2)  # E: Too many positional arguments
    cls(x=1)
    cls(y=2)  # E: Missing named argument "x"
    cls(x=1, y=2, error="")  # E: Unexpected keyword argument "error"
[typing fixtures/typing-full.pyi]
[builtins fixtures/tuple.pyi]

[case testInitTypedDictFromTypeGeneric]
from typing import Generic, TypedDict, Type, TypeVar
from typing_extensions import Required

class Point(TypedDict, total=False):
    x: Required[int]
    y: int

T = TypeVar("T", bound=Point)

class A(Generic[T]):
    def __init__(self, a: Type[T]) -> None:
        self.a = a

    def func(self) -> T:
        reveal_type(self.a)  # N: Revealed type is "Type[T`1]"
        self.a(x=1, y=2)
        self.a(y=2)  # E: Missing named argument "x"
        return self.a(x=1)
[typing fixtures/typing-full.pyi]
[builtins fixtures/tuple.pyi]

[case testNameUndefinedErrorDoesNotLoseUnpackedKWArgsInformation]
from typing import overload
from typing_extensions import TypedDict, Unpack

class TD(TypedDict, total=False):
    x: int
    y: str

@overload
def f(self, *, x: int) -> None: ...
@overload
def f(self, *, y: str) -> None: ...
def f(self, **kwargs: Unpack[TD]) -> None:
    z  # E: Name "z" is not defined

@overload
def g(self, *, x: float) -> None: ...
@overload
def g(self, *, y: str) -> None: ...
def g(self, **kwargs: Unpack[TD]) -> None:  # E: Overloaded function implementation does not accept all possible arguments of signature 1
    z  # E: Name "z" is not defined

class A:
    def f(self, *, x: int) -> None: ...
    def g(self, *, x: float) -> None: ...
class B(A):
    def f(self, **kwargs: Unpack[TD]) -> None:
        z  # E: Name "z" is not defined
    def g(self, **kwargs: Unpack[TD]) -> None:  # E: Signature of "g" incompatible with supertype "A" \
                                                # N:      Superclass: \
                                                # N:          def g(self, *, x: float) -> None \
                                                # N:      Subclass: \
                                                # N:          def g(*, x: int = ..., y: str = ...) -> None
        z  # E: Name "z" is not defined
reveal_type(B.f)  # N: Revealed type is "def (self: __main__.B, **kwargs: Unpack[TypedDict('__main__.TD', {'x'?: builtins.int, 'y'?: builtins.str})])"
B().f(x=1.0)  # E: Argument "x" to "f" of "B" has incompatible type "float"; expected "int"
[builtins fixtures/primitives.pyi]

[case testTypedDictUnpackWithParamSpecInference]
from typing import TypeVar, ParamSpec, Callable
from typing_extensions import TypedDict, Unpack

P = ParamSpec("P")
R = TypeVar("R")

def run(func: Callable[P, R], *args: P.args, **kwargs: P.kwargs) -> R: ...

class Params(TypedDict):
    temperature: float

def test(temperature: int) -> None: ...
def test2(temperature: float, other: str) -> None: ...

class Test:
    def f(self, c: Callable[..., None], **params: Unpack[Params]) -> None:
        run(c, **params)
    def g(self, **params: Unpack[Params]) -> None:
        run(test, **params)  # E: Argument "temperature" to "run" has incompatible type "float"; expected "int"
    def h(self, **params: Unpack[Params]) -> None:
        run(test2, other="yes", **params)
        run(test2, other=0, **params)  # E: Argument "other" to "run" has incompatible type "int"; expected "str"
[builtins fixtures/tuple.pyi]

[case testTypedDictUnpackSingleWithSubtypingNoCrash]
from typing import Callable
from typing_extensions import TypedDict, Unpack

class Kwargs(TypedDict):
    name: str

def f(**kwargs: Unpack[Kwargs]) -> None:
    pass

class C:
    d: Callable[[Unpack[Kwargs]], None]

# TODO: it is an old question whether we should allow this, for now simply don't crash.
class D(C):
    d = f
[builtins fixtures/tuple.pyi]

[case testTypedDictInlineNoOldStyleAlias]
# flags: --enable-incomplete-feature=InlineTypedDict
X = {"int": int, "str": str}
reveal_type(X)  # N: Revealed type is "builtins.dict[builtins.str, def () -> builtins.object]"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictInlineYesMidStyleAlias]
# flags: --enable-incomplete-feature=InlineTypedDict
from typing_extensions import TypeAlias
X: TypeAlias = {"int": int, "str": str}
x: X
reveal_type(x)  # N:  # N: Revealed type is "TypedDict({'int': builtins.int, 'str': builtins.str})"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictInlineNoEmpty]
# flags: --enable-incomplete-feature=InlineTypedDict
x: {}  # E: Invalid type comment or annotation
reveal_type(x)  # N: Revealed type is "Any"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictInlineNotRequired]
# flags: --enable-incomplete-feature=InlineTypedDict
from typing import NotRequired

x: {"one": int, "other": NotRequired[int]}
x = {"one": 1}  # OK
y: {"one": int, "other": int}
y = {"one": 1}  # E: Expected TypedDict keys ("one", "other") but found only key "one"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictInlineReadOnly]
# flags: --enable-incomplete-feature=InlineTypedDict
from typing import ReadOnly

x: {"one": int, "other": ReadOnly[int]}
x["one"] = 1  # ok
x["other"] = 1  # E: ReadOnly TypedDict key "other" TypedDict is mutated
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictInlineNestedSchema]
# flags: --enable-incomplete-feature=InlineTypedDict
def nested() -> {"one": str, "other": {"a": int, "b": int}}:
    if bool():
        return {"one": "yes", "other": {"a": 1, "b": 2}}  # OK
    else:
        return {"one": "no", "other": {"a": 1, "b": "2"}}  # E: Incompatible types (expression has type "str", TypedDict item "b" has type "int")
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictInlineMergeAnother]
# flags: --enable-incomplete-feature=InlineTypedDict
from typing import TypeVar
from typing_extensions import TypeAlias

T = TypeVar("T")
X: TypeAlias = {"item": T}
x: {"a": int, **X[str], "b": int}
reveal_type(x)  # N: Revealed type is "TypedDict({'a': builtins.int, 'b': builtins.int, 'item': builtins.str})"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-full.pyi]


# ReadOnly
# See: https://peps.python.org/pep-0705

[case testTypedDictReadOnly]
# flags: --show-error-codes
from typing import ReadOnly, TypedDict

class TP(TypedDict):
    one: int
    other: ReadOnly[str]

x: TP
reveal_type(x["one"])   # N: Revealed type is "builtins.int"
reveal_type(x["other"]) # N: Revealed type is "builtins.str"
x["one"] = 1  # ok
x["other"] = "a"  # E: ReadOnly TypedDict key "other" TypedDict is mutated  [typeddict-readonly-mutated]
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictReadOnlyCreation]
from typing import ReadOnly, TypedDict

class TD(TypedDict):
    x: ReadOnly[int]
    y: int

# Ok:
x = TD({"x": 1, "y": 2})
y = TD(x=1, y=2)
z: TD = {"x": 1, "y": 2}

# Error:
x2 = TD({"x": "a", "y": 2})  # E: Incompatible types (expression has type "str", TypedDict item "x" has type "int")
y2 = TD(x="a", y=2)          # E: Incompatible types (expression has type "str", TypedDict item "x" has type "int")
z2: TD = {"x": "a", "y": 2}  # E: Incompatible types (expression has type "str", TypedDict item "x" has type "int")
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictReadOnlyDel]
from typing import ReadOnly, TypedDict, NotRequired

class TP(TypedDict):
    required_key: ReadOnly[str]
    optional_key: ReadOnly[NotRequired[str]]

x: TP
del x["required_key"]  # E: Key "required_key" of TypedDict "TP" cannot be deleted
del x["optional_key"]  # E: Key "optional_key" of TypedDict "TP" cannot be deleted
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictReadOnlyMutateMethods]
from typing import ReadOnly, TypedDict

class TP(TypedDict):
    key: ReadOnly[str]
    other: ReadOnly[int]
    mutable: bool

x: TP
reveal_type(x.pop("key"))  # N: Revealed type is "builtins.str" \
                           # E: Key "key" of TypedDict "TP" cannot be deleted


x.update({"key": "abc", "other": 1, "mutable": True})  # E: ReadOnly TypedDict keys ("key", "other") TypedDict are mutated
x.setdefault("key", "abc")  # E: ReadOnly TypedDict key "key" TypedDict is mutated
x.setdefault("other", 1)  # E: ReadOnly TypedDict key "other" TypedDict is mutated
x.setdefault("mutable", False)  # ok
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictFromTypingExtensionsReadOnlyMutateMethods]
from typing_extensions import ReadOnly, TypedDict

class TP(TypedDict):
    key: ReadOnly[str]

x: TP
x.update({"key": "abc"})  # E: ReadOnly TypedDict key "key" TypedDict is mutated
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictFromMypyExtensionsReadOnlyMutateMethods]
from typing import TypedDict
from typing_extensions import ReadOnly

class TP(TypedDict):
    key: ReadOnly[str]

x: TP
x.update({"key": "abc"})  # E: ReadOnly TypedDict key "key" TypedDict is mutated
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictReadOnlyMutate__ior__Statements]
from typing_extensions import ReadOnly, TypedDict

class TP(TypedDict):
    key: ReadOnly[str]
    other: ReadOnly[int]
    mutable: bool

x: TP
x |= {"mutable": True}  # ok
x |= {"key": "a"}  # E: ReadOnly TypedDict key "key" TypedDict is mutated
x |= {"key": "a", "other": 1, "mutable": True}  # E: ReadOnly TypedDict keys ("key", "other") TypedDict are mutated
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict-iror.pyi]

[case testTypedDictReadOnlyMutate__or__Statements]
from typing_extensions import ReadOnly, TypedDict

class TP(TypedDict):
    key: ReadOnly[str]
    other: ReadOnly[int]
    mutable: bool

x: TP
# These are new objects, not mutation:
x = x | {"mutable": True}
x = x | {"key": "a"}
x = x | {"key": "a", "other": 1, "mutable": True}
y1 = x | {"mutable": True}
y2 = x | {"key": "a"}
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict-iror.pyi]

[case testTypedDictReadOnlyMutateWithOtherDicts]
from typing import ReadOnly, TypedDict, Dict

class TP(TypedDict):
    key: ReadOnly[str]
    mutable: bool

class Mutable(TypedDict):
    mutable: bool

class Regular(TypedDict):
    key: str

m: Mutable
r: Regular
d: Dict[str, object]

# Creating new objects is ok:
tp: TP = {**r, **m}
tp1: TP = {**tp, **m}
tp2: TP = {**r, **m}
tp3: TP = {**tp, **r}
tp4: TP = {**tp, **d}  # E: Unsupported type "Dict[str, object]" for ** expansion in TypedDict
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictGenericReadOnly]
from typing import ReadOnly, TypedDict, TypeVar, Generic

T = TypeVar('T')

class TP(TypedDict, Generic[T]):
    key: ReadOnly[T]

x: TP[int]
reveal_type(x["key"])   # N: Revealed type is "builtins.int"
x["key"] = 1  # E: ReadOnly TypedDict key "key" TypedDict is mutated
x["key"] = "a"  # E: ReadOnly TypedDict key "key" TypedDict is mutated \
                # E: Value of "key" has incompatible type "str"; expected "int"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictReadOnlyOtherTypedDict]
from typing import ReadOnly, TypedDict

class First(TypedDict):
    field: int

class TP(TypedDict):
    key: ReadOnly[First]

x: TP
reveal_type(x["key"]["field"])   # N: Revealed type is "builtins.int"
x["key"]["field"] = 1  # ok
x["key"] = {"field": 2}  # E: ReadOnly TypedDict key "key" TypedDict is mutated
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictReadOnlyInheritance]
from typing import ReadOnly, TypedDict

class Base(TypedDict):
    a: ReadOnly[str]

class Child(Base):
    b: ReadOnly[int]

base: Base
reveal_type(base["a"])   # N: Revealed type is "builtins.str"
base["a"] = "x"  # E: ReadOnly TypedDict key "a" TypedDict is mutated
base["b"]  # E: TypedDict "Base" has no key "b"

child: Child
reveal_type(child["a"])   # N: Revealed type is "builtins.str"
reveal_type(child["b"])   # N: Revealed type is "builtins.int"
child["a"] = "x"  # E: ReadOnly TypedDict key "a" TypedDict is mutated
child["b"] = 1  # E: ReadOnly TypedDict key "b" TypedDict is mutated
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictReadOnlySubtyping]
from typing import ReadOnly, TypedDict

class A(TypedDict):
    key: ReadOnly[str]

class B(TypedDict):
    key: str

a: A
b: B

def accepts_A(d: A): ...
def accepts_B(d: B): ...

accepts_A(a)
accepts_A(b)
accepts_B(a)  # E: Argument 1 to "accepts_B" has incompatible type "A"; expected "B"
accepts_B(b)
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictRequiredConsistentWithNotRequiredReadOnly]
from typing import NotRequired, ReadOnly, Required, TypedDict

class A(TypedDict):
    x: NotRequired[ReadOnly[str]]

class B(TypedDict):
    x: Required[str]

def f(b: B):
    a: A = b  # ok
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictReadOnlyCall]
from typing import ReadOnly, TypedDict

TP = TypedDict("TP", {"one": int, "other": ReadOnly[str]})

x: TP
reveal_type(x["one"])   # N: Revealed type is "builtins.int"
reveal_type(x["other"]) # N: Revealed type is "builtins.str"
x["one"] = 1  # ok
x["other"] = "a"  # E: ReadOnly TypedDict key "other" TypedDict is mutated
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictReadOnlyABCSubtypes]
from typing import ReadOnly, TypedDict, Mapping, Dict, MutableMapping

class TP(TypedDict):
    one: int
    other: ReadOnly[int]

def accepts_mapping(m: Mapping[str, object]): ...
def accepts_mutable_mapping(mm: MutableMapping[str, object]): ...
def accepts_dict(d: Dict[str, object]): ...

x: TP
accepts_mapping(x)
accepts_mutable_mapping(x)  # E: Argument 1 to "accepts_mutable_mapping" has incompatible type "TP"; expected "MutableMapping[str, object]"
accepts_dict(x)  # E: Argument 1 to "accepts_dict" has incompatible type "TP"; expected "Dict[str, object]"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictReadOnlyAndNotRequired]
from typing import ReadOnly, TypedDict, NotRequired

class TP(TypedDict):
    one: ReadOnly[NotRequired[int]]
    two: NotRequired[ReadOnly[str]]

x: TP
reveal_type(x)  # N: Revealed type is "TypedDict('__main__.TP', {'one'?=: builtins.int, 'two'?=: builtins.str})"
reveal_type(x.get("one"))  # N: Revealed type is "Union[builtins.int, None]"
reveal_type(x.get("two"))  # N: Revealed type is "Union[builtins.str, None]"
x["one"] = 1  # E: ReadOnly TypedDict key "one" TypedDict is mutated
x["two"] = "a"  # E: ReadOnly TypedDict key "two" TypedDict is mutated
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testMeetOfTypedDictsWithReadOnly]
from typing import TypeVar, Callable, TypedDict, ReadOnly
XY = TypedDict('XY', {'x': ReadOnly[int], 'y': int})
YZ = TypedDict('YZ', {'y': int, 'z': ReadOnly[int]})
T = TypeVar('T')
def f(x: Callable[[T, T], None]) -> T: pass
def g(x: XY, y: YZ) -> None: pass
reveal_type(f(g))  # N: Revealed type is "TypedDict({'x'=: builtins.int, 'y': builtins.int, 'z'=: builtins.int})"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictReadOnlyUnpack]
from typing_extensions import TypedDict, Unpack, ReadOnly

class TD(TypedDict):
    x: ReadOnly[int]
    y: str

def func(**kwargs: Unpack[TD]):
    kwargs["x"] = 1  # E: ReadOnly TypedDict key "x" TypedDict is mutated
    kwargs["y" ] = "a"
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testIncorrectTypedDictSpecialFormsUsage]
from typing import ReadOnly, TypedDict, NotRequired, Required

x: ReadOnly[int]     # E: ReadOnly[] can be only used in a TypedDict definition
y: Required[int]     # E: Required[] can be only used in a TypedDict definition
z: NotRequired[int]  # E: NotRequired[] can be only used in a TypedDict definition

class TP(TypedDict):
    a: ReadOnly[ReadOnly[int]]              # E: "ReadOnly[]" type cannot be nested
    b: ReadOnly[NotRequired[ReadOnly[str]]] # E: "ReadOnly[]" type cannot be nested
    c: NotRequired[Required[int]]           # E: "Required[]" type cannot be nested
    d: Required[NotRequired[int]]           # E: "NotRequired[]" type cannot be nested
    e: Required[ReadOnly[NotRequired[int]]] # E: "NotRequired[]" type cannot be nested
    f: ReadOnly[ReadOnly[ReadOnly[int]]]    # E: "ReadOnly[]" type cannot be nested
    g: Required[Required[int]]              # E: "Required[]" type cannot be nested
    h: NotRequired[NotRequired[int]]        # E: "NotRequired[]" type cannot be nested

    j: NotRequired[ReadOnly[Required[ReadOnly[int]]]]  # E: "Required[]" type cannot be nested \
                                                       # E: "ReadOnly[]" type cannot be nested

    k: ReadOnly  # E: "ReadOnly[]" must have exactly one type argument
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictAnnotatedWithSpecialForms]
from typing import NotRequired, ReadOnly, Required, TypedDict
from typing_extensions import Annotated

class A(TypedDict):
    a: Annotated[NotRequired[ReadOnly[int]], ""]  # ok
    b: NotRequired[ReadOnly[Annotated[int, ""]]]  # ok
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictReadOnlyCovariant]
from typing import ReadOnly, TypedDict, Union

class A(TypedDict):
    a: ReadOnly[Union[int, str]]

class A2(TypedDict):
    a: ReadOnly[int]

class B(TypedDict):
    a: int

class B2(TypedDict):
    a: Union[int, str]

class B3(TypedDict):
    a: int

def fa(a: A) -> None: ...
def fa2(a: A2) -> None: ...

b: B = {"a": 1}
fa(b)
fa2(b)
b2: B2 = {"a": 1}
fa(b2)
fa2(b2)  # E: Argument 1 to "fa2" has incompatible type "B2"; expected "A2"

class C(TypedDict):
    a: ReadOnly[Union[int, str]]
    b: Union[str, bytes]

class D(TypedDict):
    a: int
    b: str

d: D = {"a": 1, "b": "x"}
c: C = d  # E: Incompatible types in assignment (expression has type "D", variable has type "C")
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]


[case testTypedDictFinalAndClassVar]
from typing import TypedDict, Final, ClassVar

class My(TypedDict):
    a: Final      # E: Final[...] can't be used inside a TypedDict
    b: Final[int] # E: Final[...] can't be used inside a TypedDict
    c: ClassVar       # E: ClassVar[...] can't be used inside a TypedDict
    d: ClassVar[int]  # E: ClassVar[...] can't be used inside a TypedDict

Func = TypedDict('Func', {
    'a': Final,         # E: Final[...] can't be used inside a TypedDict
    'b': Final[int],    # E: Final[...] can't be used inside a TypedDict
    'c': ClassVar,      # E: ClassVar[...] can't be used inside a TypedDict
    'd': ClassVar[int], # E: ClassVar[...] can't be used inside a TypedDict
})
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testTypedDictNestedInClassAndInherited]
from typing_extensions import TypedDict

class Base:
    class Params(TypedDict):
        name: str

class Derived(Base):
    pass

class DerivedOverride(Base):
    class Params(Base.Params):
        pass

Base.Params(name="Robert")
Derived.Params(name="Robert")
DerivedOverride.Params(name="Robert")
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]
