[case testUnannotatedFunction]
# flags: --disallow-untyped-defs
def f(x): pass
[out]
main:2: error: Function is missing a type annotation

[case testUnannotatedArgument]
# flags: --disallow-untyped-defs
def f(x) -> int: pass
[out]
main:2: error: Function is missing a type annotation for one or more arguments

[case testNoArgumentFunction]
# flags: --disallow-untyped-defs
def f() -> int: pass
[out]

[case testUnannotatedReturn]
# flags: --disallow-untyped-defs
def f(x: int): pass
[out]
main:2: error: Function is missing a return type annotation

[case testUnannotatedReturnWithFastParser]
# flags: --disallow-untyped-defs
def f(x: int): pass
[out]
main:2: error: Function is missing a return type annotation

[case testLambda]
# flags: --disallow-untyped-defs
lambda x: x
[out]

[case testUntypedDef]
# flags: --disallow-untyped-defs
def f():
    1 + "str"
[out]
main:2: error: Function is missing a return type annotation
main:2: note: Use "-> None" if function does not return a value

[case testUnannotatedReturnWithOnlySelfArgument]
# flags: --disallow-untyped-defs
def f(self): pass
[out]
main:2: error: Function is missing a return type annotation
main:2: note: Use "-> None" if function does not return a value

[case testUnannotatedReturnWithNontrivialReturn]
# flags: --disallow-untyped-defs
def f(): return 1
[out]
main:2: error: Function is missing a return type annotation

[case testUntypedAsyncDef]
# flags: --disallow-untyped-defs
async def f():  # E: Function is missing a return type annotation \
                # N: Use "-> None" if function does not return a value
    pass
[builtins fixtures/async_await.pyi]
[typing fixtures/typing-medium.pyi]

[case testAsyncUnannotatedArgument]
# flags: --disallow-untyped-defs
async def f(x) -> None:  # E: Function is missing a type annotation for one or more arguments
    pass
[builtins fixtures/async_await.pyi]
[typing fixtures/typing-async.pyi]

[case testAsyncUnannotatedReturn]
# flags: --disallow-untyped-defs
from typing import Any
async def f(x: int):  # E: Function is missing a return type annotation
    pass
# Make sure explicit Any is allowed.
async def g(x: int) -> Any:
    pass
[builtins fixtures/async_await.pyi]
[typing fixtures/typing-async.pyi]

[case testDisallowUntypedDefsAndGeneric]
# flags: --disallow-untyped-defs --disallow-any-generics
def get_tasks(self):
    return 'whatever'
[out]
main:2: error: Function is missing a return type annotation

[case testDisallowUntypedDefsUntypedDecorator]
# flags: --disallow-untyped-decorators
def d(p):
    return p

@d  # E: Untyped decorator makes function "f" untyped
def f(i: int) -> int:
    return i

[case testDisallowUntypedDecoratorsUnresolvedDecorator]
# flags: --disallow-untyped-decorators --ignore-missing-imports
from nonexistent import d

@d  # E: Untyped decorator makes function "f" untyped
def f(i: int) -> int:
    return i

[case testDisallowUntypedDecoratorUntypedDef]
# flags: --disallow-untyped-decorators

def d(p):
    return p

@d  # no error
def f(): pass

[case testDisallowUntypedDecoratorsPartialFunction]
# flags: --disallow-untyped-decorators

def d(p):
    return p

@d  # E: Untyped decorator makes function "f" untyped
def f(x) -> None: pass

@d  # E: Untyped decorator makes function "g" untyped
def g(x, y: int): pass

@d  # E: Untyped decorator makes function "h" untyped
def h(x: int): pass

[case testDisallowUntypedDecoratorsImpreciseDecorator]
# flags: --disallow-untyped-decorators
from typing import Any

def d(p) -> Any:
    return p

@d  # no error
def f() -> None: pass

[case testDisallowUntypedDecoratorsMultipleDecorators]
# flags: --disallow-untyped-decorators
from typing import Any

def d1(p):
    return p
def d2(p):
    return p
def d3(p) -> Any:
    return p

@d1  # E: Untyped decorator makes function "f" untyped
@d2  # E: Untyped decorator makes function "f" untyped
@d3  # no error
@d1  # E: Untyped decorator makes function "f" untyped
def f() -> None: pass

[case testDisallowUntypedDecoratorsCallableInstance]
# flags: --disallow-untyped-decorators
from typing import Callable

class TypedDecorator:
    def __call__(self, c: Callable) -> Callable:
        return function

class UntypedDecorator:
    def __call__(self, c):
        return function

@TypedDecorator()
def f() -> None: pass

@UntypedDecorator()  # E: Untyped decorator makes function "g" untyped
def g() -> None: pass

@TypedDecorator()
@UntypedDecorator()  # E: Untyped decorator makes function "h" untyped
def h() -> None: pass

@UntypedDecorator()  # E: Untyped decorator makes function "i" untyped
@TypedDecorator()
def i() -> None: pass

reveal_type(f)  # N: Revealed type is "def (*Any, **Any) -> Any"
reveal_type(g)  # N: Revealed type is "Any"
reveal_type(h)  # N: Revealed type is "def (*Any, **Any) -> Any"
reveal_type(i)  # N: Revealed type is "Any"

[case testDisallowUntypedDecoratorsCallableInstanceDecoratedCall]
# flags: --disallow-untyped-decorators
from typing import Callable, TypeVar

C = TypeVar('C', bound=Callable)

def typed_decorator(c: C) -> C:
    return c

def untyped_decorator(c):
    return c

class TypedDecorator:
    @typed_decorator
    def __call__(self, c: Callable) -> Callable:
        return function

class UntypedDecorator1:
    @untyped_decorator
    def __call__(self, c):
        return function

class UntypedDecorator2:
    @untyped_decorator  # E: Untyped decorator makes function "__call__" untyped
    def __call__(self, c: Callable) -> Callable:
        return function

class UntypedDecorator3:
    @typed_decorator
    @untyped_decorator  # E: Untyped decorator makes function "__call__" untyped
    def __call__(self, c: Callable) -> Callable:
        return function

class UntypedDecorator4:
    @untyped_decorator  # E: Untyped decorator makes function "__call__" untyped
    @typed_decorator
    def __call__(self, c: Callable) -> Callable:
        return function

@TypedDecorator()
def f() -> None: pass

@UntypedDecorator1()  # E: Untyped decorator makes function "g1" untyped
def g1() -> None: pass

@UntypedDecorator2()  # E: Untyped decorator makes function "g2" untyped
def g2() -> None: pass

@UntypedDecorator3()  # E: Untyped decorator makes function "g3" untyped
def g3() -> None: pass

@UntypedDecorator4()  # E: Untyped decorator makes function "g4" untyped
def g4() -> None: pass

reveal_type(f)  # N: Revealed type is "def (*Any, **Any) -> Any"
reveal_type(g1)  # N: Revealed type is "Any"
reveal_type(g2)  # N: Revealed type is "Any"
reveal_type(g3)  # N: Revealed type is "Any"
reveal_type(g4)  # N: Revealed type is "Any"
[builtins fixtures/bool.pyi]

[case testDisallowUntypedDecoratorsNonCallableInstance]
# flags: --disallow-untyped-decorators
class Decorator:
    pass

@Decorator()  # E: "Decorator" not callable
def f() -> None: pass

[case testSubclassingAny]
# flags: --disallow-subclassing-any
from typing import Any
FakeClass = None  # type: Any
class Foo(FakeClass): pass  # E: Class cannot subclass "FakeClass" (has type "Any")
[out]

[case testSubclassingAnyMultipleBaseClasses]
# flags: --disallow-subclassing-any
from typing import Any
FakeClass = None  # type: Any
class ActualClass: pass
class Foo(ActualClass, FakeClass): pass  # E: Class cannot subclass "FakeClass" (has type "Any")
[out]

[case testSubclassingAnySilentImports]
# flags: --disallow-subclassing-any --follow-imports=skip
# cmd: mypy -m main

[file main.py]
from ignored_module import BaseClass
class Foo(BaseClass): pass

[file ignored_module.py]
class BaseClass: pass

[out]
tmp/main.py:2: error: Class cannot subclass "BaseClass" (has type "Any")

[case testSubclassingAnySilentImports2]
# flags: --disallow-subclassing-any --follow-imports=skip
# cmd: mypy -m main

[file main.py]
import ignored_module
class Foo(ignored_module.BaseClass): pass

[file ignored_module.py]
class BaseClass: pass

[out]
tmp/main.py:2: error: Class cannot subclass "BaseClass" (has type "Any")

[case testWarnNoReturnIgnoresTrivialFunctions]
# flags: --warn-no-return
def f() -> int:
  pass
def g() -> int:
  ...
def h() -> int:
  """with docstring"""
  pass
def i() -> int:
  """with docstring"""
  ...
def j() -> int:
  u"""with unicode docstring"""
  pass
def k() -> int:
  """docstring only"""

[case testWarnNoReturnWorksWithAlwaysTrue]
# flags: --warn-no-return
PY3 = True
def f() -> int:
    if PY3:
        return 0
    else:
        return 0
[builtins fixtures/bool.pyi]

[case testWarnNoReturnWorksWithAlwaysFalse]
# flags: --warn-no-return
PY2 = False
def f() -> int:
    if PY2:
        return 0
    else:
        return 0
[builtins fixtures/bool.pyi]

[case testWarnNoReturnWorksWithMypyTrue]
# flags: --warn-no-return
MYPY = False
def f() -> int:
    if MYPY:
        return 0
    else:
        return 0
[builtins fixtures/bool.pyi]

[case testNoReturnDisallowsReturn]
# flags: --warn-no-return
from typing import NoReturn

def f() -> NoReturn:
  if bool():
    return 5  # E: Return statement in function which does not return
  else:
    return  # E: Return statement in function which does not return
[builtins fixtures/dict.pyi]

[case testNoReturnWithoutImplicitReturn]
# flags: --warn-no-return
from typing import NoReturn

def no_return() -> NoReturn: pass
def f() -> NoReturn:
  no_return()
[builtins fixtures/dict.pyi]

[case testNoReturnDisallowsImplicitReturn]
# flags: --warn-no-return
from typing import NoReturn

def f() -> NoReturn:  # E: Implicit return in function which does not return
  non_trivial_function = 1
[builtins fixtures/dict.pyi]

[case testNoReturnImplicitReturnCheckInDeferredNode]
# flags: --warn-no-return
from typing import NoReturn

def exit() -> NoReturn: ...

def force_forward_reference() -> int:
    return 4

def f() -> NoReturn:
    x
    exit()

x = force_forward_reference()
[builtins fixtures/exception.pyi]

[case testNoReturnNoWarnNoReturn]
# flags: --warn-no-return
from typing import NoReturn

def no_return() -> NoReturn: pass
def f() -> int:
  if bool():
    return 0
  else:
    no_return()
[builtins fixtures/dict.pyi]

[case testNoReturnInExpr]
# flags: --warn-no-return
from typing import NoReturn

def no_return() -> NoReturn: pass
def f() -> int:
  return 0
reveal_type(f() or no_return())  # N: Revealed type is "builtins.int"
[builtins fixtures/dict.pyi]

[case testNoReturnVariable]
# flags: --warn-no-return
from typing import NoReturn

x = 0  # type: NoReturn  # E: Incompatible types in assignment (expression has type "int", variable has type "Never")
[builtins fixtures/dict.pyi]

[case testNoReturnAsync]
# flags: --warn-no-return
from typing import NoReturn

async def f() -> NoReturn: ...

async def g() -> NoReturn:
  await f()

async def h() -> NoReturn:  # E: Implicit return in function which does not return
  # Purposely not evaluating coroutine
  _ = f()
[builtins fixtures/dict.pyi]
[typing fixtures/typing-async.pyi]

[case testNoWarnNoReturn]
# flags: --no-warn-no-return
import typing

def implicit_optional_return(arg) -> typing.Optional[str]:
    if arg:
        return "false"

def unsound_implicit_return(arg) -> str:  # E: Incompatible return value type (implicitly returns "None", expected "str")
    if arg:
        return "false"

def implicit_return_gen(arg) -> typing.Generator[int, None, typing.Optional[str]]:
    yield 1

def unsound_implicit_return_gen(arg) -> typing.Generator[int, None, str]:  # E: Incompatible return value type (implicitly returns "None", expected "str")
    yield 1
[builtins fixtures/dict.pyi]

[case testNoWarnNoReturnNoStrictOptional]
# flags: --no-warn-no-return --no-strict-optional
import typing

def implicit_optional_return(arg) -> typing.Optional[str]:
    if arg:
        return "false"

def unsound_implicit_return(arg) -> str:
    if arg:
        return "false"

def implicit_return_gen(arg) -> typing.Generator[int, None, typing.Optional[str]]:
    yield 1

def unsound_implicit_return_gen(arg) -> typing.Generator[int, None, str]:
    yield 1
[builtins fixtures/dict.pyi]

[case testNoReturnImportFromTyping]
from typing import NoReturn

def h() -> NoReturn:
  if bool():
    return 5  # E: Return statement in function which does not return
  else:
    return  # E: Return statement in function which does not return

def no_return() -> NoReturn: pass
def f() -> NoReturn:
  no_return()

x: NoReturn = 0 # E: Incompatible types in assignment (expression has type "int", variable has type "Never")
[builtins fixtures/dict.pyi]

[case testShowErrorContextFunction]
# flags: --show-error-context
def f() -> None:
  0 + ""
[out]
main: note: In function "f":
main:3: error: Unsupported operand types for + ("int" and "str")

[case testShowErrorContextClass]
# flags: --show-error-context
class A:
  0 + ""
[out]
main: note: In class "A":
main:3: error: Unsupported operand types for + ("int" and "str")

[case testShowErrorContextMember]
# flags: --show-error-context
class A:
  def f(self, x: int) -> None:
    self.f("")
[out]
main: note: In member "f" of class "A":
main:4: error: Argument 1 to "f" of "A" has incompatible type "str"; expected "int"

[case testShowErrorContextModule]
# flags: --show-error-context
import m
[file m.py]
0 + ""
[out]
main:2: note: In module imported here:
tmp/m.py:1: error: Unsupported operand types for + ("int" and "str")

[case testShowErrorContextTopLevel]
# flags: --show-error-context
def f() -> None:
  0 + ""
0 + ""
[out]
main: note: In function "f":
main:3: error: Unsupported operand types for + ("int" and "str")
main: note: At top level:
main:4: error: Unsupported operand types for + ("int" and "str")

[case testShowErrorContextFromHere]
# flags: --show-error-context
import a
[file a.py]
import b
[file b.py]
0 + ""
[out]
tmp/a.py:1: note: In module imported here,
main:2: note: ... from here:
tmp/b.py:1: error: Unsupported operand types for + ("int" and "str")

[case testFollowImportsNormal]
# flags: --follow-imports=normal
from mod import x
x + 0
x + ""  # E: Unsupported operand types for + ("int" and "str")
import mod
mod.x + 0
mod.x + ""  # E: Unsupported operand types for + ("int" and "str")
mod.y  # E: "object" has no attribute "y"
mod + 0  # E: Unsupported left operand type for + ("object")
[file mod.py]
1 + ""  # E: Unsupported operand types for + ("int" and "str")
x = 0
x += ""  # E: Unsupported operand types for + ("int" and "str")

[case testFollowImportsSilent]
# flags: --follow-imports=silent
from mod import x
x + ""  # E: Unsupported operand types for + ("int" and "str")
import mod
mod.x + ""  # E: Unsupported operand types for + ("int" and "str")
mod.y  # E: "object" has no attribute "y"
mod + 0  # E: Unsupported left operand type for + ("object")
[file mod.py]
1 + ""
x = 0
x += ""

[case testFollowImportsSilentTypeIgnore]
# flags: --warn-unused-ignores --follow-imports=silent
import mod
[file mod.py]
x = 3  # type: ignore

[case testFollowImportsSkip]
# flags: --follow-imports=skip
from mod import x
reveal_type(x)  # N: Revealed type is "Any"
x + ""
import mod
reveal_type(mod.x)  # N: Revealed type is "Any"
[file mod.py]
this deliberate syntax error will not be reported

[case testFollowImportsError]
# flags: --follow-imports=error
from mod import x  # E: Import of "mod" ignored \
                   # N: (Using --follow-imports=error, module not passed on command line)
x + ""
reveal_type(x)  # N: Revealed type is "Any"
import mod
reveal_type(mod.x) # N: Revealed type is "Any"
[file mod.py]
deliberate syntax error

[case testFollowImportsSelective]
# flags: --config-file tmp/mypy.ini
import normal
import silent
import skip
import error  # E: Import of "error" ignored \
              # N: (Using --follow-imports=error, module not passed on command line)
reveal_type(normal.x)  # N: Revealed type is "builtins.int"
reveal_type(silent.x)  # N: Revealed type is "builtins.int"
reveal_type(skip)  # N: Revealed type is "Any"
reveal_type(error)  # N: Revealed type is "Any"
[file mypy.ini]
\[mypy]
\[mypy-normal]
follow_imports = normal
\[mypy-silent]
follow_imports = silent
\[mypy-skip]
follow_imports = skip
\[mypy-error]
follow_imports = error
[file normal.py]
x = 0
x += ''  # E: Unsupported operand types for + ("int" and "str")
[file silent.py]
x = 0
x += ''
[file skip.py]
bla bla
[file error.py]
bla bla

[case testIgnoreMissingImportsFalse]
from mod import x
[out]
main:1: error: Cannot find implementation or library stub for module named "mod"
main:1: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports

[case testIgnoreMissingImportsTrue]
# flags: --ignore-missing-imports
from mod import x
[out]

[case testNoConfigFile]
# flags: --config-file=
# type: ignore

[file mypy.ini]
\[mypy]
warn_unused_ignores = True
[out]

[case testPerFileIncompleteDefsBasic]
# flags: --config-file tmp/mypy.ini
import standard, incomplete

[file standard.py]
def incomplete(x) -> int:
    return 0
[file incomplete.py]
def incomplete(x) -> int:  # E: Function is missing a type annotation for one or more arguments
    return 0
[file mypy.ini]
\[mypy]
disallow_incomplete_defs = False
\[mypy-incomplete]
disallow_incomplete_defs = True


[case testPerFileIncompleteDefsBasicPyProjectTOML]
# flags: --config-file tmp/pyproject.toml
import standard, incomplete

[file standard.py]
def incomplete(x) -> int:
    return 0
[file incomplete.py]
def incomplete(x) -> int:  # E: Function is missing a type annotation for one or more arguments
    return 0
[file pyproject.toml]
\[tool.mypy]
disallow_incomplete_defs = false
\[[tool.mypy.overrides]]
module = 'incomplete'
disallow_incomplete_defs = true


[case testPerFileStrictOptionalBasic]
# flags: --config-file tmp/mypy.ini
import standard, optional

[file standard.py]
x = 0
if int():
    x = None
[file optional.py]
x = 0
if int():
    x = None  # E: Incompatible types in assignment (expression has type "None", variable has type "int")

[file mypy.ini]
\[mypy]
strict_optional = False
\[mypy-optional]
strict_optional = True


[case testPerFileStrictOptionalBasicPyProjectTOML]
# flags: --config-file tmp/pyproject.toml
import standard, optional

[file standard.py]
x = 0
if int():
    x = None
[file optional.py]
x = 0
if int():
    x = None  # E: Incompatible types in assignment (expression has type "None", variable has type "int")

[file pyproject.toml]
\[tool.mypy]
strict_optional = false
\[[tool.mypy.overrides]]
module = 'optional'
strict_optional = true


[case testPerFileStrictOptionalBasicImportStandard]
# flags: --config-file tmp/mypy.ini
import standard, optional

[file standard.py]
from typing import Optional
def f(x: int) -> None: pass
an_int = 0  # type: int
optional_int = None  # type: Optional[int]
f(an_int)  # ints can be used as ints
f(optional_int)  # optional ints can be used as ints in this file

[file optional.py]
import standard
def f(x: int) -> None: pass
standard.an_int = None  # E: Incompatible types in assignment (expression has type "None", variable has type "int")
standard.optional_int = None  # OK -- explicitly declared as optional
f(standard.an_int)  # ints can be used as ints
f(standard.optional_int)  # E: Argument 1 to "f" has incompatible type "None"; expected "int"

[file mypy.ini]
\[mypy]
strict_optional = False
\[mypy-optional]
strict_optional = True


[case testPerFileStrictOptionalBasicImportStandardPyProjectTOML]
# flags: --config-file tmp/pyproject.toml
import standard, optional

[file standard.py]
from typing import Optional
def f(x: int) -> None: pass
an_int = 0  # type: int
optional_int = None  # type: Optional[int]
f(an_int)  # ints can be used as ints
f(optional_int)  # optional ints can be used as ints in this file

[file optional.py]
import standard
def f(x: int) -> None: pass
standard.an_int = None  # E: Incompatible types in assignment (expression has type "None", variable has type "int")
standard.optional_int = None  # OK -- explicitly declared as optional
f(standard.an_int)  # ints can be used as ints
f(standard.optional_int)  # E: Argument 1 to "f" has incompatible type "None"; expected "int"

[file pyproject.toml]
\[tool.mypy]
strict_optional = false
\[[tool.mypy.overrides]]
module = 'optional'
strict_optional = true


[case testPerFileStrictOptionalBasicImportOptional]
# flags: --config-file tmp/mypy.ini
import standard, optional

[file standard.py]
import optional
def f(x: int) -> None: pass
f(optional.x)  # OK -- in non-strict Optional context
f(optional.y)  # OK -- in non-strict Optional context

[file optional.py]
from typing import Optional
def f(x: int) -> None: pass
x = 0  # type: Optional[int]
y = None  # type: None

[file mypy.ini]
\[mypy]
strict_optional = False
\[mypy-optional]
strict_optional = True


[case testPerFileStrictOptionalBasicImportOptionalPyProjectTOML]
# flags: --config-file tmp/pyproject.toml
import standard, optional

[file standard.py]
import optional
def f(x: int) -> None: pass
f(optional.x)  # OK -- in non-strict Optional context
f(optional.y)  # OK -- in non-strict Optional context

[file optional.py]
from typing import Optional
def f(x: int) -> None: pass
x = 0  # type: Optional[int]
y = None  # type: None

[file pyproject.toml]
\[tool.mypy]
strict_optional = false
\[[tool.mypy.overrides]]
module = 'optional'
strict_optional = true


[case testPerFileStrictOptionalListItemImportOptional]
# flags: --config-file tmp/mypy.ini
import standard, optional

[file standard.py]
import optional
from typing import List
def f(x: List[int]) -> None: pass
f(optional.x)  # OK -- in non-strict Optional context
f(optional.y)  # OK -- in non-strict Optional context

[file optional.py]
from typing import Optional, List
def f(x: List[int]) -> None: pass
x = []  # type: List[Optional[int]]
y = []  # type: List[int]

[file mypy.ini]
\[mypy]
strict_optional = False
\[mypy-optional]
strict_optional = True
[builtins fixtures/list.pyi]


[case testPerFileStrictOptionalListItemImportOptionalPyProjectTOML]
# flags: --config-file tmp/pyproject.toml
import standard, optional

[file standard.py]
import optional
from typing import List
def f(x: List[int]) -> None: pass
f(optional.x)  # OK -- in non-strict Optional context
f(optional.y)  # OK -- in non-strict Optional context

[file optional.py]
from typing import Optional, List
def f(x: List[int]) -> None: pass
x = []  # type: List[Optional[int]]
y = []  # type: List[int]

[file pyproject.toml]
\[tool.mypy]
strict_optional = false
\[[tool.mypy.overrides]]
module = 'optional'
strict_optional = true

[builtins fixtures/list.pyi]


[case testPerFileStrictOptionalComplicatedList]
from typing import Union, Optional, List

def f() -> None:
    x = [] # type: Union[List[Optional[str]], str]
[builtins fixtures/list.pyi]

[case testPerFileStrictOptionalNoneArguments]
# flags: --config-file tmp/mypy.ini
import standard, optional

[file standard.py]
def f(x: int = None) -> None: pass

[file optional.py]
import standard
def f(x: int = None) -> None: pass
standard.f(None)

[file mypy.ini]
\[mypy]
strict_optional = False
implicit_optional = true
\[mypy-optional]
strict_optional = True


[case testPerFileStrictOptionalNoneArgumentsPyProjectTOML]
# flags: --config-file tmp/pyproject.toml
import standard, optional

[file standard.py]
def f(x: int = None) -> None: pass

[file optional.py]
import standard
def f(x: int = None) -> None: pass
standard.f(None)

[file pyproject.toml]
\[tool.mypy]
strict_optional = false
implicit_optional = true
\[[tool.mypy.overrides]]
module = 'optional'
strict_optional = true

[case testSilentMissingImportsOff]
-- ignore_missing_imports is False by default.
import missing  # E: Cannot find implementation or library stub for module named "missing" \
                # N: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports
reveal_type(missing.x)  # N: Revealed type is "Any"

[case testSilentMissingImportsOn]
# flags: --ignore-missing-imports
import missing
reveal_type(missing.x)  # N: Revealed type is "Any"

[case testDisallowImplicitTypesIgnoreMissingTypes]
# flags: --ignore-missing-imports --disallow-any-unimported
from missing import MyType

def f(x: MyType) -> None:  # E: Argument 1 to "f" becomes "Any" due to an unfollowed import
    pass

[case testDisallowImplicitTypes]
# flags: --disallow-any-unimported
from missing import MyType

def f(x: MyType) -> None:
    pass
[out]
main:2: error: Cannot find implementation or library stub for module named "missing"
main:2: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports
main:4: error: Argument 1 to "f" becomes "Any" due to an unfollowed import

[case testDisallowImplicitAnyVariableDefinition]
# flags: --ignore-missing-imports --disallow-any-unimported
from missing import Unchecked

t: Unchecked = 12  # E: Type of variable becomes "Any" due to an unfollowed import

[case testAllowImplicitAnyVariableDefinition]
# flags: --ignore-missing-imports --allow-any-unimported
from missing import Unchecked

t: Unchecked = 12

[case testDisallowImplicitAnyGeneric]
# flags: --ignore-missing-imports --disallow-any-unimported
from missing import Unchecked
from typing import List

def foo(l: List[Unchecked]) -> List[Unchecked]:
    t = []  # type: List[Unchecked]
    return l
[builtins fixtures/list.pyi]
[out]
main:5: error: Return type becomes "list[Any]" due to an unfollowed import
main:5: error: Argument 1 to "foo" becomes "list[Any]" due to an unfollowed import
main:6: error: Type of variable becomes "list[Any]" due to an unfollowed import

[case testDisallowImplicitAnyInherit]
# flags: --ignore-missing-imports --disallow-any-unimported
from missing import Unchecked
from typing import List

class C(Unchecked): # E: Base type Unchecked becomes "Any" due to an unfollowed import
    pass

class A(List[Unchecked]): # E: Base type becomes "list[Any]" due to an unfollowed import
    pass
[builtins fixtures/list.pyi]

[case testDisallowImplicitAnyAlias]
# flags: --ignore-missing-imports --disallow-any-unimported
from missing import Unchecked
from typing import List

X = List[Unchecked]  # E: Type alias target becomes "list[Any]" due to an unfollowed import

def f(x: X) -> None:
    pass
[builtins fixtures/list.pyi]

[case testDisallowImplicitAnyCast]
# flags: --ignore-missing-imports --disallow-any-unimported
from missing import Unchecked
from typing import List, cast


foo = [1, 2, 3]
cast(List[Unchecked], foo)  # E: Target type of cast becomes "list[Any]" due to an unfollowed import
cast(Unchecked, foo)  # E: Target type of cast becomes "Any" due to an unfollowed import
[builtins fixtures/list.pyi]

[case testDisallowImplicitAnyNamedTuple]
# flags: --ignore-missing-imports --disallow-any-unimported
from typing import List, NamedTuple
from missing import Unchecked

Point = NamedTuple('Point', [('x', List[Unchecked]),
                             ('y', Unchecked)])
[builtins fixtures/list.pyi]
[out]
main:5: error: NamedTuple type becomes "tuple[list[Any], Any]" due to an unfollowed import

[case testDisallowImplicitAnyTypeVarConstraints]
# flags: --ignore-missing-imports --disallow-any-unimported
from typing import List, NamedTuple, TypeVar, Any
from missing import Unchecked

T = TypeVar('T', Unchecked, List[Unchecked], str)
[builtins fixtures/list.pyi]
[out]
main:5: error: Constraint 1 becomes "Any" due to an unfollowed import
main:5: error: Constraint 2 becomes "list[Any]" due to an unfollowed import

[case testDisallowImplicitAnyNewType]
# flags: --ignore-missing-imports --disallow-any-unimported
from typing import NewType, List
from missing import Unchecked

Baz = NewType('Baz', Unchecked)  # E: Argument 2 to NewType(...) must be subclassable (got "Any")
Bar = NewType('Bar', List[Unchecked])  # E: Argument 2 to NewType(...) becomes "list[Any]" due to an unfollowed import

[builtins fixtures/list.pyi]

[case testDisallowImplicitAnyCallableAndTuple]
# flags: --ignore-missing-imports --disallow-any-unimported
from typing import Callable, Tuple
from missing import Unchecked

def foo(f: Callable[[], Unchecked]) -> Tuple[Unchecked]:
    return f()
[builtins fixtures/list.pyi]
[out]
main:5: error: Return type becomes "tuple[Any]" due to an unfollowed import
main:5: error: Argument 1 to "foo" becomes "Callable[[], Any]" due to an unfollowed import

[case testDisallowImplicitAnySubclassingExplicitAny]
# flags: --ignore-missing-imports --disallow-any-unimported --disallow-subclassing-any
from typing import Any

class C(Any): # E: Class cannot subclass "Any" (has type "Any")
    pass

[case testDisallowImplicitAnyVarDeclaration]
# flags: --ignore-missing-imports --disallow-any-unimported
from missing import Unchecked

foo: Unchecked = ""
foo = ""
x, y = 1, 2  # type: Unchecked, Unchecked
[builtins fixtures/tuple.pyi]
[out]
main:4: error: Type of variable becomes "Any" due to an unfollowed import
main:6: error: A type on this line becomes "Any" due to an unfollowed import

[case testDisallowUnimportedAnyTypedDictSimple]
# flags: --ignore-missing-imports --disallow-any-unimported
from typing import TypedDict
from x import Unchecked

M = TypedDict('M', {'x': str, 'y': Unchecked})  # E: Type of a TypedDict key becomes "Any" due to an unfollowed import

def f(m: M) -> M: pass  # no error
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testDisallowUnimportedAnyTypedDictGeneric]
# flags: --ignore-missing-imports --disallow-any-unimported
from typing import List, TypedDict
from x import Unchecked

M = TypedDict('M', {'x': str, 'y': List[Unchecked]})  # E: Type of a TypedDict key becomes "list[Any]" due to an unfollowed import

def f(m: M) -> M: pass  # no error
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testDisallowAnyDecoratedUnannotatedDecorator]
# flags: --disallow-any-decorated
from typing import Any

def d(f):
    return f

@d
def f(x: Any) -> Any:  # E: Function is untyped after decorator transformation
    pass
@d
def h(x):  # E: Function is untyped after decorator transformation
    pass
[builtins fixtures/list.pyi]

[case testDisallowAnyDecoratedUnannotatedDecoratorDeferred1]
# flags: --disallow-any-decorated
from typing import Callable

def d(f: Callable[[int], None]) -> Callable[[int], None]:
    return f

def wrapper() -> None:
    if c:
        @d
        def h(x):
            pass

c = [1]
[builtins fixtures/list.pyi]

[case testDisallowAnyDecoratedUnannotatedDecoratorDeferred2]
# flags: --disallow-any-decorated
from typing import Callable

def d(f: Callable[[int], None]) -> Callable[[int], None]:
    return f

c = 1  # no deferral - check that the previous testcase is valid

def wrapper() -> None:
    if c:
        @d
        def h(x):
            pass
[builtins fixtures/list.pyi]

[case testDisallowAnyDecoratedErrorIsReportedOnlyOnce]
# flags: --disallow-any-decorated

def d(f):
    return f

def d2(f):
    return f

@d
@d2
@d
def f(x: int) -> None: pass  # E: Function is untyped after decorator transformation
[case testDisallowAnyDecoratedReturnAny]
# flags: --disallow-any-decorated
from typing import Any

def d(f) -> Any:
    return f

@d
def f() -> None: pass  # E: Function is untyped after decorator transformation
[builtins fixtures/list.pyi]
[case testDisallowAnyDecoratedReturnCallable]
# flags: --disallow-any-decorated
from typing import Any, Callable

def d(f) -> Callable[..., None]:
    return f

@d
def g(i: int, s: str) -> None: pass  # E: Type of decorated function contains type "Any" ("Callable[..., None]")

[builtins fixtures/list.pyi]
[case testDisallowAnyDecoratedNonexistentDecorator]
# flags: --disallow-any-decorated --ignore-missing-imports
from nonexistent import d

@d
def f() -> None: pass  # E: Function is untyped after decorator transformation
[builtins fixtures/list.pyi]

[case testDisallowAnyDecoratedPartlyTypedCallable]
# flags: --disallow-any-decorated --ignore-missing-imports
from typing import Callable, Any, List

def d(f) -> Callable[[int, Any], Any]: pass
def d2(f) -> Callable[[int], List[Any]]: pass
def d3(f) -> Callable[[Any], List[str]]: pass

@d
def f(i: int, s: str) -> None:  # E: Type of decorated function contains type "Any" ("Callable[[int, Any], Any]")
    pass
@d2
def g(i: int) -> None:  # E: Type of decorated function contains type "Any" ("Callable[[int], list[Any]]")
    pass
@d3
def h(i: int) -> None:  # E: Type of decorated function contains type "Any" ("Callable[[Any], list[str]]")
    pass
[builtins fixtures/list.pyi]

[case testDisallowAnyDecoratedReturnsCallableNoParams]
# flags: --disallow-any-decorated
from typing import Callable

def d(p) -> Callable[[], int]:
    return p

@d
def f(i):
    return i
[builtins fixtures/list.pyi]

[case testDisallowAnyDecoratedDecoratorReturnsNonCallable]
# flags: --disallow-any-decorated
def d(p) -> int:
    return p(0)

@d
def f(i):
    return i

[case testDisallowAnyDecoratedUntypedUndecoratedFunction]
# flags: --disallow-any-decorated
from typing import Callable

def f(i):  # no error
    return i

[case testDisallowAnyDecoratedTwoDecorators]
# flags: --disallow-any-decorated
from typing import Callable

def typed_dec(f) -> Callable[[], int]: pass
def untyped_dec(f): pass

@typed_dec
@untyped_dec
def f():  # no error
    return i

@untyped_dec
@typed_dec
def g():  # E: Function is untyped after decorator transformation
    return i

[case testDisallowAnyExprSimple]
# flags: --disallow-any-expr
from typing import Any
def f(s):
    yield s

def g(x) -> Any:
    yield x  # E: Expression has type "Any"

x = f(0)  # E: Expression has type "Any"
for x in f(0):  # E: Expression has type "Any"
    g(x)  # E: Expression has type "Any"

l = [1, 2, 3]
l[f(0)]  # E: Expression has type "Any"
f(l)
f(f(0))  # E: Expression has type "Any"
[builtins fixtures/list.pyi]

[case testDisallowAnyExprUnannotatedFunction]
# flags: --disallow-any-expr
def g(s):
    return s

g(0)
w: int = g(1)

[case testDisallowAnyExprExplicitAnyParam]
# flags: --disallow-any-expr
from typing import Any, List
def f(s: Any) -> None:
    pass

def g(s: List[Any]) -> None:
    pass

f(0)

# type of list below is inferred with expected type of "list[Any]", so that becomes it's type
# instead of list[str]
g([''])  # E: Expression type contains "Any" (has type "list[Any]")
[builtins fixtures/list.pyi]

[case testDisallowAnyExprAllowsAnyInCast]
# flags: --disallow-any-expr
from typing import Any, cast
class Foo:
    g: Any = 2

z = cast(int, Foo().g)
m = cast(Any, Foo().g)  # E: Expression has type "Any"
k = Foo.g  # E: Expression has type "Any"
[builtins fixtures/list.pyi]

[case testDisallowAnyExprAllowsAnyInVariableAssignmentWithExplicitTypeAnnotation]
# flags: --disallow-any-expr
from typing import Any
class Foo:
    g: Any = 2

z: int = Foo().g
x = Foo().g  # type: int
m: Any = Foo().g  # E: Expression has type "Any"
n = Foo().g  # type: Any  # E: Expression has type "Any"
[builtins fixtures/list.pyi]

[case testDisallowAnyExprGeneric]
# flags: --disallow-any-expr
from typing import List

l: List = []
l.append(1)  # E: Expression type contains "Any" (has type "list[Any]")
k = l[0]  # E: Expression type contains "Any" (has type "list[Any]")  # E: Expression has type "Any"
[builtins fixtures/list.pyi]

[case testDisallowAnyExprTypeVar]
# flags: --disallow-any-expr
from typing import TypeVar

T = TypeVar('T')  # no error

def f(t: T) -> T:
    return t
[builtins fixtures/list.pyi]

[case testDisallowAnyExprNamedTuple]
# flags: --disallow-any-expr
from typing import NamedTuple

Point = NamedTuple('Point', [('x', int), ('y', int)])  # no error

def origin() -> Point:
    return Point(x=0, y=0)
[builtins fixtures/list.pyi]

[case testDisallowAnyExprNewType]
# flags: --disallow-any-expr
from typing import NewType

NT = NewType('NT', int)  # no error

def nt() -> NT:
    return NT(1)
[builtins fixtures/list.pyi]

[case testDisallowAnyExprEnum]
# flags: --disallow-any-expr
from enum import Enum
E = Enum('E', '1, 2, 3')  # no error

def k(s: E) -> None: pass
[builtins fixtures/list.pyi]

[case testDisallowAnyExprTypedDict]
# flags: --disallow-any-expr
from typing import TypedDict

Movie = TypedDict('Movie', {'name': str, 'year': int})

def g(m: Movie) -> Movie:
    return m
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testDisallowIncompleteDefs]
# flags: --disallow-incomplete-defs

def f(i: int):  # E: Function is missing a return type annotation
    pass
def g(i) -> None:  # E: Function is missing a type annotation for one or more arguments
    pass
def h(i: int) -> int:  # no error
    return i
def i() -> None:  # no error
    pass

[case testDisallowIncompleteDefsNoReturn]
# flags: --disallow-incomplete-defs --disallow-untyped-defs

def f(i: int):  # E: Function is missing a return type annotation
    pass

[case testDisallowIncompleteDefsSelf]
# flags: --disallow-incomplete-defs
class C:
    def foo(self) -> None:  # no error
        pass

[case testDisallowIncompleteDefsPartiallyAnnotatedParams]
# flags: --disallow-incomplete-defs

def f(i: int, s):
    pass

[out]
main:3: error: Function is missing a return type annotation
main:3: error: Function is missing a type annotation for one or more arguments

[case testDisallowIncompleteDefsAttrsNoAnnotations]
# flags: --disallow-incomplete-defs
import attrs

@attrs.define
class Unannotated:
    foo = attrs.field()

[builtins fixtures/plugin_attrs.pyi]

[case testDisallowIncompleteDefsAttrsWithAnnotations]
# flags: --disallow-incomplete-defs
import attrs

@attrs.define
class Annotated:
    bar: int = attrs.field()

[builtins fixtures/plugin_attrs.pyi]

[case testDisallowIncompleteDefsAttrsPartialAnnotations]
# flags: --disallow-incomplete-defs
import attrs

@attrs.define
class PartiallyAnnotated:  # E: Function is missing a type annotation for one or more arguments
    bar: int = attrs.field()
    baz = attrs.field()

[builtins fixtures/plugin_attrs.pyi]

[case testAlwaysTrueAlwaysFalseFlags]
# flags: --always-true=YOLO --always-true=YOLO1 --always-false=BLAH1 --always-false BLAH --ignore-missing-imports
from somewhere import YOLO, BLAH
if not YOLO:
    1+()
if BLAH:
    1+()
[builtins fixtures/bool.pyi]

[case testAlwaysTrueAlwaysFalseConfigFile]
# flags: --config-file tmp/mypy.ini
from somewhere import YOLO, BLAH
if not YOLO:
    1+()
if BLAH:
    1+()
[file mypy.ini]
\[mypy]
ignore_missing_imports = True
always_true = YOLO1, YOLO
always_false = BLAH, BLAH1
[builtins fixtures/bool.pyi]


[case testAlwaysTrueAlwaysFalseConfigFilePyProjectTOML]
# flags: --config-file tmp/pyproject.toml
from somewhere import YOLO, BLAH
if not YOLO:
    1+()
if BLAH:
    1+()

[file pyproject.toml]
\[tool.mypy]
ignore_missing_imports = true
always_true = ['YOLO1', 'YOLO']
always_false = ['BLAH', 'BLAH1']

[builtins fixtures/bool.pyi]


[case testDisableErrorCodeConfigFile]
# flags: --config-file tmp/mypy.ini --disallow-untyped-defs
import foo
def bar():
    pass
[file mypy.ini]
\[mypy]
disable_error_code = import, no-untyped-def


[case testDisableErrorCodeConfigFilePyProjectTOML]
# flags: --config-file tmp/pyproject.toml --disallow-untyped-defs
import foo
def bar():
    pass

[file pyproject.toml]
\[tool.mypy]
disable_error_code = ['import', 'no-untyped-def']


[case testCheckDisallowAnyGenericsNamedTuple]
# flags: --disallow-any-generics
from typing import NamedTuple

N = NamedTuple('N', [('x', N)])  # type: ignore
n: N
[builtins fixtures/tuple.pyi]
[out]

[case testCheckDisallowAnyGenericsTypedDict]
# flags: --disallow-any-generics
from typing import Dict, Any, Optional, TypedDict

VarsDict = Dict[str, Any]
HostsDict = Dict[str, Optional[VarsDict]]

GroupDataDict = TypedDict(
    "GroupDataDict", {"children": "GroupsDict",  # type: ignore
                      "vars": VarsDict,
                      "hosts": HostsDict}, total=False
)

GroupsDict = Dict[str, GroupDataDict]  # type: ignore
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]


[case testCheckDisallowAnyGenericsStubOnly]
# flags: --disallow-any-generics
from asyncio import Future
from queue import Queue
x: Future[str]
y: Queue[int]

p: Future  # E: Missing type parameters for generic type "Future"
q: Queue  # E: Missing type parameters for generic type "Queue"
[file asyncio/__init__.pyi]
from asyncio.futures import Future as Future
[file asyncio/futures.pyi]
from typing import TypeVar, Generic
_T = TypeVar('_T')
class Future(Generic[_T]): ...
[file queue.pyi]
from typing import TypeVar, Generic
_T = TypeVar('_T')
class Queue(Generic[_T]): ...
[builtins fixtures/async_await.pyi]
[typing fixtures/typing-full.pyi]

[case testDisallowAnyGenericsBuiltinTuple]
# flags: --disallow-any-generics
s = tuple([1, 2, 3])
def f(t: tuple) -> None: pass  # E: Missing type parameters for generic type "tuple"
[builtins fixtures/tuple.pyi]

[case testDisallowAnyGenericsBuiltinList]
# flags: --disallow-any-generics
l = list([1, 2, 3])
def f(t: list) -> None: pass  # E: Missing type parameters for generic type "list"
[builtins fixtures/list.pyi]

[case testDisallowAnyGenericsBuiltinSet]
# flags: --disallow-any-generics
l = set({1, 2, 3})
def f(s: set) -> None: pass  # E: Missing type parameters for generic type "set"
[builtins fixtures/set.pyi]

[case testDisallowAnyGenericsBuiltinDict]
# flags: --disallow-any-generics
l = dict([('a', 1)])
def f(d: dict) -> None: pass  # E: Missing type parameters for generic type "dict"
[builtins fixtures/dict.pyi]

[case testCheckDefaultAllowAnyGeneric]
from typing import TypeVar, Callable

T = TypeVar('T')
C = Callable[[], T]

def f(c: C):
    pass
[out]

[case testCheckAllowAnyGenericAnyGeneric]
# flags: --strict --allow-any-generics
from typing import TypeVar, Callable

T = TypeVar('T')
C = Callable[[], T]

def f(c: C) -> None:
    pass
[out]

[case testCheckDisallowAnyGenericsAnyGeneric]
# flags: --disallow-any-generics
from typing import TypeVar, Callable

T = TypeVar('T')
C = Callable[[], T]

def f(c: C):  # E: Missing type parameters for generic type "C"
    pass
[out]

[case testStrictAnyGeneric]
# flags: --strict
from typing import TypeVar, Generic

T = TypeVar('T')

class A(Generic[T]):
    pass

def f(c: A) -> None:  # E: Missing type parameters for generic type "A"
    pass
[out]

[case testStrictInConfigAnyGeneric]
# flags: --config-file tmp/mypy.ini
from typing import TypeVar, Generic

T = TypeVar('T')

class A(Generic[T]):
    pass

def f(c: A) -> None:  # E: Missing type parameters for generic type "A"
    pass
[file mypy.ini]
\[mypy]
strict = True
[out]


[case testStrictInConfigAnyGenericPyProjectTOML]
# flags: --config-file tmp/pyproject.toml
from typing import TypeVar, Generic

T = TypeVar('T')

class A(Generic[T]):
    pass

def f(c: A) -> None:  # E: Missing type parameters for generic type "A"
    pass

[file pyproject.toml]
\[tool.mypy]
strict = true

[out]


[case testStrictFalseInConfigAnyGeneric]
# flags: --config-file tmp/mypy.ini
from typing import TypeVar, Generic

T = TypeVar('T')

class A(Generic[T]):
    pass

def f(c: A) -> None:
    pass
[file mypy.ini]
\[mypy]
strict = False
[out]


[case testStrictFalseInConfigAnyGenericPyProjectTOML]
# flags: --config-file tmp/pyproject.toml
from typing import TypeVar, Generic

T = TypeVar('T')

class A(Generic[T]):
    pass

def f(c: A) -> None:
    pass

[file pyproject.toml]
\[tool.mypy]
strict = false

[out]


[case testStrictAndStrictEquality]
# flags: --strict
x = 0
y = ''
if x == y:  # E: Non-overlapping equality check (left operand type: "int", right operand type: "str")
    int()
[builtins fixtures/ops.pyi]

[case testStrictEqualityPerFile]
# flags: --config-file tmp/mypy.ini
import b
42 == 'no'  # E: Non-overlapping equality check (left operand type: "Literal[42]", right operand type: "Literal['no']")
[file b.py]
42 == 'no'
[file mypy.ini]
\[mypy]
strict_equality = True
\[mypy-b]
strict_equality = False
[builtins fixtures/bool.pyi]


[case testStrictEqualityPerFilePyProjectTOML]
# flags: --config-file tmp/pyproject.toml
import b
42 == 'no'  # E: Non-overlapping equality check (left operand type: "Literal[42]", right operand type: "Literal['no']")

[file b.py]
42 == 'no'

[file pyproject.toml]
\[tool.mypy]
strict_equality = true
\[[tool.mypy.overrides]]
module = 'b'
strict_equality = false

[builtins fixtures/bool.pyi]


[case testNoImplicitReexport]
# flags: --no-implicit-reexport --show-error-codes
from other_module_2 import a  # E: Module "other_module_2" does not explicitly export attribute "a"  [attr-defined]
reveal_type(a)  # N: Revealed type is "builtins.int"

import other_module_2
reveal_type(other_module_2.a)  # E: Module "other_module_2" does not explicitly export attribute "a"  [attr-defined] \
                               # N: Revealed type is "builtins.int"

from other_module_2 import b  # E: Module "other_module_2" does not explicitly export attribute "b"  [attr-defined]
reveal_type(b)  # N: Revealed type is "def (a: builtins.int) -> builtins.str"

import other_module_2
reveal_type(other_module_2.b)  # E: Module "other_module_2" does not explicitly export attribute "b"  [attr-defined] \
                               # N: Revealed type is "def (a: builtins.int) -> builtins.str"

[file other_module_1.py]
a = 5
def b(a: int) -> str: ...
[file other_module_2.py]
from other_module_1 import a, b
[builtins fixtures/module.pyi]

[case testNoImplicitReexportRespectsAll]
# flags: --no-implicit-reexport
from other_module_2 import a
from other_module_2 import b
[file other_module_1.py]
a = 5
b = 6
[file other_module_2.py]
from other_module_1 import a, b
__all__ = ('b',)
[builtins fixtures/tuple.pyi]
[out]
main:2: error: Module "other_module_2" does not explicitly export attribute "a"

[case testNoImplicitReexportStarConsideredExplicit]
# flags: --no-implicit-reexport
from other_module_2 import a
from other_module_2 import b
[file other_module_1.py]
a = 5
b = 6
[file other_module_2.py]
from other_module_1 import *
__all__ = ('b',)
[builtins fixtures/tuple.pyi]

[case testNoImplicitReexportGetAttr]
# flags: --no-implicit-reexport
from other_module_2 import a  # E: Module "other_module_2" does not explicitly export attribute "a"
reveal_type(a)  # N: Revealed type is "builtins.int"
from other_module_2 import b  # E: Module "other_module_2" does not explicitly export attribute "b"
reveal_type(b)  # N: Revealed type is "builtins.str"
[file other_module_1.py]
b: str = "asdf"
def __getattr__(name: str) -> int: ...
[file other_module_2.py]
from other_module_1 import a, b
def __getattr__(name: str) -> bytes: ...
[builtins fixtures/tuple.pyi]

[case textNoImplicitReexportSuggestions]
# flags: --no-implicit-reexport
from other_module_2 import attr_1

[file other_module_1.py]
attr_1 = 5
attr_2 = 6
[file other_module_2.py]
from other_module_1 import attr_1, attr_2
[out]
main:2: error: Module "other_module_2" does not explicitly export attribute "attr_1"

[case testNoImplicitReexportMypyIni]
# flags: --config-file tmp/mypy.ini
from other_module_2 import a

[file other_module_1.py]
a = 5

[file other_module_2.py]
from other_module_1 import a

[file mypy.ini]
\[mypy]
implicit_reexport = True
\[mypy-other_module_2]
implicit_reexport = False
[out]
main:2: error: Module "other_module_2" does not explicitly export attribute "a"


[case testNoImplicitReexportPyProjectTOML]
# flags: --config-file tmp/pyproject.toml
from other_module_2 import a

[file other_module_1.py]
a = 5

[file other_module_2.py]
from other_module_1 import a

[file pyproject.toml]
\[tool.mypy]
implicit_reexport = true
\[[tool.mypy.overrides]]
module = 'other_module_2'
implicit_reexport = false

[out]
main:2: error: Module "other_module_2" does not explicitly export attribute "a"


[case testImplicitAnyOKForNoArgs]
# flags: --disallow-any-generics --show-column-numbers
from typing import List

A = List  # OK
B = List[A]  # E:10: Missing type parameters for generic type "A"
x: A  # E:4: Missing type parameters for generic type "A"
[builtins fixtures/list.pyi]

[case testDisallowAnyExplicitDefSignature]
# flags: --disallow-any-explicit --show-error-codes

from typing import Any, List

def f(x: Any) -> None:  # E: Explicit "Any" is not allowed  [explicit-any]
    pass

def g() -> Any:  # E: Explicit "Any" is not allowed  [explicit-any]
    pass

def h() -> List[Any]:  # E: Explicit "Any" is not allowed  [explicit-any]
    pass
[builtins fixtures/list.pyi]

[case testDisallowAnyExplicitVarDeclaration]
# flags: --disallow-any-explicit --show-error-codes
from typing import Any
v: Any = ''  # E: Explicit "Any" is not allowed  [explicit-any]
w = ''  # type: Any  # E: Explicit "Any" is not allowed  [explicit-any]
class X:
    y = ''  # type: Any  # E: Explicit "Any" is not allowed  [explicit-any]

[case testDisallowAnyExplicitGenericVarDeclaration]
# flags: --disallow-any-explicit --show-error-codes
from typing import Any, List
v: List[Any] = []  # E: Explicit "Any" is not allowed  [explicit-any]
[builtins fixtures/list.pyi]

[case testDisallowAnyExplicitInheritance]
# flags: --disallow-any-explicit --show-error-codes
from typing import Any, List

class C(Any):  # E: Explicit "Any" is not allowed  [explicit-any]
    pass

class D(List[Any]):  # E: Explicit "Any" is not allowed  [explicit-any]
    pass
[builtins fixtures/list.pyi]

[case testDisallowAnyExplicitAlias]
# flags: --disallow-any-explicit --show-error-codes
from typing import Any, List

X = Any  # E: Explicit "Any" is not allowed  [explicit-any]
Y = List[Any]  # E: Explicit "Any" is not allowed  [explicit-any]

def foo(x: X) -> Y:  # no error
    x.nonexistent()  # no error
    return x
[builtins fixtures/list.pyi]

[case testDisallowAnyExplicitGenericAlias]
# flags: --disallow-any-explicit --show-error-codes
from typing import Any, TypeVar, Tuple

T = TypeVar('T')

TupleAny = Tuple[Any, T]  # E: Explicit "Any" is not allowed  [explicit-any]

def foo(x: TupleAny[str]) -> None:  # no error
    pass

def goo(x: TupleAny[Any]) -> None:  # E: Explicit "Any" is not allowed  [explicit-any]
    pass
[builtins fixtures/tuple.pyi]

[case testDisallowAnyExplicitCast]
# flags: --disallow-any-explicit --show-error-codes
from typing import Any, List, cast

x = 1
y = cast(Any, x)  # E: Explicit "Any" is not allowed  [explicit-any]
z = cast(List[Any], x)  # E: Explicit "Any" is not allowed  [explicit-any]
[builtins fixtures/list.pyi]

[case testDisallowAnyExplicitNamedTuple]
# flags: --disallow-any-explicit --show-error-codes
from typing import Any, List, NamedTuple

Point = NamedTuple('Point', [('x', List[Any]), ('y', Any)])  # E: Explicit "Any" is not allowed  [explicit-any]
[builtins fixtures/list.pyi]

[case testDisallowAnyExplicitTypeVarConstraint]
# flags: --disallow-any-explicit --show-error-codes
from typing import Any, List, TypeVar

T = TypeVar('T', Any, List[Any])  # E: Explicit "Any" is not allowed  [explicit-any]
[builtins fixtures/list.pyi]

[case testDisallowAnyExplicitNewType]
# flags: --disallow-any-explicit --show-error-codes
from typing import Any, List, NewType

# this error does not come from `--disallow-any-explicit` flag
Baz = NewType('Baz', Any)  # E: Argument 2 to NewType(...) must be subclassable (got "Any")  [valid-newtype]
Bar = NewType('Bar', List[Any])  # E: Explicit "Any" is not allowed  [explicit-any]
[builtins fixtures/list.pyi]

[case testDisallowAnyExplicitTypedDictSimple]
# flags: --disallow-any-explicit --show-error-codes
from typing import Any, TypedDict

M = TypedDict('M', {'x': str, 'y': Any})  # E: Explicit "Any" is not allowed  [explicit-any]
M(x='x', y=2)  # no error
def f(m: M) -> None: pass  # no error
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testDisallowAnyExplicitTypedDictGeneric]
# flags: --disallow-any-explicit --show-error-codes
from typing import Any, List, TypedDict

M = TypedDict('M', {'x': str, 'y': List[Any]})  # E: Explicit "Any" is not allowed  [explicit-any]
N = TypedDict('N', {'x': str, 'y': List})  # no error
[builtins fixtures/dict.pyi]
[typing fixtures/typing-typeddict.pyi]

[case testDisallowAnyGenericsTupleNoTypeParams]
# flags: --disallow-any-generics
from typing import Tuple

def f(s: Tuple) -> None: pass  # E: Missing type parameters for generic type "Tuple"
def g(s) -> Tuple:  # E: Missing type parameters for generic type "Tuple"
    return 'a', 'b'
def h(s) -> Tuple[str, str]:  # no error
    return 'a', 'b'
x: Tuple = ()  # E: Missing type parameters for generic type "Tuple"
[builtins fixtures/tuple.pyi]

[case testDisallowAnyGenericsTupleWithNoTypeParamsGeneric]
# flags: --disallow-any-generics
from typing import Tuple, List

def f(s: Tuple) -> None: pass  # E: Missing type parameters for generic type "Tuple"
def g(s: List[Tuple]) -> None: pass  # E: Missing type parameters for generic type "Tuple"
def h(s: List[Tuple[str, str]]) -> None: pass  # no error
[builtins fixtures/list.pyi]

[case testDisallowAnyGenericsTypeType]
# flags: --disallow-any-generics
from typing import Type, Any

def f(s: Type[Any]) -> None: pass  # no error
def g(s) -> Type:  # E: Missing type parameters for generic type "Type"
    return s
def h(s) -> Type[str]:  # no error
    return s
x: Type = g(0)  # E: Missing type parameters for generic type "Type"

[case testDisallowAnyGenericsAliasGenericType]
# flags: --disallow-any-generics
from typing import List

L = List  # no error

def f(l: L) -> None: pass  # E: Missing type parameters for generic type "L"
def g(l: L[str]) -> None: pass  # no error
[builtins fixtures/list.pyi]

[case testDisallowAnyGenericsGenericAlias]
# flags: --disallow-any-generics
from typing import TypeVar, Tuple

T = TypeVar('T')
A = Tuple[T, str, T]

def f(s: A) -> None: pass  # E: Missing type parameters for generic type "A"
def g(s) -> A:  # E: Missing type parameters for generic type "A"
    return 'a', 'b', 1
def h(s) -> A[str]:  # no error
    return 'a', 'b', 'c'
x: A = ('a', 'b', 1)  # E: Missing type parameters for generic type "A"
[builtins fixtures/tuple.pyi]

[case testDisallowAnyGenericsPlainList]
# flags: --disallow-any-generics
from typing import List

def f(l: List) -> None: pass  # E: Missing type parameters for generic type "List"
def g(l: List[str]) -> None: pass
def h(l: List[List]) -> None: pass   # E: Missing type parameters for generic type "List"
def i(l: List[List[List[List]]]) -> None: pass  # E: Missing type parameters for generic type "List"
def j() -> List: pass  # E: Missing type parameters for generic type "List"

x = []  # E: Need type annotation for "x" (hint: "x: list[<type>] = ...")
y: List = []  # E: Missing type parameters for generic type "List"
[builtins fixtures/list.pyi]

[case testDisallowAnyGenericsPlainDict]
# flags: --disallow-any-generics
from typing import List, Dict

def f(d: Dict) -> None: pass  # E: Missing type parameters for generic type "Dict"
def g(d: Dict[str, Dict]) -> None: pass  # E: Missing type parameters for generic type "Dict"
def h(d: List[Dict]) -> None: pass  # E: Missing type parameters for generic type "Dict"

d: Dict = {}  # E: Missing type parameters for generic type "Dict"
[builtins fixtures/dict.pyi]

[case testDisallowAnyGenericsPlainSet]
# flags: --disallow-any-generics
from typing import Set

def f(s: Set) -> None: pass  # E: Missing type parameters for generic type "Set"
def g(s: Set[Set]) -> None: pass  # E: Missing type parameters for generic type "Set"

s: Set = set()  # E: Missing type parameters for generic type "Set"
[builtins fixtures/set.pyi]

[case testDisallowAnyGenericsCustomGenericClass]
# flags: --disallow-any-generics
from typing import Generic, TypeVar, Any

T = TypeVar('T')
class G(Generic[T]): pass

def f() -> G:  # E: Missing type parameters for generic type "G"
    return G()

x: G[Any] = G()  # no error
y: G = x  # E: Missing type parameters for generic type "G"

[case testDisallowAnyGenericsForAliasesInRuntimeContext]
# flags: --disallow-any-generics
from typing import Any, TypeVar, Generic, Tuple

T = TypeVar("T")
class G(Generic[T]):
    @classmethod
    def foo(cls) -> T: ...

A = G[Tuple[T, T]]
A()  # E: Missing type parameters for generic type "A"
A.foo()  # E: Missing type parameters for generic type "A"

B = G
B()
B.foo()

def foo(x: Any) -> None: ...
foo(A)
foo(A.foo)
[builtins fixtures/classmethod.pyi]

[case testDisallowSubclassingAny]
# flags: --config-file tmp/mypy.ini
import m
import y

[file m.py]
from typing import Any

x = None  # type: Any

class ShouldBeFine(x): ...

[file y.py]
from typing import Any

x = None  # type: Any

class ShouldNotBeFine(x): ...  # E: Class cannot subclass "x" (has type "Any")

[file mypy.ini]
\[mypy]
disallow_subclassing_any = True
\[mypy-m]
disallow_subclassing_any = False


[case testDisallowSubclassingAnyPyProjectTOML]
# flags: --config-file tmp/pyproject.toml
import m
import y

[file m.py]
from typing import Any

x = None  # type: Any

class ShouldBeFine(x): ...

[file y.py]
from typing import Any

x = None  # type: Any

class ShouldNotBeFine(x): ...  # E: Class cannot subclass "x" (has type "Any")

[file pyproject.toml]
\[tool.mypy]
disallow_subclassing_any = true
\[[tool.mypy.overrides]]
module = 'm'
disallow_subclassing_any = false


[case testNoImplicitOptionalPerModule]
# flags: --config-file tmp/mypy.ini
import m

[file m.py]
def f(a: str = None) -> int:
    return 0

[file mypy.ini]
\[mypy]
no_implicit_optional = True
\[mypy-m]
no_implicit_optional = False


[case testNoImplicitOptionalPerModulePyProjectTOML]
# flags: --config-file tmp/pyproject.toml
import m

[file m.py]
def f(a: str = None) -> int:
    return 0

[file pyproject.toml]
\[tool.mypy]
no_implicit_optional = true
\[[tool.mypy.overrides]]
module = 'm'
no_implicit_optional = false

[case testDisableErrorCode]
# flags: --disable-error-code attr-defined
x = 'should be fine'
x.trim()

[case testDisableDifferentErrorCode]
# flags: --disable-error-code name-defined --show-error-codes
x = 'should not be fine'
x.trim()  # E: "str" has no attribute "trim"  [attr-defined]

[case testDisableMultipleErrorCode]
# flags: --disable-error-code attr-defined --disable-error-code return-value --show-error-codes
x = 'should be fine'
x.trim()

def bad_return_type() -> str:
    return None

bad_return_type('no args taken!')  # E: Too many arguments for "bad_return_type"  [call-arg]

[case testEnableErrorCode]
# flags: --disable-error-code attr-defined --enable-error-code attr-defined --show-error-codes
x = 'should be fine'
x.trim()  # E: "str" has no attribute "trim"  [attr-defined]

[case testEnableDifferentErrorCode]
# flags: --disable-error-code attr-defined --enable-error-code name-defined --show-error-codes
x = 'should not be fine'
x.trim()
y.trim()  # E: Name "y" is not defined  [name-defined]

[case testEnableMultipleErrorCode]
# flags: \
    --disable-error-code attr-defined \
    --disable-error-code return-value \
    --disable-error-code call-arg \
    --enable-error-code attr-defined \
    --enable-error-code return-value --show-error-codes
x = 'should be fine'
x.trim()  # E: "str" has no attribute "trim"  [attr-defined]

def bad_return_type() -> str:
    return None  # E: Incompatible return value type (got "None", expected "str")  [return-value]

bad_return_type('no args taken!')

[case testDisallowUntypedCallsArgType]
# flags: --disallow-untyped-calls
def f(x):
    pass

y = 1
f(reveal_type(y)) # E: Call to untyped function "f" in typed context \
                  # N: Revealed type is "builtins.int"

[case testDisallowUntypedCallsAllowListFlags]
# flags: --disallow-untyped-calls  --untyped-calls-exclude=foo --untyped-calls-exclude=bar.A
from foo import test_foo
from bar import A, B
from baz import test_baz
from foobar import bad

test_foo(42)  # OK
test_baz(42)  # E: Call to untyped function "test_baz" in typed context
bad(42)  # E: Call to untyped function "bad" in typed context

a: A
b: B
a.meth()  # OK
b.meth()  # E: Call to untyped function "meth" in typed context
[file foo.py]
def test_foo(x): pass
[file foobar.py]
def bad(x): pass
[file bar.py]
class A:
    def meth(self): pass
class B:
    def meth(self): pass
[file baz.py]
def test_baz(x): pass

[case testDisallowUntypedCallsAllowListConfig]
# flags: --config-file tmp/mypy.ini
from foo import test_foo
from bar import A, B
from baz import test_baz

test_foo(42)  # OK
test_baz(42)  # E: Call to untyped function "test_baz" in typed context

a: A
b: B
a.meth()  # OK
b.meth()  # E: Call to untyped function "meth" in typed context
[file foo.py]
def test_foo(x): pass
[file bar.py]
class A:
    def meth(self): pass
class B:
    def meth(self): pass
[file baz.py]
def test_baz(x): pass

[file mypy.ini]
\[mypy]
disallow_untyped_calls = True
untyped_calls_exclude = foo, bar.A

[case testPerModuleErrorCodes]
# flags: --config-file tmp/mypy.ini
import tests.foo
import bar
[file bar.py]
x = []  # E: Need type annotation for "x" (hint: "x: list[<type>] = ...")
[file tests/__init__.py]
[file tests/foo.py]
x = []  # OK
[file mypy.ini]
\[mypy]
strict = True

\[mypy-tests.*]
allow_untyped_defs = True
allow_untyped_calls = True
disable_error_code = var-annotated

[case testPerFileIgnoreErrors]
# flags: --config-file tmp/mypy.ini
import foo, bar
[file foo.py]
x: str = 5
[file bar.py]
x: str = 5  # E: Incompatible types in assignment (expression has type "int", variable has type "str")
[file mypy.ini]
\[mypy]
\[mypy-foo]
ignore_errors = True

[case testPerFileUntypedDefs]
# flags: --config-file tmp/mypy.ini
import x, y, z
[file x.py]
def f(a): ...  # E: Function is missing a type annotation
def g(a: int) -> int: return f(a)
[file y.py]
def f(a): pass
def g(a: int) -> int: return f(a)
[file z.py]
def f(a): pass  # E: Function is missing a type annotation
def g(a: int) -> int: return f(a)  # E: Call to untyped function "f" in typed context
[file mypy.ini]
\[mypy]
disallow_untyped_defs = True
\[mypy-y]
disallow_untyped_defs = False
\[mypy-z]
disallow_untyped_calls = True

[case testPerModuleErrorCodesOverride]
# flags: --config-file tmp/mypy.ini
import tests.foo
import bar
[file bar.py]
def foo() -> int: ...
if foo: ...  # E: Function "foo" could always be true in boolean context
42 + "no"  # type: ignore  # E: "type: ignore" comment without error code (consider "type: ignore[operator]" instead)
[file tests/__init__.py]
[file tests/foo.py]
def foo() -> int: ...
if foo: ...  # E: Function "foo" could always be true in boolean context
42 + "no"  # type: ignore
[file mypy.ini]
\[mypy]
enable_error_code = ignore-without-code, truthy-bool, used-before-def

\[mypy-tests.*]
disable_error_code = ignore-without-code

[case testShowErrorCodes]
# flags: --show-error-codes
x: int = ""  # E: Incompatible types in assignment (expression has type "str", variable has type "int")  [assignment]

[case testHideErrorCodes]
# flags: --hide-error-codes
x: int = ""  # E: Incompatible types in assignment (expression has type "str", variable has type "int")

[case testDisableBytearrayPromotion]
# flags: --disable-bytearray-promotion --strict-equality
def f(x: bytes) -> None: ...
f(bytearray(b"asdf"))  # E: Argument 1 to "f" has incompatible type "bytearray"; expected "bytes"
f(memoryview(b"asdf"))
ba = bytearray(b"")
if ba == b"":
    f(ba)  # E: Argument 1 to "f" has incompatible type "bytearray"; expected "bytes"
if b"" == ba:
    f(ba)  # E: Argument 1 to "f" has incompatible type "bytearray"; expected "bytes"
if ba == bytes():
    f(ba)  # E: Argument 1 to "f" has incompatible type "bytearray"; expected "bytes"
if bytes() == ba:
    f(ba)  # E: Argument 1 to "f" has incompatible type "bytearray"; expected "bytes"
[builtins fixtures/primitives.pyi]

[case testDisableMemoryviewPromotion]
# flags: --disable-memoryview-promotion
def f(x: bytes) -> None: ...
f(bytearray(b"asdf"))
f(memoryview(b"asdf"))  # E: Argument 1 to "f" has incompatible type "memoryview"; expected "bytes"
[builtins fixtures/primitives.pyi]

[case testDisableBytearrayMemoryviewPromotionStrictEquality]
# flags: --disable-bytearray-promotion --disable-memoryview-promotion --strict-equality
def f(x: bytes, y: bytearray, z: memoryview) -> None:
    x == y
    y == z
    x == z
    97 in x
    97 in y
    97 in z
    x in y
    x in z
[builtins fixtures/primitives.pyi]

[case testEnableBytearrayMemoryviewPromotionStrictEquality]
# flags: --strict-equality
def f(x: bytes, y: bytearray, z: memoryview) -> None:
    x == y
    y == z
    x == z
    97 in x
    97 in y
    97 in z
    x in y
    x in z
[builtins fixtures/primitives.pyi]

[case testStrictBytes]
# flags: --strict-bytes
def f(x: bytes) -> None: ...
f(bytearray(b"asdf"))  # E: Argument 1 to "f" has incompatible type "bytearray"; expected "bytes"
f(memoryview(b"asdf"))  # E: Argument 1 to "f" has incompatible type "memoryview"; expected "bytes"
[builtins fixtures/primitives.pyi]

[case testNoStrictBytes]
# flags: --no-strict-bytes
def f(x: bytes) -> None: ...
f(bytearray(b"asdf"))
f(memoryview(b"asdf"))
[builtins fixtures/primitives.pyi]

[case testStrictBytesDisabledByDefault]
# TODO: probably change this default in Mypy v2.0, with https://github.com/python/mypy/pull/18371
# (this would also obsolete the testStrictBytesEnabledByStrict test, below)
def f(x: bytes) -> None: ...
f(bytearray(b"asdf"))
f(memoryview(b"asdf"))
[builtins fixtures/primitives.pyi]

[case testStrictBytesEnabledByStrict]
# flags: --strict --disable-error-code type-arg
# The type-arg thing is just work around the primitives.pyi isinstance Tuple not having type parameters,
#   which isn't important for this.
def f(x: bytes) -> None: ...
f(bytearray(b"asdf"))  # E: Argument 1 to "f" has incompatible type "bytearray"; expected "bytes"
f(memoryview(b"asdf"))  # E: Argument 1 to "f" has incompatible type "memoryview"; expected "bytes"
[builtins fixtures/primitives.pyi]

[case testNoCrashFollowImportsForStubs]
# flags: --config-file tmp/mypy.ini
{**{"x": "y"}}

[file mypy.ini]
\[mypy]
follow_imports = skip
follow_imports_for_stubs = true
[builtins fixtures/dict.pyi]

[case testReturnAnyLambda]
# flags: --warn-return-any
from typing import Any, Callable

def cb(f: Callable[[int], int]) -> None: ...
a: Any
cb(lambda x: a)  # OK

fn = lambda x: a
cb(fn)

[case testShowErrorCodeLinks]
# flags: --show-error-codes --show-error-code-links

x: int = ""  # E: Incompatible types in assignment (expression has type "str", variable has type "int")  [assignment]
list(1)  # E: No overload variant of "list" matches argument type "int"  [call-overload] \
         # N: Possible overload variants: \
         # N:     def [T] __init__(self) -> list[T] \
         # N:     def [T] __init__(self, x: Iterable[T]) -> list[T] \
         # N: See https://mypy.rtfd.io/en/stable/_refs.html#code-call-overload for more info
list(2)  # E: No overload variant of "list" matches argument type "int"  [call-overload] \
         # N: Possible overload variants: \
         # N:     def [T] __init__(self) -> list[T] \
         # N:     def [T] __init__(self, x: Iterable[T]) -> list[T]
[builtins fixtures/list.pyi]

[case testNestedGenericInAliasDisallow]
# flags: --disallow-any-generics
from typing import TypeVar, Generic, List, Union

class C(Generic[T]): ...

A = Union[C, List]  # E: Missing type parameters for generic type "C" \
                    # E: Missing type parameters for generic type "List"
[builtins fixtures/list.pyi]

[case testNestedGenericInAliasAllow]
# flags: --allow-any-generics
from typing import TypeVar, Generic, List, Union

class C(Generic[T]): ...

A = Union[C, List]  # OK
[builtins fixtures/list.pyi]

[case testNotesOnlyResultInExitSuccess]
-- check_untyped_defs is False by default.
def f():
    x: int = "no"  # N: By default the bodies of untyped functions are not checked, consider using --check-untyped-defs
