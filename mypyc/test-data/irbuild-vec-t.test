-- Test cases for vec[t] where t is a boxed, non-vec type (PyObject *).
-- Also tests for vec[t | None], which uses the same representation.

[case testVecTCreateEmpty]
from vecs import vec, append

class C: pass

def primitive() -> vec[str]:
    return vec[str]()

def native_class() -> vec[C]:
    return vec[C]()
[out]
def primitive():
    r0 :: object
    r1 :: ptr
    r2 :: vec[str]
L0:
    r0 = load_address PyUnicode_Type
    r1 = r0
    r2 = VecTApi.alloc(0, 0, r1)
    return r2
def native_class():
    r0 :: object
    r1 :: ptr
    r2 :: vec[__main__.C]
L0:
    r0 = __main__.C :: type
    r1 = r0
    r2 = VecTApi.alloc(0, 0, r1)
    return r2

[case testVecTAppend]
from vecs import vec, append

def f(v: vec[str]) -> vec[str]:
    return append(v, 'x')
[out]
def f(v):
    v :: vec[str]
    r0 :: str
    r1 :: object
    r2 :: ptr
    r3 :: vec[str]
L0:
    r0 = 'x'
    r1 = load_address PyUnicode_Type
    r2 = r1
    r3 = VecTApi.append(v, r0, r2)
    return r3

[case testVecTOptionalCreateEmpty]
from vecs import vec, append
from typing import Optional

class C: pass

def primitive() -> vec[Optional[str]]:
    return vec[Optional[str]]()

def native_class() -> vec[Optional[C]]:
    return vec[Optional[C]]()
[out]
def primitive():
    r0 :: object
    r1, r2 :: ptr
    r3 :: vec[union[str, None]]
L0:
    r0 = load_address PyUnicode_Type
    r1 = r0
    r2 = r1 | 1
    r3 = VecTApi.alloc(0, 0, r2)
    return r3
def native_class():
    r0 :: object
    r1, r2 :: ptr
    r3 :: vec[union[__main__.C, None]]
L0:
    r0 = __main__.C :: type
    r1 = r0
    r2 = r1 | 1
    r3 = VecTApi.alloc(0, 0, r2)
    return r3

[case testVecTOptionalAppend]
from vecs import vec, append
from typing import Optional

def f(v: vec[Optional[str]]) -> vec[Optional[str]]:
    v = append(v, 'x')
    return append(v, None)
[out]
def f(v):
    v :: vec[union[str, None]]
    r0 :: str
    r1 :: object
    r2, r3 :: ptr
    r4 :: vec[union[str, None]]
    r5, r6 :: object
    r7, r8 :: ptr
    r9 :: vec[union[str, None]]
L0:
    r0 = 'x'
    r1 = load_address PyUnicode_Type
    r2 = r1
    r3 = r2 | 1
    r4 = VecTApi.append(v, r0, r3)
    v = r4
    r5 = box(None, 1)
    r6 = load_address PyUnicode_Type
    r7 = r6
    r8 = r7 | 1
    r9 = VecTApi.append(v, r5, r8)
    return r9

[case testVecTLen]
from vecs import vec
from mypy_extensions import i64
from typing import Optional

def f(v: vec[str]) -> i64:
    return len(v)

def g(v: vec[Optional[str]]) -> i64:
    return len(v)
[out]
def f(v):
    v :: vec[str]
    r0 :: native_int
L0:
    r0 = v.len
    return r0
def g(v):
    v :: vec[union[str, None]]
    r0 :: native_int
L0:
    r0 = v.len
    return r0

[case testVecTGetItem]
from vecs import vec
from mypy_extensions import i64

def f(v: vec[str], n: i64) -> str:
    return v[n]
[out]
def f(v, n):
    v :: vec[str]
    n :: int64
    r0 :: native_int
    r1 :: bit
    r2 :: bool
    r3 :: object
    r4 :: ptr
    r5 :: int64
    r6 :: ptr
    r7 :: str
L0:
    r0 = v.len
    r1 = n < r0 :: unsigned
    if r1 goto L2 else goto L1 :: bool
L1:
    r2 = raise IndexError
    unreachable
L2:
    r3 = v.buf
    r4 = get_element_ptr r3 items :: VecbufTObject
    r5 = n * 8
    r6 = r4 + r5
    r7 = load_mem r6 :: builtins.str*
    keep_alive v
    return r7

[case testVecTOptionalGetItem]
from vecs import vec
from mypy_extensions import i64
from typing import Optional

def f(v: vec[Optional[str]], n: i64) -> Optional[str]:
    return v[n]
[out]
def f(v, n):
    v :: vec[union[str, None]]
    n :: int64
    r0 :: native_int
    r1 :: bit
    r2 :: bool
    r3 :: object
    r4 :: ptr
    r5 :: int64
    r6 :: ptr
    r7 :: union[str, None]
L0:
    r0 = v.len
    r1 = n < r0 :: unsigned
    if r1 goto L2 else goto L1 :: bool
L1:
    r2 = raise IndexError
    unreachable
L2:
    r3 = v.buf
    r4 = get_element_ptr r3 items :: VecbufTObject
    r5 = n * 8
    r6 = r4 + r5
    r7 = load_mem r6 :: union*
    keep_alive v
    return r7

[case testNewTPopLast]
from typing import Tuple
from vecs import vec, pop

def pop_last(v: vec[str]) -> Tuple[vec[str], str]:
    return pop(v)
[out]
def pop_last(v):
    v :: vec[str]
    r0 :: tuple[vec[str], str]
L0:
    r0 = VecTApi.pop(v, -1)
    return r0

[case testVecTConstructFromListComprehension]
from vecs import vec
from mypy_extensions import i64

def f(n: i64) -> vec[str]:
    return vec[str](['x' for x in range(i64(5))])
[out]
def f(n):
    n :: int64
    r0 :: object
    r1 :: ptr
    r2, r3 :: vec[str]
    r4, x :: int64
    r5 :: bit
    r6 :: str
    r7 :: object
    r8 :: ptr
    r9 :: vec[str]
    r10 :: int64
L0:
    r0 = load_address PyUnicode_Type
    r1 = r0
    r2 = VecTApi.alloc(0, 0, r1)
    r3 = r2
    r4 = 0
    x = r4
L1:
    r5 = r4 < 5 :: signed
    if r5 goto L2 else goto L4 :: bool
L2:
    r6 = 'x'
    r7 = load_address PyUnicode_Type
    r8 = r7
    r9 = VecTApi.append(r3, r6, r8)
    r3 = r9
L3:
    r10 = r4 + 1
    r4 = r10
    x = r10
    goto L1
L4:
    return r3
