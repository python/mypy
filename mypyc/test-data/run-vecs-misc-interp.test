[case testLibrtVecsMiscInterpreted_librt_experimental]
# Test cases for vec[<value primitive type>]. using generic operations.
# This simulates use from interpreted code.
#
# All specialized vec types share most of the implementation, so we don't try to
# duplicate all tests in run-vecs-i64-interp.test, which acts also as a more detailed
# test suite for specialized vec types.

import sys
from typing import Any
import typing

import librt.vecs
import mypy_extensions

from testutil import assertRaises

# Access via Any references to force generic operations
vec: Any = librt.vecs.vec
append: Any = librt.vecs.append
remove: Any = librt.vecs.remove
pop: Any = librt.vecs.pop
u8: Any = mypy_extensions.u8
i16: Any = mypy_extensions.i16
i32: Any = mypy_extensions.i32
i64: Any = mypy_extensions.i64

# Work around test stub limitations
Optional: Any = getattr(getattr(sys, "modules")["typing"], "Optional")

# TODO: Add some nested vec tests

ITEM_TYPES = [i64, u8, i16, i32, float, bool]

# Common tests for all item types

def test_bare_vec_cannot_be_constructed() -> None:
    with assertRaises(TypeError):
        vec()
    with assertRaises(TypeError):
        vec([])

def test_vec_indexing() -> None:
    for t in ITEM_TYPES:
        assert type(vec[t]) is type
        t1 = vec[t]
        t2 = vec[t]
        assert type(vec[t1]) is type(vec[t2])
        _ = [t1, t2]  # Ensure t1 and t2 are live here

        assert vec[t] is not vec
        if t is not i64:
            assert vec[t] is not vec[i64]
        else:
            assert vec[t] is not vec[i32]

        with assertRaises(TypeError):
            vec[Optional[t]]  # Not supported

def test_type_str() -> None:
    for t in ITEM_TYPES:
        name = t.__name__
        assert str(vec[t]) == f"<class 'vec[{name}]'>"
        assert repr(vec[t]) == f"<class 'vec[{name}]'>"

def test_construct_empty() -> None:
    for t in ITEM_TYPES:
        v = vec[t]()
        assert type(v) is vec[t]
        assert len(v) == 0

def test_basic_int_operations() -> None:
    # All of the non-bool item types support int values 0 to 255
    for t in ITEM_TYPES:
        if t is bool:
            continue
        v = vec[t]([0, 4, 255])
        assert len(v) == 3
        assert v[0] == 0
        assert v[1] == 4
        assert v[2] == 255
        assert v[-1] == 255
        assert v[-2] == 4
        assert v[-3] == 0
        for bad_index in 3, -4, 1 << 100, -1 << 100:
            with assertRaises(IndexError):
                v[bad_index]
        with assertRaises(TypeError):
            v["0"]
        with assertRaises(TypeError):
            append(v, "0")

def test_equality() -> None:
    for t1 in ITEM_TYPES:
        for t2 in ITEM_TYPES:
            assert vec[t1]() != []
            if t1 is t2:
                assert vec[t1]() == vec[t2]()
            else:
                assert vec[t1]() != vec[t2]()

def test_repr() -> None:
    for t in ITEM_TYPES:
        name = t.__name__
        assert repr(vec[t]()) == f"vec[{name}]([])"

# vec[float] tests

def test_float_construct_from_initializer() -> None:
    v = vec[float]([123.5])
    assert len(v) == 1
    assert v[0] == 123.5
    v = vec[float](x + 1 for x in [5, 7.5, -8.5, 10])
    assert len(v) == 4
    assert v[0] == 6
    assert v[1] == 8.5
    assert v[2] == -7.5
    assert v[3] == 11
    with assertRaises(TypeError):
        vec[float](1)
    with assertRaises(TypeError):
        vec[float](['1'])
    with assertRaises(TypeError):
        vec[float]([None])

def test_float_append() -> None:
    v = vec[float]()
    v = append(v, 1.5)
    assert str(v) == "vec[float]([1.5])"
    v = append(v, -2)
    assert str(v) == "vec[float]([1.5, -2.0])"

def test_float_get_item() -> None:
    v = append(vec[float](), 44.5)
    assert v[0] == 44.5
    v = append(v, -56.5)
    assert v[0] == 44.5
    assert v[1] == -56.5

def test_float_remove() -> None:
    a = [4.5, 7, 9]
    for x in a:
        v = vec[float](a)
        v = remove(v, x)
        assert v == vec[float]([y for y in a if y != x])

def test_float_pop() -> None:
    v = vec[float]([4.5, 7, 9.5])
    v, n = pop(v)
    assert n == 9.5
    assert v == vec[float]([4.5, 7])

# vec[u8] tests

def test_u8_construct_from_initializer() -> None:
    v = vec[u8]([123])
    assert len(v) == 1
    assert v[0] == 123
    v = vec[u8](x for x in [0, 5, 255, 10])
    assert len(v) == 4
    assert v[0] == 0
    assert v[1] == 5
    assert v[2] == 255
    assert v[3] == 10
    with assertRaises(TypeError):
        vec[u8](1)
    with assertRaises(TypeError):
        vec[u8](['1'])
    with assertRaises(TypeError):
        vec[u8]([None])

def test_u8_append() -> None:
    v = vec[u8]()
    v = append(v, 5)
    assert str(v) == "vec[u8]([5])"
    v = append(v, 255)
    assert str(v) == "vec[u8]([5, 255])"

def test_u8_item_overflow() -> None:
    with assertRaises(OverflowError):
        vec[u8]([256])
    with assertRaises(OverflowError):
        vec[u8]([-1])
    with assertRaises(OverflowError):
        vec[u8]([2**100])
    with assertRaises(OverflowError):
        vec[u8]([-2**100])

def test_u8_get_item() -> None:
    v = append(vec[u8](), 44)
    assert v[0] == 44
    v = append(v, 238)
    assert v[0] == 44
    assert v[1] == 238

def test_u8_remove() -> None:
    a = [0, 7, 255]
    for x in a:
        v = vec[u8](a)
        v = remove(v, x)
        assert v == vec[u8]([y for y in a if y != x])

def test_u8_pop() -> None:
    v = vec[u8]([0, 7, 255])
    v, n = pop(v)
    assert n == 255
    assert v == vec[u8]([0, 7])

# vec[i16] tests

def test_i16_construct_from_initializer() -> None:
    v = vec[i16]([123])
    assert len(v) == 1
    assert v[0] == 123
    v = vec[i16](x for x in [0, 5, 32767, -32768])
    assert len(v) == 4
    assert v[0] == 0
    assert v[1] == 5
    assert v[2] == 32767
    assert v[3] == -32768
    with assertRaises(TypeError):
        vec[i16](1)
    with assertRaises(TypeError):
        vec[i16](['1'])
    with assertRaises(TypeError):
        vec[i16]([None])

def test_i16_append() -> None:
    v = vec[i16]()
    v = append(v, 5)
    assert str(v) == "vec[i16]([5])"
    v = append(v, 32767)
    assert str(v) == "vec[i16]([5, 32767])"

def test_i16_item_overflow() -> None:
    with assertRaises(OverflowError):
        vec[i16]([32768])
    with assertRaises(OverflowError):
        vec[i16]([-32769])
    with assertRaises(OverflowError):
        vec[i16]([2**100])
    with assertRaises(OverflowError):
        vec[i16]([-2**100])

def test_i16_get_item() -> None:
    v = append(vec[i16](), 44)
    assert v[0] == 44
    v = append(v, -238)
    assert v[0] == 44
    assert v[1] == -238

def test_i16_remove() -> None:
    a = [0, 7, -532, 32767]
    for x in a:
        v = vec[i16](a)
        v = remove(v, x)
        assert v == vec[i16]([y for y in a if y != x])

def test_i16_pop() -> None:
    v = vec[i16]([0, -7, 32767])
    v, n = pop(v)
    assert n == 32767
    assert v == vec[i16]([0, -7])

# vec[i32] tests

def test_i32_construct_from_initializer() -> None:
    v = vec[i32]([123])
    assert len(v) == 1
    assert v[0] == 123
    v = vec[i32](x for x in [0, 5, 2**31 - 1, -2**31])
    assert len(v) == 4
    assert v[0] == 0
    assert v[1] == 5
    assert v[2] == 2**31 - 1
    assert v[3] == -2**31
    with assertRaises(TypeError):
        vec[i32](1)
    with assertRaises(TypeError):
        vec[i32](['1'])
    with assertRaises(TypeError):
        vec[i32]([None])

def test_i32_append() -> None:
    v = vec[i32]()
    v = append(v, 5)
    assert str(v) == "vec[i32]([5])"
    v = append(v, 2**31 - 1)
    assert str(v) == "vec[i32]([5, 2147483647])"

def test_i32_item_overflow() -> None:
    with assertRaises(OverflowError):
        vec[i32]([2**31])
    with assertRaises(OverflowError):
        vec[i32]([-2**31 - 1])
    with assertRaises(OverflowError):
        vec[i32]([2**100])
    with assertRaises(OverflowError):
        vec[i32]([-2**100])

def test_i32_get_item() -> None:
    v = append(vec[i32](), 44)
    assert v[0] == 44
    v = append(v, -238)
    assert v[0] == 44
    assert v[1] == -238

def test_i32_remove() -> None:
    a = [0, 7, -532, 2**31 - 1]
    for x in a:
        v = vec[i32](a)
        v = remove(v, x)
        assert v == vec[i32]([y for y in a if y != x])

def test_i32_pop() -> None:
    v = vec[i32]([0, -7, 2**31 - 1])
    v, n = pop(v)
    assert n == 2**31 - 1
    assert v == vec[i32]([0, -7])

# vec[bool] tests

def test_bool_construct_from_initializer() -> None:
    v = vec[bool]([True])
    assert len(v) == 1
    assert v[0] == True
    v = vec[bool](x for x in [True, False, True])
    assert len(v) == 3
    assert v[0] is True
    assert v[1] is False
    assert v[2] is True
    with assertRaises(TypeError):
        vec[bool](1)
    with assertRaises(TypeError):
        vec[bool](['1'])
    with assertRaises(TypeError):
        vec[bool]([1])
    with assertRaises(TypeError):
        vec[bool]([None])

def test_bool_append() -> None:
    v = vec[bool]()
    v = append(v, False)
    assert str(v) == "vec[bool]([False])"
    v = append(v, True)
    assert str(v) == "vec[bool]([False, True])"

def test_bool_get_item() -> None:
    v = append(vec[bool](), True)
    assert v[0] is True
    v = append(v, False)
    assert v[0] is True
    assert v[1] is False

def test_bool_remove() -> None:
    a = [True, False]
    for x in a:
        v = vec[bool](a)
        v = remove(v, x)
        assert v == vec[bool]([y for y in a if y != x])

def test_bool_pop() -> None:
    v = vec[bool]([True, False, True])
    v, n = pop(v)
    assert n is True
    assert v == vec[bool]([True, False])

[case testLibrtVecsFeaturesNotAvailableInNonExperimentalBuild_librt]
# This also ensures librt.vecs can be built without experimental features
import librt.vecs

def test_features_not_available() -> None:
    vecs: object = getattr(librt, "vecs")
    assert not hasattr(vecs, "vec")
    assert not hasattr(vecs, "append")
    assert not hasattr(vecs, "remove")
    assert not hasattr(vecs, "pop")
