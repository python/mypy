[case testAnnotateNonNativeAttribute]
from typing import Any

def f1(x):
    return x.foo  # A: Get non-native attribute "foo".

def f2(x: Any) -> object:
    return x.foo  # A: Get non-native attribute "foo".

class C:
    foo: int

def f3(x: C) -> int:
    return x.foo

[case testAnnotateGenericAdd]
def f(x):
    return x + 1  # A: Generic "+" operation.

def g(x: int) -> int:
    return x + 1

[case testAnnotateTwoOperationsOnLine]
def f(x):
    return x.foo + 1  # A: Get non-native attribute "foo". Generic "+" operation.

[case testAnnotateNonNativeMethod]
from typing import Any

def f1(x):
    return x.foo()  # A: Call non-native method "foo".

def f2(x: Any) -> None:
    x.foo(1)  # A: Call non-native method "foo".
    x.foo(a=1)  # A: Call non-native method "foo".
    t = (1, 'x')
    x.foo(*t)  # A: Get non-native attribute "foo". Generic call operation.
    d = {"a": 1}
    x.foo(*d)  # A: Get non-native attribute "foo". Generic call operation.

class C:
    def foo(self) -> int:
        return 0

def g(c: C) -> int:
    return c.foo()

[case testAnnotateGlobalVariableAccess]
from typing import Final
import nonnative

x = 0
y: Final = 0

def read() -> int:
    return x  # A: Access global "x" through namespace dictionary (hint: access is faster if you can make it Final).

def assign(a: int) -> None:
    global x
    x = a  # A: Access global "x" through namespace dictionary (hint: access is faster if you can make it Final).

def read_final() -> int:
    return y

def read_nonnative() -> int:
    return nonnative.z  # A: Get non-native attribute "z".

[file nonnative.py]
z = 2

[case testAnnotateNestedFunction]
def f1() -> None:
    def g() -> None:  # A: A nested function object is allocated each time statement is executed. A module-level function would be faster.
        pass

    g()

def f2() -> int:
    l = lambda: 1  # A: A new object is allocated for lambda each time it is evaluated. A module-level function would be faster.
    return l()
