[case testNewFrozenSet]
from typing import FrozenSet
def f() -> FrozenSet[int]:
    return frozenset({1, 2, 3})
[out]
def f():
    r0 :: set
    r1 :: object
    r2 :: i32
    r3 :: bit
    r4 :: object
    r5 :: i32
    r6 :: bit
    r7 :: object
    r8 :: i32
    r9 :: bit
    r10 :: frozenset
L0:
    r0 = PySet_New(0)
    r1 = object 1
    r2 = PySet_Add(r0, r1)
    r3 = r2 >= 0 :: signed
    r4 = object 2
    r5 = PySet_Add(r0, r4)
    r6 = r5 >= 0 :: signed
    r7 = object 3
    r8 = PySet_Add(r0, r7)
    r9 = r8 >= 0 :: signed
    r10 = PyFrozenSet_New(r0)
    return r10

[case testNewEmptyFrozenSet]
from typing import FrozenSet
def f1() -> FrozenSet[int]:
    return frozenset()

def f2() -> FrozenSet[int]:
    return frozenset(())
[out]
def f1():
    r0 :: frozenset
L0:
    r0 = PyFrozenSet_New(0)
    return r0
def f2():
    r0 :: tuple[]
    r1 :: object
    r2 :: frozenset
L0:
    r0 = ()
    r1 = box(tuple[], r0)
    r2 = PyFrozenSet_New(r1)
    return r2

[case testNewFrozenSetFromIterable]
from typing import FrozenSet, List, TypeVar

T = TypeVar("T")

def f(l: List[T]) -> FrozenSet[T]:
    return frozenset(l)
[out]
def f(l):
    l :: list
    r0 :: frozenset
L0:
    r0 = PyFrozenSet_New(l)
    return r0

[case testFrozenSetSize]
from typing import FrozenSet
def f() -> int:
    return len(frozenset((1, 2, 3)))
[out]
def f():
    r0 :: tuple[int, int, int]
    r1 :: object
    r2 :: frozenset
    r3 :: ptr
    r4 :: native_int
    r5 :: short_int
L0:
    r0 = (2, 4, 6)
    r1 = box(tuple[int, int, int], r0)
    r2 = PyFrozenSet_New(r1)
    r3 = get_element_ptr r2 used :: PySetObject
    r4 = load_mem r3 :: native_int*
    keep_alive r2
    r5 = r4 << 1
    return r5

[case testFrozenSetContains]
from typing import FrozenSet
def f() -> bool:
    x = frozenset((3, 4))
    return (5 in x)
[out]
def f():
    r0 :: tuple[int, int]
    r1 :: object
    r2, x :: frozenset
    r3 :: object
    r4 :: i32
    r5 :: bit
    r6 :: bool
L0:
    r0 = (6, 8)
    r1 = box(tuple[int, int], r0)
    r2 = PyFrozenSet_New(r1)
    x = r2
    r3 = object 5
    r4 = PySet_Contains(x, r3)
    r5 = r4 >= 0 :: signed
    r6 = truncate r4: i32 to builtins.bool
    return r6

[case testFrozenSetFromRange1]
from typing import FrozenSet
def fn() -> FrozenSet[int]:
    return frozenset(range(3))
[out]
def fn():
    r0, r1 :: object
    r2 :: object[1]
    r3 :: object_ptr
    r4 :: object
    r5 :: range
    r6 :: frozenset
L0:
    r0 = load_address PyRange_Type
    r1 = object 3
    r2 = [r1]
    r3 = load_address r2
    r4 = PyObject_Vectorcall(r0, r3, 1, 0)
    keep_alive r1
    r5 = cast(range, r4)
    r6 = PyFrozenSet_New(r5)
    return r6

[case testFrozenSetFromRange2]
from typing import FrozenSet
def fn() -> FrozenSet[int]:
    return frozenset(range(1, 3))
[out]
def fn():
    r0, r1, r2 :: object
    r3 :: object[2]
    r4 :: object_ptr
    r5 :: object
    r6 :: range
    r7 :: frozenset
L0:
    r0 = load_address PyRange_Type
    r1 = object 1
    r2 = object 3
    r3 = [r1, r2]
    r4 = load_address r3
    r5 = PyObject_Vectorcall(r0, r4, 2, 0)
    keep_alive r1, r2
    r6 = cast(range, r5)
    r7 = PyFrozenSet_New(r6)
    return r7

[case testFrozenSetFromRange3]
from typing import FrozenSet
def fn() -> FrozenSet[int]:
    return frozenset(range(1, 3, 2))
[out]
def fn():
    r0, r1, r2, r3 :: object
    r4 :: object[3]
    r5 :: object_ptr
    r6 :: object
    r7 :: range
    r8 :: frozenset
L0:
    r0 = load_address PyRange_Type
    r1 = object 1
    r2 = object 3
    r3 = object 2
    r4 = [r1, r2, r3]
    r5 = load_address r4
    r6 = PyObject_Vectorcall(r0, r5, 3, 0)
    keep_alive r1, r2, r3
    r7 = cast(range, r6)
    r8 = PyFrozenSet_New(r7)
    return r8

[case testFrozenSetFromRange4]
from typing import FrozenSet
def fn() -> FrozenSet[str]:
    abc = tuple(range(3))
    return frozenset(str(i) for i in abc)
[out]
def fn():
    r0, r1 :: object
    r2 :: object[1]
    r3 :: object_ptr
    r4 :: object
    r5 :: range
    r6, abc :: tuple
    r7 :: native_int
    r8 :: list
    r9, r10 :: native_int
    r11 :: bit
    r12 :: object
    r13, i :: int
    r14 :: str
    r15 :: native_int
    r16 :: frozenset
L0:
    r0 = load_address PyRange_Type
    r1 = object 3
    r2 = [r1]
    r3 = load_address r2
    r4 = PyObject_Vectorcall(r0, r3, 1, 0)
    keep_alive r1
    r5 = cast(range, r4)
    r6 = PySequence_Tuple(r5)
    abc = r6
    r7 = var_object_size abc
    r8 = PyList_New(r7)
    r9 = 0
L1:
    r10 = var_object_size abc
    r11 = r9 < r10 :: signed
    if r11 goto L2 else goto L4 :: bool
L2:
    r12 = CPySequenceTuple_GetItemUnsafe(abc, r9)
    r13 = unbox(int, r12)
    i = r13
    r14 = CPyTagged_Str(i)
    CPyList_SetItemUnsafe(r8, r9, r14)
L3:
    r15 = r9 + 1
    r9 = r15
    goto L1
L4:
    r16 = PyFrozenSet_New(r8)
    return r16

[case testFrozenSetFromRange5]
from typing import FrozenSet
def fn() -> FrozenSet[str]:
    abc = tuple(range(1, 3))
    return frozenset(str(i) for i in abc)
[out]
def fn():
    r0, r1, r2 :: object
    r3 :: object[2]
    r4 :: object_ptr
    r5 :: object
    r6 :: range
    r7, abc :: tuple
    r8 :: native_int
    r9 :: list
    r10, r11 :: native_int
    r12 :: bit
    r13 :: object
    r14, i :: int
    r15 :: str
    r16 :: native_int
    r17 :: frozenset
L0:
    r0 = load_address PyRange_Type
    r1 = object 1
    r2 = object 3
    r3 = [r1, r2]
    r4 = load_address r3
    r5 = PyObject_Vectorcall(r0, r4, 2, 0)
    keep_alive r1, r2
    r6 = cast(range, r5)
    r7 = PySequence_Tuple(r6)
    abc = r7
    r8 = var_object_size abc
    r9 = PyList_New(r8)
    r10 = 0
L1:
    r11 = var_object_size abc
    r12 = r10 < r11 :: signed
    if r12 goto L2 else goto L4 :: bool
L2:
    r13 = CPySequenceTuple_GetItemUnsafe(abc, r10)
    r14 = unbox(int, r13)
    i = r14
    r15 = CPyTagged_Str(i)
    CPyList_SetItemUnsafe(r9, r10, r15)
L3:
    r16 = r10 + 1
    r10 = r16
    goto L1
L4:
    r17 = PyFrozenSet_New(r9)
    return r17

[case testFrozenSetFromRange6]
from typing import FrozenSet
def fn() -> FrozenSet[str]:
    abc = tuple(range(1, 3, 2))
    return frozenset(str(i) for i in abc)
[out]
def fn():
    r0, r1, r2, r3 :: object
    r4 :: object[3]
    r5 :: object_ptr
    r6 :: object
    r7 :: range
    r8, abc :: tuple
    r9 :: native_int
    r10 :: list
    r11, r12 :: native_int
    r13 :: bit
    r14 :: object
    r15, i :: int
    r16 :: str
    r17 :: native_int
    r18 :: frozenset
L0:
    r0 = load_address PyRange_Type
    r1 = object 1
    r2 = object 3
    r3 = object 2
    r4 = [r1, r2, r3]
    r5 = load_address r4
    r6 = PyObject_Vectorcall(r0, r5, 3, 0)
    keep_alive r1, r2, r3
    r7 = cast(range, r6)
    r8 = PySequence_Tuple(r7)
    abc = r8
    r9 = var_object_size abc
    r10 = PyList_New(r9)
    r11 = 0
L1:
    r12 = var_object_size abc
    r13 = r11 < r12 :: signed
    if r13 goto L2 else goto L4 :: bool
L2:
    r14 = CPySequenceTuple_GetItemUnsafe(abc, r11)
    r15 = unbox(int, r14)
    i = r15
    r16 = CPyTagged_Str(i)
    CPyList_SetItemUnsafe(r10, r11, r16)
L3:
    r17 = r11 + 1
    r11 = r17
    goto L1
L4:
    r18 = PyFrozenSet_New(r10)
    return r18

