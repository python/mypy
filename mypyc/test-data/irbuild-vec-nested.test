-- Test cases for nested vecs

[case testVecNestedCreateEmpty]
from vecs import vec, append
from mypy_extensions import i64

def f() -> vec[vec[str]]:
    return vec[vec[str]]()

def g() -> vec[vec[i64]]:
    return vec[vec[i64]]()
[out]
def f():
    r0 :: object
    r1 :: ptr
    r2 :: vec[vec[str]]
L0:
    r0 = load_address PyUnicode_Type
    r1 = r0
    r2 = VecTExtApi.alloc(0, 0, r1, 1)
    return r2
def g():
    r0 :: vec[vec[int64]]
L0:
    r0 = VecTExtApi.alloc(0, 0, 2, 1)
    return r0

[case testVecNestedAppend]
from vecs import vec, append

def f(v: vec[vec[str]], vv: vec[str]) -> vec[vec[str]]:
    return append(v, vv)
[out]
def f(v, vv):
    v :: vec[vec[str]]
    vv :: vec[str]
    r0 :: native_int
    r1 :: object
    r2, r3 :: VecbufTExtItem{len:native_int, buf:object_nrc}
    r4 :: vec[vec[str]]
L0:
    r0 = vv.len
    r1 = vv.buf
    r2 = set_element undef, len, r0
    r3 = set_element r2, buf, r1
    r4 = VecTExtApi.append(v, r3)
    keep_alive vv
    return r4

[case testVecNestedVecI64Append]
from vecs import vec, append
from mypy_extensions import i64

def f(v: vec[vec[i64]], vv: vec[i64]) -> vec[vec[i64]]:
    return append(v, vv)
[out]
def f(v, vv):
    v :: vec[vec[int64]]
    vv :: vec[int64]
    r0 :: native_int
    r1 :: object
    r2, r3 :: VecbufTExtItem{len:native_int, buf:object_nrc}
    r4 :: vec[vec[int64]]
L0:
    r0 = vv.len
    r1 = vv.buf
    r2 = set_element undef, len, r0
    r3 = set_element r2, buf, r1
    r4 = VecTExtApi.append(v, r3)
    keep_alive vv
    return r4

[case testVecNestedLen]
from vecs import vec
from mypy_extensions import i64
from typing import Optional

def f(v: vec[vec[str]]) -> i64:
    return len(v)

def g(v: vec[vec[i64]]) -> i64:
    return len(v)
[out]
def f(v):
    v :: vec[vec[str]]
    r0 :: native_int
L0:
    r0 = v.len
    return r0
def g(v):
    v :: vec[vec[int64]]
    r0 :: native_int
L0:
    r0 = v.len
    return r0

[case testVecNestedGetItem]
from vecs import vec
from mypy_extensions import i64

def f(v: vec[vec[str]], n: i64) -> vec[str]:
    return v[n]
[out]
def f(v, n):
    v :: vec[vec[str]]
    n :: int64
    r0 :: native_int
    r1 :: bit
    r2 :: bool
    r3 :: object
    r4 :: ptr
    r5 :: int64
    r6 :: ptr
    r7 :: vec[str]
L0:
    r0 = v.len
    r1 = n < r0 :: unsigned
    if r1 goto L2 else goto L1 :: bool
L1:
    r2 = raise IndexError
    unreachable
L2:
    r3 = v.buf
    r4 = get_element_ptr r3 items :: VecbufTExtObject
    r5 = n * 16
    r6 = r4 + r5
    r7 = load_mem r6 :: vec[str]*
    keep_alive v
    return r7

[case testVecNestedI64GetItem]
from vecs import vec
from mypy_extensions import i64

def f(v: vec[vec[i64]], n: i64) -> vec[i64]:
    return v[n]
[out]
def f(v, n):
    v :: vec[vec[int64]]
    n :: int64
    r0 :: native_int
    r1 :: bit
    r2 :: bool
    r3 :: object
    r4 :: ptr
    r5 :: int64
    r6 :: ptr
    r7 :: vec[int64]
L0:
    r0 = v.len
    r1 = n < r0 :: unsigned
    if r1 goto L2 else goto L1 :: bool
L1:
    r2 = raise IndexError
    unreachable
L2:
    r3 = v.buf
    r4 = get_element_ptr r3 items :: VecbufTExtObject
    r5 = n * 16
    r6 = r4 + r5
    r7 = load_mem r6 :: vec[int64]*
    keep_alive v
    return r7

[case testVecNestedI64GetItemWithBorrow]
from vecs import vec
from mypy_extensions import i64

def f(v: vec[vec[i64]], n: i64) -> i64:
    return v[n][n]
[out]
def f(v, n):
    v :: vec[vec[int64]]
    n :: int64
    r0 :: native_int
    r1 :: bit
    r2 :: bool
    r3 :: object
    r4 :: ptr
    r5 :: int64
    r6 :: ptr
    r7 :: vec[int64]
    r8 :: native_int
    r9 :: bit
    r10 :: bool
    r11 :: object
    r12 :: ptr
    r13 :: int64
    r14 :: ptr
    r15 :: int64
L0:
    r0 = v.len
    r1 = n < r0 :: unsigned
    if r1 goto L2 else goto L1 :: bool
L1:
    r2 = raise IndexError
    unreachable
L2:
    r3 = v.buf
    r4 = get_element_ptr r3 items :: VecbufTExtObject
    r5 = n * 16
    r6 = r4 + r5
    r7 = borrow load_mem r6 :: vec[int64]*
    r8 = r7.len
    r9 = n < r8 :: unsigned
    if r9 goto L4 else goto L3 :: bool
L3:
    r10 = raise IndexError
    unreachable
L4:
    r11 = r7.buf
    r12 = get_element_ptr r11 items :: VecbufI64Object
    r13 = n * 8
    r14 = r12 + r13
    r15 = load_mem r14 :: int64*
    keep_alive v, r7
    return r15

[case testVecDoublyNestedGetItem]
from vecs import vec
from mypy_extensions import i64

def f(v: vec[vec[vec[str]]], n: i64) -> vec[vec[str]]:
    return v[n]
[out]
def f(v, n):
    v :: vec[vec[vec[str]]]
    n :: int64
    r0 :: native_int
    r1 :: bit
    r2 :: bool
    r3 :: object
    r4 :: ptr
    r5 :: int64
    r6 :: ptr
    r7 :: vec[vec[str]]
L0:
    r0 = v.len
    r1 = n < r0 :: unsigned
    if r1 goto L2 else goto L1 :: bool
L1:
    r2 = raise IndexError
    unreachable
L2:
    r3 = v.buf
    r4 = get_element_ptr r3 items :: VecbufTExtObject
    r5 = n * 16
    r6 = r4 + r5
    r7 = load_mem r6 :: vec[vec[str]]*
    keep_alive v
    return r7
