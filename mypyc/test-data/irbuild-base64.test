[case testBase64_experimental]
from librt.base64 import b64encode, b64decode, urlsafe_b64encode, urlsafe_b64decode

def enc(b: bytes) -> bytes:
    return b64encode(b)

def dec_bytes(b: bytes) -> bytes:
    return b64decode(b)

def dec_str(b: str) -> bytes:
    return b64decode(b)

def uenc(b: bytes) -> bytes:
    return urlsafe_b64encode(b)

def udec_bytes(b: bytes) -> bytes:
    return urlsafe_b64decode(b)

def udec_str(b: str) -> bytes:
    return urlsafe_b64decode(b)
[out]
def enc(b):
    b, r0 :: bytes
L0:
    r0 = LibRTBase64_b64encode_internal(b, 0)
    return r0
def dec_bytes(b):
    b, r0 :: bytes
L0:
    r0 = LibRTBase64_b64decode_internal(b, 0)
    return r0
def dec_str(b):
    b :: str
    r0 :: bytes
L0:
    r0 = LibRTBase64_b64decode_internal(b, 0)
    return r0
def uenc(b):
    b, r0 :: bytes
L0:
    r0 = LibRTBase64_b64encode_internal(b, 1)
    return r0
def udec_bytes(b):
    b, r0 :: bytes
L0:
    r0 = LibRTBase64_b64decode_internal(b, 1)
    return r0
def udec_str(b):
    b :: str
    r0 :: bytes
L0:
    r0 = LibRTBase64_b64decode_internal(b, 1)
    return r0

[case testBase64ExperimentalDisabled]
from librt.base64 import b64encode

def enc(b: bytes) -> bytes:
    return b64encode(b)
[out]
def enc(b):
    b :: bytes
    r0 :: dict
    r1 :: str
    r2 :: object
    r3 :: object[1]
    r4 :: object_ptr
    r5 :: object
    r6 :: bytes
L0:
    r0 = __main__.globals :: static
    r1 = 'b64encode'
    r2 = CPyDict_GetItem(r0, r1)
    r3 = [b]
    r4 = load_address r3
    r5 = PyObject_Vectorcall(r2, r4, 1, 0)
    keep_alive b
    r6 = cast(bytes, r5)
    return r6
