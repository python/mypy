# async test cases (compile and run)

[case testRunAsyncBasics]
import asyncio

async def h() -> int:
    return 1

async def g() -> int:
    await asyncio.sleep(0)
    return await h()

async def f() -> int:
    return await g() + 2

async def f2() -> int:
    x = 0
    for i in range(2):
        x += i + await f() + await g()
    return x

def test_1() -> None:
    result = asyncio.run(f())
    assert result == 3

def test_2() -> None:
    result = asyncio.run(f2())
    assert result == 9

[file asyncio/__init__.pyi]
async def sleep(t: float) -> None: ...
# eh, we could use the real type but it doesn't seem important
def run(x: object) -> object: ...

[typing fixtures/typing-full.pyi]

[case testRunAsyncAwaitInVariousPositions]
from typing import cast, Any

import asyncio

async def one() -> int:
    await asyncio.sleep(0.0)
    return int() + 1

async def true() -> bool:
    return bool(int() + await one())

async def branch_await() -> int:
    if await true():
        return 3
    return 2

async def branch_await_not() -> int:
    if not await true():
        return 3
    return 2

def test_branch() -> None:
    assert asyncio.run(branch_await()) == 3
    assert asyncio.run(branch_await_not()) == 2

async def assign_local() -> int:
    x = await one()
    return x + 1

def test_assign_local() -> None:
    assert asyncio.run(assign_local()) == 2

class C:
    def __init__(self, s: str) -> None:
        self.s = s

    def concat(self, s: str) -> str:
        return self.s + s

async def make_c(s: str) -> C:
    await one()
    return C(s)

async def get_attr(s: str) -> str:
    return (await make_c(s)).s

def test_get_attr() -> None:
    assert asyncio.run(get_attr("foo")) == "foo"

async def concat(s: str, t: str) -> str:
    await one()
    return s + t

async def set_attr1(s: str) -> str:
    c = await make_c("xyz")
    c.s = await concat(s, "!")
    return c.s

async def set_attr2(s: str) -> None:
    (await make_c("xyz")).s = s

def test_set_attr() -> None:
    assert asyncio.run(set_attr1("foo")) == "foo!"
    asyncio.run(set_attr2("foo"))  # Just check that it compiles and runs

def upper(s: str) -> str:
    return s.upper()

async def call1(s: str) -> str:
    return upper(await concat(s, "a"))

async def call2(s: str) -> str:
    return await concat(await concat(s, "a"), "b")

def test_call() -> None:
    assert asyncio.run(call1("foo")) == "FOOA"
    assert asyncio.run(call2("foo")) == "fooab"

async def method_call(s: str) -> str:
    c = C("<")
    return c.concat(await concat(s, ">"))

def test_method_call() -> None:
    assert asyncio.run(method_call("foo")) == "<foo>"

async def construct(s: str) -> str:
    c = C(await concat(s, "!"))
    return c.s

def test_construct() -> None:
    assert asyncio.run(construct("foo")) == "foo!"

async def repr_as_object(s: str) -> object:
    return repr(s)

async def do_cast(s: str) -> str:
    return cast(str, await repr_as_object(s))

def test_cast() -> None:
    assert asyncio.run(do_cast("foo")) == "'foo'"

async def box() -> list[int]:
    return [await one(), await one()]

def test_box() -> None:
    assert asyncio.run(box()) == [1, 1]

async def int_as_any(n: int) -> Any:
    return n * 2

async def inc(n: int) -> int:
    return n + await one()

async def unbox(n: int) -> int:
    return await inc(await int_as_any(n))

def test_unbox() -> None:
    assert asyncio.run(unbox(4)) == 9

[file asyncio/__init__.pyi]
async def sleep(t: float) -> None: ...
# eh, we could use the real type but it doesn't seem important
def run(x: object) -> object: ...

[typing fixtures/typing-full.pyi]


[case testAsyncWith]
from testutil import async_val

class async_ctx:
    async def __aenter__(self) -> str:
        await async_val("enter")
        return "test"

    async def __aexit__(self, x, y, z) -> None:
        await async_val("exit")


async def async_with() -> str:
    async with async_ctx() as x:
        return await async_val("body")


[file driver.py]
from native import async_with
from testutil import run_generator

yields, val = run_generator(async_with(), [None, 'x', None])
assert yields == ('enter', 'body', 'exit'), yields
assert val == 'x', val


[case testAsyncReturn]
from testutil import async_val

async def async_return() -> str:
    try:
        return 'test'
    finally:
        await async_val('foo')

[file driver.py]
from native import async_return
from testutil import run_generator

yields, val = run_generator(async_return())
assert yields == ('foo',)
assert val == 'test', val

[case testAsyncFor]
from typing import AsyncIterable, List, Set, Dict

async def async_iter(xs: AsyncIterable[int]) -> List[int]:
    ys = []
    async for x in xs:
        ys.append(x)
    return ys

async def async_comp(xs: AsyncIterable[int]) -> List[int]:
    ys = [x async for x in xs]
    return ys

async def async_comp_set(xs: AsyncIterable[int]) -> Set[int]:
    return {x async for x in xs}

async def async_comp_dict(xs: AsyncIterable[int]) -> Dict[int, str]:
    return {x: str(x) async for x in xs}

[typing fixtures/typing-full.pyi]

[file driver.py]
from native import async_iter, async_comp, async_comp_set, async_comp_dict
from testutil import run_generator, async_val
from typing import AsyncIterable, List

# defined here since we couldn't do it inside the test yet...
async def foo() -> AsyncIterable[int]:
    for x in range(3):
        await async_val(x)
        yield x

yields, val = run_generator(async_iter(foo()))
assert val == [0,1,2], val
assert yields == (0,1,2), yields

yields, val = run_generator(async_comp(foo()))
assert val == [0,1,2], val
assert yields == (0,1,2), yields

yields, val = run_generator(async_comp_set(foo()))
assert val == {0,1,2}, val
assert yields == (0,1,2), yields

yields, val = run_generator(async_comp_dict(foo()))
assert val == {0: '0',1: '1', 2: '2'}, val
assert yields == (0,1,2), yields

[case testAsyncFor2]
from typing import AsyncIterable, List

async def async_iter(xs: AsyncIterable[int]) -> List[int]:
    ys = []
    async for x in xs:
        ys.append(x)
    return ys

[typing fixtures/typing-full.pyi]

[file driver.py]
from native import async_iter
from testutil import run_generator, async_val
from typing import AsyncIterable, List

# defined here since we couldn't do it inside the test yet...
async def foo() -> AsyncIterable[int]:
    for x in range(3):
        await async_val(x)
        yield x
    raise Exception('lol no')

yields, val = run_generator(async_iter(foo()))
assert yields == (0,1,2), yields
assert val == 'lol no', val

[case testAsyncWithVarReuse]
class ConMan:
    async def __aenter__(self) -> int:
        return 1
    async def __aexit__(self, *exc: object):
        pass

class ConManB:
    async def __aenter__(self) -> int:
        return 2
    async def __aexit__(self, *exc: object):
        pass

async def x() -> None:
    value = 2
    async with ConMan() as f:
        value += f
    assert value == 3, value
    async with ConManB() as f:
        value += f
    assert value == 5, value

[typing fixtures/typing-full.pyi]
[file driver.py]
import asyncio
import native
asyncio.run(native.x())
