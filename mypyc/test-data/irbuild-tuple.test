[case testTupleGet]
from typing import Tuple

def f(x: Tuple[Tuple[int, bool], bool]) -> int:
    return x[0][0]
[out]
def f(x):
    x :: tuple[tuple[int, bool], bool]
    r0 :: tuple[int, bool]
    r1 :: int
L0:
    r0 = x[0]
    r1 = r0[0]
    return r1

[case testTupleNew]
from typing import Tuple

def f() -> int:
    t = (True, 1)
    return t[1]
[out]
def f():
    r0, t :: tuple[bool, int]
    r1 :: int
L0:
    r0 = (1, 2)
    t = r0
    r1 = t[1]
    return r1

[case testTupleLen]
from typing import Tuple
def f(x: Tuple[bool, bool, int]) -> int:
    return len(x)
[out]
def f(x):
    x :: tuple[bool, bool, int]
L0:
    return 6

[case testSequenceTuple]
from typing import List
def f(x: List[bool]) -> bool:
    return tuple(x)[1]
[out]
def f(x):
    x :: list
    r0 :: tuple
    r1 :: object
    r2 :: bool
L0:
    r0 = PyList_AsTuple(x)
    r1 = CPySequenceTuple_GetItem(r0, 2)
    r2 = unbox(bool, r1)
    return r2

[case testSequenceTupleLen]
from typing import Tuple
def f(x: Tuple[int, ...]) -> int:
  return len(x)
[out]
def f(x):
    x :: tuple
    r0 :: native_int
    r1 :: short_int
L0:
    r0 = var_object_size x
    r1 = r0 << 1
    return r1

[case testSequenceTupleForced]
from typing import Tuple
def f() -> int:
    t = (1, 2) # type: Tuple[int, ...]
    return t[1]
[out]
def f():
    r0 :: tuple[int, int]
    r1 :: object
    t :: tuple
    r2 :: object
    r3 :: int
L0:
    r0 = (2, 4)
    r1 = box(tuple[int, int], r0)
    t = r1
    r2 = CPySequenceTuple_GetItem(t, 2)
    r3 = unbox(int, r2)
    return r3

[case testTupleDisplay]
from typing import Sequence, Tuple
def f(x: Sequence[int], y: Sequence[int]) -> Tuple[int, ...]:
    return (1, 2, *x, *y, 3)
[out]
def f(x, y):
    x, y :: object
    r0 :: list
    r1, r2 :: object
    r3 :: ptr
    r4, r5, r6 :: object
    r7 :: i32
    r8 :: bit
    r9 :: tuple
L0:
    r0 = PyList_New(2)
    r1 = object 1
    r2 = object 2
    r3 = list_items r0
    buf_init_item r3, 0, r1
    buf_init_item r3, 1, r2
    keep_alive r0
    r4 = CPyList_Extend(r0, x)
    r5 = CPyList_Extend(r0, y)
    r6 = object 3
    r7 = PyList_Append(r0, r6)
    r8 = r7 >= 0 :: signed
    r9 = PyList_AsTuple(r0)
    return r9

[case testTupleFor]
from typing import Tuple, List
def f(xs: Tuple[str, ...]) -> None:
    for x in xs:
        pass
[out]
def f(xs):
    xs :: tuple
    r0, r1 :: native_int
    r2 :: bit
    r3 :: object
    r4, x :: str
    r5 :: native_int
L0:
    r0 = var_object_size xs
    r1 = 0
L1:
    r2 = r1 < r0 :: signed
    if r2 goto L2 else goto L4 :: bool
L2:
    r3 = CPySequenceTuple_GetItemUnsafe(xs, r1)
    r4 = cast(str, r3)
    x = r4
L3:
    r5 = r1 + 1
    r1 = r5
    goto L1
L4:
    return 1

[case testNamedTupleAttribute]
from typing import NamedTuple

NT = NamedTuple('NT', [('x', int), ('y', int)])

def f(nt: NT, b: bool) -> int:
    if b:
        return nt.x
    return nt.y
[out]
def f(nt, b):
    nt :: tuple
    b :: bool
    r0 :: object
    r1 :: int
    r2 :: object
    r3 :: int
L0:
    if b goto L1 else goto L2 :: bool
L1:
    r0 = CPySequenceTuple_GetItem(nt, 0)
    r1 = unbox(int, r0)
    return r1
L2:
    r2 = CPySequenceTuple_GetItem(nt, 2)
    r3 = unbox(int, r2)
    return r3


[case testTupleOperatorIn]
def f(i: int) -> bool:
    return i in [1, 2, 3]
[out]
def f(i):
    i :: int
    r0, r1, r2 :: bit
    r3 :: bool
L0:
    r0 = int_eq i, 2
    if r0 goto L4 else goto L1 :: bool
L1:
    r1 = int_eq i, 4
    if r1 goto L4 else goto L2 :: bool
L2:
    r2 = int_eq i, 6
    if r2 goto L4 else goto L3 :: bool
L3:
    r3 = 0
    goto L5
L4:
    r3 = 1
L5:
    return r3

[case testTupleOperatorNotIn]
def x() -> int:
    return 1
def y() -> int:
    return 2
def z() -> int:
    return 3

def f() -> bool:
    return z() not in (x(), y())
[out]
def x():
L0:
    return 2
def y():
L0:
    return 4
def z():
L0:
    return 6
def f():
    r0, r1, r2 :: int
    r3, r4 :: bit
    r5 :: bool
L0:
    r0 = z()
    r1 = x()
    r2 = y()
    r3 = int_ne r0, r1
    if r3 goto L1 else goto L3 :: bool
L1:
    r4 = int_ne r0, r2
    if r4 goto L2 else goto L3 :: bool
L2:
    r5 = 1
    goto L4
L3:
    r5 = 0
L4:
    return r5

[case testTupleOperatorInFinalTuple]
from typing import Final

tt: Final = (1, 2)

def f(x: int) -> bool:
    return x in tt
[out]
def f(x):
    x :: int
    r0 :: tuple[int, int]
    r1 :: bool
    r2, r3 :: int
    r4, r5 :: bit
    r6 :: bool
L0:
    r0 = __main__.tt :: static
    if is_error(r0) goto L1 else goto L2
L1:
    r1 = raise NameError('value for final name "tt" was not set')
    unreachable
L2:
    r2 = r0[0]
    r3 = r0[1]
    r4 = int_eq x, r2
    if r4 goto L5 else goto L3 :: bool
L3:
    r5 = int_eq x, r3
    if r5 goto L5 else goto L4 :: bool
L4:
    r6 = 0
    goto L6
L5:
    r6 = 1
L6:
    return r6

[case testTupleBuiltFromList]
def f(val: int) -> bool:
    return val % 2 == 0

def test() -> None:
    source = [1, 2, 3]
    a = tuple(f(x) for x in source)
[out]
def f(val):
    val, r0 :: int
    r1 :: bit
L0:
    r0 = CPyTagged_Remainder(val, 4)
    r1 = int_eq r0, 0
    return r1
def test():
    r0 :: list
    r1, r2, r3 :: object
    r4 :: ptr
    source :: list
    r5 :: native_int
    r6 :: tuple
    r7, r8 :: native_int
    r9 :: bit
    r10 :: object
    r11, x :: int
    r12 :: bool
    r13 :: object
    r14 :: native_int
    a :: tuple
L0:
    r0 = PyList_New(3)
    r1 = object 1
    r2 = object 2
    r3 = object 3
    r4 = list_items r0
    buf_init_item r4, 0, r1
    buf_init_item r4, 1, r2
    buf_init_item r4, 2, r3
    keep_alive r0
    source = r0
    r5 = var_object_size source
    r6 = PyTuple_New(r5)
    r7 = 0
L1:
    r8 = var_object_size source
    r9 = r7 < r8 :: signed
    if r9 goto L2 else goto L4 :: bool
L2:
    r10 = list_get_item_unsafe source, r7
    r11 = unbox(int, r10)
    x = r11
    r12 = f(x)
    r13 = box(bool, r12)
    CPySequenceTuple_SetItemUnsafe(r6, r7, r13)
L3:
    r14 = r7 + 1
    r7 = r14
    goto L1
L4:
    a = r6
    return 1

[case testTupleBuiltFromStr]
def f2(val: str) -> str:
    return val + "f2"

def test() -> None:
    source = "abc"
    a = tuple(f2(x) for x in source)
[out]
def f2(val):
    val, r0, r1 :: str
L0:
    r0 = 'f2'
    r1 = PyUnicode_Concat(val, r0)
    return r1
def test():
    r0, source :: str
    r1 :: native_int
    r2 :: bit
    r3 :: tuple
    r4 :: native_int
    r5 :: bit
    r6, x, r7 :: str
    r8 :: native_int
    a :: tuple
L0:
    r0 = 'abc'
    source = r0
    r1 = CPyStr_Size_size_t(source)
    r2 = r1 >= 0 :: signed
    r3 = PyTuple_New(r1)
    r4 = 0
L1:
    r5 = r4 < r1 :: signed
    if r5 goto L2 else goto L4 :: bool
L2:
    r6 = CPyStr_GetItemUnsafe(source, r4)
    x = r6
    r7 = f2(x)
    CPySequenceTuple_SetItemUnsafe(r3, r4, r7)
L3:
    r8 = r4 + 1
    r4 = r8
    goto L1
L4:
    a = r3
    return 1

[case testTupleBuiltFromStrExpr]
def f2(val: str) -> str:
    return val + "f2"

def test() -> None:
    a = tuple(f2(x) for x in "abc")

[out]
def f2(val):
    val, r0, r1 :: str
L0:
    r0 = 'f2'
    r1 = PyUnicode_Concat(val, r0)
    return r1
def test():
    r0 :: str
    r1 :: tuple
    r2 :: native_int
    r3 :: bit
    r4, x, r5 :: str
    r6 :: native_int
    a :: tuple
L0:
    r0 = 'abc'
    r1 = PyTuple_New(3)
    r2 = 0
    goto L2
L1:
    r3 = r2 < 3 :: signed
    if r3 goto L2 else goto L4 :: bool
L2:
    r4 = CPyStr_GetItemUnsafe(r0, r2)
    x = r4
    r5 = f2(x)
    CPySequenceTuple_SetItemUnsafe(r1, r2, r5)
L3:
    r6 = r2 + 1
    r2 = r6
    goto L1
L4:
    a = r1
    return 1

[case testTupleBuiltFromFinalStr]
from typing import Final

source: Final = "abc"

def f2(val: str) -> str:
    return val + "f2"

def test() -> None:
    a = tuple(f2(x) for x in source)
[out]
def f2(val):
    val, r0, r1 :: str
L0:
    r0 = 'f2'
    r1 = PyUnicode_Concat(val, r0)
    return r1
def test():
    r0 :: str
    r1 :: tuple
    r2 :: native_int
    r3 :: bit
    r4, x, r5 :: str
    r6 :: native_int
    a :: tuple
L0:
    r0 = 'abc'
    r1 = PyTuple_New(3)
    r2 = 0
    goto L2
L1:
    r3 = r2 < 3 :: signed
    if r3 goto L2 else goto L4 :: bool
L2:
    r4 = CPyStr_GetItemUnsafe(r0, r2)
    x = r4
    r5 = f2(x)
    CPySequenceTuple_SetItemUnsafe(r1, r2, r5)
L3:
    r6 = r2 + 1
    r2 = r6
    goto L1
L4:
    a = r1
    return 1

[case testTupleBuiltFromBytes_64bit]
def f2(val: int) -> int:
    return val + 2

def test() -> None:
    source = b"abc"
    a = tuple(f2(x) for x in source)

[out]
def f2(val):
    val, r0 :: int
L0:
    r0 = CPyTagged_Add(val, 4)
    return r0
def test():
    r0, source :: bytes
    r1 :: native_int
    r2 :: tuple
    r3 :: native_int
    r4, r5, r6 :: bit
    r7, r8, r9, r10 :: int
    r11 :: object
    r12, x, r13 :: int
    r14 :: object
    r15 :: native_int
    a :: tuple
L0:
    r0 = b'abc'
    source = r0
    r1 = var_object_size source
    r2 = PyTuple_New(r1)
    r3 = 0
L1:
    r4 = r3 < r1 :: signed
    if r4 goto L2 else goto L8 :: bool
L2:
    r5 = r3 <= 4611686018427387903 :: signed
    if r5 goto L3 else goto L4 :: bool
L3:
    r6 = r3 >= -4611686018427387904 :: signed
    if r6 goto L5 else goto L4 :: bool
L4:
    r7 = CPyTagged_FromInt64(r3)
    r8 = r7
    goto L6
L5:
    r9 = r3 << 1
    r8 = r9
L6:
    r10 = CPyBytes_GetItem(source, r8)
    r11 = box(int, r10)
    r12 = unbox(int, r11)
    x = r12
    r13 = f2(x)
    r14 = box(int, r13)
    CPySequenceTuple_SetItemUnsafe(r2, r3, r14)
L7:
    r15 = r3 + 1
    r3 = r15
    goto L1
L8:
    a = r2
    return 1

[case testTupleBuiltFromBytesExpr_64bit]
def f2(val: int) -> int:
    return val + 2

def test() -> None:
    a = tuple(f2(x) for x in b"abc")

[out]
def f2(val):
    val, r0 :: int
L0:
    r0 = CPyTagged_Add(val, 4)
    return r0
def test():
    r0 :: bytes
    r1 :: tuple
    r2 :: native_int
    r3, r4, r5 :: bit
    r6, r7, r8, r9 :: int
    r10 :: object
    r11, x, r12 :: int
    r13 :: object
    r14 :: native_int
    a :: tuple
L0:
    r0 = b'abc'
    r1 = PyTuple_New(3)
    r2 = 0
    goto L2
L1:
    r3 = r2 < 3 :: signed
    if r3 goto L2 else goto L8 :: bool
L2:
    r4 = r2 <= 4611686018427387903 :: signed
    if r4 goto L3 else goto L4 :: bool
L3:
    r5 = r2 >= -4611686018427387904 :: signed
    if r5 goto L5 else goto L4 :: bool
L4:
    r6 = CPyTagged_FromInt64(r2)
    r7 = r6
    goto L6
L5:
    r8 = r2 << 1
    r7 = r8
L6:
    r9 = CPyBytes_GetItem(r0, r7)
    r10 = box(int, r9)
    r11 = unbox(int, r10)
    x = r11
    r12 = f2(x)
    r13 = box(int, r12)
    CPySequenceTuple_SetItemUnsafe(r1, r2, r13)
L7:
    r14 = r2 + 1
    r2 = r14
    goto L1
L8:
    a = r1
    return 1

[case testTupleBuiltFromFinalBytes_64bit]
from typing import Final

source: Final = b"abc"

def f2(val: int) -> int:
    return val + 2

def test() -> None:
    a = tuple(f2(x) for x in source)

[out]
def f2(val):
    val, r0 :: int
L0:
    r0 = CPyTagged_Add(val, 4)
    return r0
def test():
    r0 :: bytes
    r1 :: bool
    r2 :: native_int
    r3 :: tuple
    r4 :: native_int
    r5, r6, r7 :: bit
    r8, r9, r10, r11 :: int
    r12 :: object
    r13, x, r14 :: int
    r15 :: object
    r16 :: native_int
    a :: tuple
L0:
    r0 = __main__.source :: static
    if is_error(r0) goto L1 else goto L2
L1:
    r1 = raise NameError('value for final name "source" was not set')
    unreachable
L2:
    r2 = var_object_size r0
    r3 = PyTuple_New(r2)
    r4 = 0
L3:
    r5 = r4 < r2 :: signed
    if r5 goto L4 else goto L10 :: bool
L4:
    r6 = r4 <= 4611686018427387903 :: signed
    if r6 goto L5 else goto L6 :: bool
L5:
    r7 = r4 >= -4611686018427387904 :: signed
    if r7 goto L7 else goto L6 :: bool
L6:
    r8 = CPyTagged_FromInt64(r4)
    r9 = r8
    goto L8
L7:
    r10 = r4 << 1
    r9 = r10
L8:
    r11 = CPyBytes_GetItem(r0, r9)
    r12 = box(int, r11)
    r13 = unbox(int, r12)
    x = r13
    r14 = f2(x)
    r15 = box(int, r14)
    CPySequenceTuple_SetItemUnsafe(r3, r4, r15)
L9:
    r16 = r4 + 1
    r4 = r16
    goto L3
L10:
    a = r3
    return 1

[case testTupleBuiltFromFixedLengthTuple]
def f(val: int) -> bool:
    return val % 2 == 0

def test() -> None:
    source = (1, 2, 3)
    a = tuple(f(x) for x in source)
[out]
def f(val):
    val, r0 :: int
    r1 :: bit
L0:
    r0 = CPyTagged_Remainder(val, 4)
    r1 = int_eq r0, 0
    return r1
def test():
    r0, source :: tuple[int, int, int]
    r1, r2, r3 :: int
    r4, r5, r6 :: object
    r7, r8 :: tuple
    r9 :: native_int
    r10 :: bit
    r11 :: object
    r12, x :: int
    r13 :: bool
    r14 :: object
    r15 :: native_int
    a :: tuple
L0:
    r0 = (2, 4, 6)
    source = r0
    r1 = source[0]
    r2 = source[1]
    r3 = source[2]
    r4 = box(int, r1)
    r5 = box(int, r2)
    r6 = box(int, r3)
    r7 = PyTuple_Pack(3, r4, r5, r6)
    r8 = PyTuple_New(3)
    r9 = 0
    goto L2
L1:
    r10 = r9 < 3 :: signed
    if r10 goto L2 else goto L4 :: bool
L2:
    r11 = CPySequenceTuple_GetItemUnsafe(r7, r9)
    r12 = unbox(int, r11)
    x = r12
    r13 = f(x)
    r14 = box(bool, r13)
    CPySequenceTuple_SetItemUnsafe(r8, r9, r14)
L3:
    r15 = r9 + 1
    r9 = r15
    goto L1
L4:
    a = r8
    return 1

[case testTupleBuiltFromFinalFixedLengthTuple]
from typing import Final

source: Final = (1, 2, 3)

def f(val: int) -> bool:
    return val % 2 == 0

def test() -> None:
    a = tuple(f(x) for x in source)
[out]
def f(val):
    val, r0 :: int
    r1 :: bit
L0:
    r0 = CPyTagged_Remainder(val, 4)
    r1 = int_eq r0, 0
    return r1
def test():
    r0 :: tuple[int, int, int]
    r1 :: bool
    r2, r3, r4 :: int
    r5, r6, r7 :: object
    r8, r9 :: tuple
    r10 :: native_int
    r11 :: bit
    r12 :: object
    r13, x :: int
    r14 :: bool
    r15 :: object
    r16 :: native_int
    a :: tuple
L0:
    r0 = __main__.source :: static
    if is_error(r0) goto L1 else goto L2
L1:
    r1 = raise NameError('value for final name "source" was not set')
    unreachable
L2:
    r2 = r0[0]
    r3 = r0[1]
    r4 = r0[2]
    r5 = box(int, r2)
    r6 = box(int, r3)
    r7 = box(int, r4)
    r8 = PyTuple_Pack(3, r5, r6, r7)
    r9 = PyTuple_New(3)
    r10 = 0
    goto L4
L3:
    r11 = r10 < 3 :: signed
    if r11 goto L4 else goto L6 :: bool
L4:
    r12 = CPySequenceTuple_GetItemUnsafe(r8, r10)
    r13 = unbox(int, r12)
    x = r13
    r14 = f(x)
    r15 = box(bool, r14)
    CPySequenceTuple_SetItemUnsafe(r9, r10, r15)
L5:
    r16 = r10 + 1
    r10 = r16
    goto L3
L6:
    a = r9
    return 1

[case testTupleBuiltFromVariableLengthTuple]
from typing import Tuple

def f(val: bool) -> bool:
    return not val

def test(source: Tuple[bool, ...]) -> None:
    a = tuple(f(x) for x in source)
[out]
def f(val):
    val, r0 :: bool
L0:
    r0 = val ^ 1
    return r0
def test(source):
    source :: tuple
    r0 :: native_int
    r1 :: tuple
    r2 :: native_int
    r3 :: bit
    r4 :: object
    r5, x, r6 :: bool
    r7 :: object
    r8 :: native_int
    a :: tuple
L0:
    r0 = var_object_size source
    r1 = PyTuple_New(r0)
    r2 = 0
L1:
    r3 = r2 < r0 :: signed
    if r3 goto L2 else goto L4 :: bool
L2:
    r4 = CPySequenceTuple_GetItemUnsafe(source, r2)
    r5 = unbox(bool, r4)
    x = r5
    r6 = f(x)
    r7 = box(bool, r6)
    CPySequenceTuple_SetItemUnsafe(r1, r2, r7)
L3:
    r8 = r2 + 1
    r2 = r8
    goto L1
L4:
    a = r1
    return 1

[case testTupleBuiltFromStars]
from typing import Final

abc: Final = "abc"

def test() -> None:
    a = tuple(str(x) for x in [*abc, *"def", *b"ghi", ("j", "k"), *("l", "m", "n")])

[out]
def test():
    r0, r1 :: str
    r2 :: bytes
    r3, r4 :: str
    r5 :: tuple[str, str]
    r6, r7, r8 :: str
    r9 :: tuple[str, str, str]
    r10 :: list
    r11, r12, r13, r14 :: object
    r15 :: i32
    r16 :: bit
    r17, r18 :: object
    r19 :: tuple
    r20, r21 :: native_int
    r22 :: bit
    r23, x :: object
    r24 :: str
    r25 :: native_int
    a :: tuple
L0:
    r0 = 'abc'
    r1 = 'def'
    r2 = b'ghi'
    r3 = 'j'
    r4 = 'k'
    r5 = (r3, r4)
    r6 = 'l'
    r7 = 'm'
    r8 = 'n'
    r9 = (r6, r7, r8)
    r10 = PyList_New(0)
    r11 = CPyList_Extend(r10, r0)
    r12 = CPyList_Extend(r10, r1)
    r13 = CPyList_Extend(r10, r2)
    r14 = box(tuple[str, str], r5)
    r15 = PyList_Append(r10, r14)
    r16 = r15 >= 0 :: signed
    r17 = box(tuple[str, str, str], r9)
    r18 = CPyList_Extend(r10, r17)
    r19 = PyTuple_New(13)
    r20 = 0
    goto L2
L1:
    r21 = var_object_size r10
    r22 = r20 < r21 :: signed
    if r22 goto L2 else goto L4 :: bool
L2:
    r23 = list_get_item_unsafe r10, r20
    x = r23
    r24 = PyObject_Str(x)
    CPySequenceTuple_SetItemUnsafe(r19, r20, r24)
L3:
    r25 = r20 + 1
    r20 = r25
    goto L1
L4:
    a = r19
    return 1

[case testTupleAdd]
from typing import Tuple
def f(a: Tuple[int, ...], b: Tuple[int, ...]) -> None:
    c = a + b
    d = a + (1, 2)
def g(a: Tuple[int, int], b: Tuple[int, int]) -> None:
    c = a + b
[out]
def f(a, b):
    a, b, r0, c :: tuple
    r1 :: tuple[int, int]
    r2 :: object
    r3, d :: tuple
L0:
    r0 = PySequence_Concat(a, b)
    c = r0
    r1 = (2, 4)
    r2 = box(tuple[int, int], r1)
    r3 = PySequence_Concat(a, r2)
    d = r3
    return 1
def g(a, b):
    a, b :: tuple[int, int]
    r0, r1 :: object
    r2 :: tuple
    r3, c :: tuple[int, int, int, int]
L0:
    r0 = box(tuple[int, int], a)
    r1 = box(tuple[int, int], b)
    r2 = PySequence_Concat(r0, r1)
    r3 = unbox(tuple[int, int, int, int], r2)
    c = r3
    return 1

[case testTupleMultiply]
from typing import Tuple
def f(a: Tuple[int]) -> None:
    b = a * 2
    c = 3 * (2,)
def g(a: Tuple[int, ...]) -> None:
    b = a * 2
[out]
def f(a):
    a :: tuple[int]
    r0 :: object
    r1 :: tuple
    r2, b :: tuple[int, int]
    r3 :: tuple[int]
    r4 :: object
    r5 :: tuple
    r6, c :: tuple[int, int, int]
L0:
    r0 = box(tuple[int], a)
    r1 = CPySequence_Multiply(r0, 4)
    r2 = unbox(tuple[int, int], r1)
    b = r2
    r3 = (4)
    r4 = box(tuple[int], r3)
    r5 = CPySequence_RMultiply(6, r4)
    r6 = unbox(tuple[int, int, int], r5)
    c = r6
    return 1
def g(a):
    a, r0, b :: tuple
L0:
    r0 = CPySequence_Multiply(a, 4)
    b = r0
    return 1

[case testTupleFloatElementComparison]
def f(x: tuple[float], y: tuple[float]) -> bool:
    return x == y

[out]
def f(x, y):
    x, y :: tuple[float]
    r0, r1 :: float
    r2 :: bit
    r3 :: bool
L0:
    r0 = x[0]
    r1 = y[0]
    r2 = r0 == r1
    if not r2 goto L1 else goto L2 :: bool
L1:
    r3 = 0
    goto L3
L2:
    r3 = 1
L3:
    return r3
