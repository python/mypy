[case testVecTCreateEmpty]
from vecs import vec, append

class C: pass

def primitive() -> vec[str]:
    return vec[str]()

def native_class() -> vec[C]:
    return vec[C]()
[out]
def primitive():
    r0 :: object
    r1 :: ptr
    r2 :: vec[str]
L0:
    r0 = load_address PyUnicode_Type
    r1 = r0
    r2 = VecTApi.alloc(0, r1)
    return r2
def native_class():
    r0 :: object
    r1 :: ptr
    r2 :: vec[__main__.C]
L0:
    r0 = __main__.C :: type
    r1 = r0
    r2 = VecTApi.alloc(0, r1)
    return r2

[case testVecTAppend]
from vecs import vec, append

def f(v: vec[str]) -> vec[str]:
    return append(v, 'x')
[out]
def f(v):
    v :: vec[str]
    r0 :: str
    r1 :: vec[str]
L0:
    r0 = 'x'
    r1 = VecTApi.append(v, r0)
    return r1

[case testVecTOptionalCreateEmpty]
from vecs import vec, append
from typing import Optional

class C: pass

def primitive() -> vec[Optional[str]]:
    return vec[Optional[str]]()

def native_class() -> vec[Optional[C]]:
    return vec[Optional[C]]()
[out]
def primitive():
    r0 :: object
    r1, r2 :: ptr
    r3 :: vec[union[str, None]]
L0:
    r0 = load_address PyUnicode_Type
    r1 = r0
    r2 = r1 | 1
    r3 = VecTApi.alloc(0, r2)
    return r3
def native_class():
    r0 :: object
    r1, r2 :: ptr
    r3 :: vec[union[__main__.C, None]]
L0:
    r0 = __main__.C :: type
    r1 = r0
    r2 = r1 | 1
    r3 = VecTApi.alloc(0, r2)
    return r3

[case testVecTOptionalAppend]
from vecs import vec, append
from typing import Optional

def f(v: vec[Optional[str]]) -> vec[Optional[str]]:
    v = append(v, 'x')
    return append(v, None)
[out]
def f(v):
    v :: vec[union[str, None]]
    r0 :: str
    r1 :: vec[union[str, None]]
    r2 :: object
    r3 :: vec[union[str, None]]
L0:
    r0 = 'x'
    r1 = VecTApi.append(v, r0)
    v = r1
    r2 = box(None, 1)
    r3 = VecTApi.append(v, r2)
    return r3

[case testVecNestedCreateEmpty]
from vecs import vec, append
from mypy_extensions import i64

def f() -> vec[vec[str]]:
    return vec[vec[str]]()

def g() -> vec[vec[i64]]:
    return vec[vec[i64]]()
[out]
def f():
    r0 :: object
    r1 :: ptr
    r2 :: vec[vec[str]]
L0:
    r0 = load_address PyUnicode_Type
    r1 = r0
    r2 = VecTExtApi.alloc(0, r1, 0, 1)
    return r2
def g():
    r0 :: vec[vec[int64]]
L0:
    r0 = VecTExtApi.alloc(0, 2, 0, 1)
    return r0

[case testVecTLen]
from vecs import vec
from mypy_extensions import i64
from typing import Optional

def f(v: vec[str]) -> i64:
    return len(v)

def g(v: vec[Optional[str]]) -> i64:
    return len(v)
[out]
def f(v):
    v :: vec[str]
    r0 :: native_int
L0:
    r0 = v.len
    return r0
def g(v):
    v :: vec[union[str, None]]
    r0 :: native_int
L0:
    r0 = v.len
    return r0

[case testVecTGetItem]
from vecs import vec
from mypy_extensions import i64

def f(v: vec[str], n: i64) -> str:
    return v[n]
[out]
def f(v, n):
    v :: vec[str]
    n :: int64
    r0 :: native_int
    r1 :: bit
    r2 :: bool
    r3 :: object
    r4 :: ptr
    r5 :: int64
    r6 :: ptr
    r7 :: str
L0:
    r0 = v.len
    r1 = n < r0 :: unsigned
    if r1 goto L2 else goto L1 :: bool
L1:
    r2 = raise IndexError
    unreachable
L2:
    r3 = v.buf
    r4 = get_element_ptr r3 items :: VecbufTObject
    r5 = n * 8
    r6 = r4 + r5
    r7 = load_mem r6 :: builtins.str*
    keep_alive v
    return r7

[case testVecTOptionalGetItem]
from vecs import vec
from mypy_extensions import i64
from typing import Optional

def f(v: vec[Optional[str]], n: i64) -> Optional[str]:
    return v[n]
[out]
def f(v, n):
    v :: vec[union[str, None]]
    n :: int64
    r0 :: native_int
    r1 :: bit
    r2 :: bool
    r3 :: object
    r4 :: ptr
    r5 :: int64
    r6 :: ptr
    r7 :: union[str, None]
L0:
    r0 = v.len
    r1 = n < r0 :: unsigned
    if r1 goto L2 else goto L1 :: bool
L1:
    r2 = raise IndexError
    unreachable
L2:
    r3 = v.buf
    r4 = get_element_ptr r3 items :: VecbufTObject
    r5 = n * 8
    r6 = r4 + r5
    r7 = load_mem r6 :: union*
    keep_alive v
    return r7

[case testVecNestedAppend]
from vecs import vec, append

def f(v: vec[vec[str]], vv: vec[str]) -> vec[vec[str]]:
    return append(v, vv)
[out]
def f(v, vv):
    v :: vec[vec[str]]
    vv :: vec[str]
    r0 :: native_int
    r1 :: object
    r2, r3 :: VecbufTExtItem{len:native_int, buf:object_nrc}
    r4 :: vec[vec[str]]
L0:
    r0 = vv.len
    r1 = vv.buf
    r2 = set_element undef, len, r0
    r3 = set_element r2, buf, r1
    r4 = VecTExtApi.append(v, r3)
    keep_alive vv
    return r4

[case testVecNestedVecI64Append]
from vecs import vec, append
from mypy_extensions import i64

def f(v: vec[vec[i64]], vv: vec[i64]) -> vec[vec[i64]]:
    return append(v, vv)
[out]
def f(v, vv):
    v :: vec[vec[int64]]
    vv :: vec[int64]
    r0 :: native_int
    r1 :: object
    r2, r3 :: VecbufTExtItem{len:native_int, buf:object_nrc}
    r4 :: vec[vec[int64]]
L0:
    r0 = vv.len
    r1 = vv.buf
    r2 = set_element undef, len, r0
    r3 = set_element r2, buf, r1
    r4 = VecTExtApi.append(v, r3)
    keep_alive vv
    return r4

[case testVecNestedLen]
from vecs import vec
from mypy_extensions import i64
from typing import Optional

def f(v: vec[vec[str]]) -> i64:
    return len(v)

def g(v: vec[vec[i64]]) -> i64:
    return len(v)
[out]
def f(v):
    v :: vec[vec[str]]
    r0 :: native_int
L0:
    r0 = v.len
    return r0
def g(v):
    v :: vec[vec[int64]]
    r0 :: native_int
L0:
    r0 = v.len
    return r0

[case testVecNestedGetItem]
from vecs import vec
from mypy_extensions import i64

def f(v: vec[vec[str]], n: i64) -> vec[str]:
    return v[n]
[out]
def f(v, n):
    v :: vec[vec[str]]
    n :: int64
    r0 :: native_int
    r1 :: bit
    r2 :: bool
    r3 :: object
    r4 :: ptr
    r5 :: int64
    r6 :: ptr
    r7 :: vec[str]
L0:
    r0 = v.len
    r1 = n < r0 :: unsigned
    if r1 goto L2 else goto L1 :: bool
L1:
    r2 = raise IndexError
    unreachable
L2:
    r3 = v.buf
    r4 = get_element_ptr r3 items :: VecbufTExtObject
    r5 = n * 8
    r6 = r4 + r5
    r7 = load_mem r6 :: vec[str]*
    keep_alive v
    return r7

[case testVecNestedI64GetItem]
from vecs import vec
from mypy_extensions import i64

def f(v: vec[vec[i64]], n: i64) -> vec[i64]:
    return v[n]
[out]
def f(v, n):
    v :: vec[vec[int64]]
    n :: int64
    r0 :: native_int
    r1 :: bit
    r2 :: bool
    r3 :: object
    r4 :: ptr
    r5 :: int64
    r6 :: ptr
    r7 :: vec[int64]
L0:
    r0 = v.len
    r1 = n < r0 :: unsigned
    if r1 goto L2 else goto L1 :: bool
L1:
    r2 = raise IndexError
    unreachable
L2:
    r3 = v.buf
    r4 = get_element_ptr r3 items :: VecbufTExtObject
    r5 = n * 8
    r6 = r4 + r5
    r7 = load_mem r6 :: vec[int64]*
    keep_alive v
    return r7

[case testVecNestedI64GetItemWithBorrow]
from vecs import vec
from mypy_extensions import i64

def f(v: vec[vec[i64]], n: i64) -> i64:
    return v[n][n]
[out]
def f(v, n):
    v :: vec[vec[int64]]
    n :: int64
    r0 :: native_int
    r1 :: bit
    r2 :: bool
    r3 :: object
    r4 :: ptr
    r5 :: int64
    r6 :: ptr
    r7 :: vec[int64]
    r8 :: native_int
    r9 :: bit
    r10 :: bool
    r11 :: object
    r12 :: ptr
    r13 :: int64
    r14 :: ptr
    r15 :: int64
L0:
    r0 = v.len
    r1 = n < r0 :: unsigned
    if r1 goto L2 else goto L1 :: bool
L1:
    r2 = raise IndexError
    unreachable
L2:
    r3 = v.buf
    r4 = get_element_ptr r3 items :: VecbufTExtObject
    r5 = n * 8
    r6 = r4 + r5
    r7 = borrow load_mem r6 :: vec[int64]*
    r8 = r7.len
    r9 = n < r8 :: unsigned
    if r9 goto L4 else goto L3 :: bool
L3:
    r10 = raise IndexError
    unreachable
L4:
    r11 = r7.buf
    r12 = get_element_ptr r11 items :: VecbufI64Object
    r13 = n * 8
    r14 = r12 + r13
    r15 = load_mem r14 :: int64*
    keep_alive v, r7
    return r15

[case testVecDoublyNestedGetItem]
from vecs import vec
from mypy_extensions import i64

def f(v: vec[vec[vec[str]]], n: i64) -> vec[vec[str]]:
    return v[n]
[out]
def f(v, n):
    v :: vec[vec[vec[str]]]
    n :: int64
    r0 :: native_int
    r1 :: bit
    r2 :: bool
    r3 :: object
    r4 :: ptr
    r5 :: int64
    r6 :: ptr
    r7 :: vec[vec[str]]
L0:
    r0 = v.len
    r1 = n < r0 :: unsigned
    if r1 goto L2 else goto L1 :: bool
L1:
    r2 = raise IndexError
    unreachable
L2:
    r3 = v.buf
    r4 = get_element_ptr r3 items :: VecbufTExtObject
    r5 = n * 8
    r6 = r4 + r5
    r7 = load_mem r6 :: vec[vec[str]]*
    keep_alive v
    return r7

--
-- New repr
--

[case testNewVecI64CreateEmpty]
from vecs import vec, append
from mypy_extensions import i64

def f() -> vec[i64]:
    return vec[i64]()
[out]
def f():
    r0 :: vec[int64]
L0:
    r0 = VecI64Api.alloc(0)
    return r0

[case testNewVecI64Len]
from vecs import vec
from mypy_extensions import i64

def f(v: vec[i64]) -> i64:
    l = len(v)
    return l
[out]
def f(v):
    v :: vec[int64]
    r0 :: native_int
    l :: int64
L0:
    r0 = v.len
    l = r0
    return l

[case testNewVecI64GetItem]
from vecs import vec
from mypy_extensions import i64

def f(v: vec[i64], i: i64) -> i64:
    return v[i]
[out]
def f(v, i):
    v :: vec[int64]
    i :: int64
    r0 :: native_int
    r1 :: bit
    r2 :: bool
    r3 :: object
    r4 :: ptr
    r5 :: int64
    r6 :: ptr
    r7 :: int64
L0:
    r0 = v.len
    r1 = i < r0 :: unsigned
    if r1 goto L2 else goto L1 :: bool
L1:
    r2 = raise IndexError
    unreachable
L2:
    r3 = v.buf
    r4 = get_element_ptr r3 items :: VecbufI64Object
    r5 = i * 8
    r6 = r4 + r5
    r7 = load_mem r6 :: int64*
    keep_alive v
    return r7

[case testNewVecI64Append]
from vecs import vec, append
from mypy_extensions import i64

def f(v: vec[i64], i: i64) -> vec[i64]:
    return append(v, i)
[out]
def f(v, i):
    v :: vec[int64]
    i :: int64
    r0 :: vec[int64]
L0:
    r0 = VecI64Api.append(v, i)
    return r0

[case testNewVecI64SetItem]
from vecs import vec
from mypy_extensions import i64

def f(v: vec[i64], i: i64, x: i64) -> None:
    v[i] = x
[out]
def f(v, i, x):
    v :: vec[int64]
    i, x :: int64
    r0 :: native_int
    r1 :: bit
    r2 :: bool
    r3 :: object
    r4 :: ptr
    r5 :: int64
    r6 :: ptr
L0:
    r0 = v.len
    r1 = i < r0 :: unsigned
    if r1 goto L2 else goto L1 :: bool
L1:
    r2 = raise IndexError
    unreachable
L2:
    r3 = v.buf
    r4 = get_element_ptr r3 items :: VecbufI64Object
    r5 = i * 8
    r6 = r4 + r5
    set_mem r6, x :: int64*
    keep_alive v
    return 1

[case testNewVecI64ConstructFromListExpr]
from vecs import vec
from mypy_extensions import i64

def f() -> vec[i64]:
    return vec[i64]([1, 5, 14])
[out]
def f():
    r0 :: vec[int64]
    r1 :: object
    r2, r3, r4, r5 :: ptr
L0:
    r0 = VecI64Api.alloc(3)
    r1 = r0.buf
    r2 = get_element_ptr r1 items :: VecbufI64Object
    set_mem r2, 1 :: int64*
    r3 = r2 + 8
    set_mem r3, 5 :: int64*
    r4 = r3 + 8
    set_mem r4, 14 :: int64*
    r5 = r4 + 8
    keep_alive r0
    return r0

[case testNewVecI64ConstructFromListMultiply]
from vecs import vec
from mypy_extensions import i64

def f(n: i64) -> vec[i64]:
    return vec[i64]([3] * n)
[out]
def f(n):
    n :: int64
    r0 :: vec[int64]
    r1 :: object
    r2 :: ptr
    r3 :: int64
    r4, r5 :: ptr
    r6 :: bit
    r7 :: ptr
L0:
    r0 = VecI64Api.alloc(n)
    r1 = r0.buf
    r2 = get_element_ptr r1 items :: VecbufI64Object
    r3 = n * 8
    r4 = r2 + r3
    r5 = r2
L1:
    r6 = r5 < r4 :: unsigned
    if r6 goto L2 else goto L3 :: bool
L2:
    set_mem r5, 3 :: int64*
    r7 = r5 + 8
    r5 = r7
    goto L1
L3:
    keep_alive r0
    return r0

[case testNewVecI64ConstructFromListMultiply2]
from vecs import vec
from mypy_extensions import i64

def f(n: i64, x: i64) -> vec[i64]:
    return vec[i64]([x] * 3)
[out]
def f(n, x):
    n, x :: int64
    r0 :: vec[int64]
    r1 :: object
    r2 :: ptr
    r3 :: native_int
    r4, r5 :: ptr
    r6 :: bit
    r7 :: ptr
L0:
    r0 = VecI64Api.alloc(3)
    r1 = r0.buf
    r2 = get_element_ptr r1 items :: VecbufI64Object
    r3 = 3 * 8
    r4 = r2 + r3
    r5 = r2
L1:
    r6 = r5 < r4 :: unsigned
    if r6 goto L2 else goto L3 :: bool
L2:
    set_mem r5, x :: int64*
    r7 = r5 + 8
    r5 = r7
    goto L1
L3:
    keep_alive r0
    return r0

[case testNewVecI64ConstructFromListComprehension]
from vecs import vec
from mypy_extensions import i64

def f(n: i64) -> vec[i64]:
    return vec[i64]([x + 1 for x in range(i64(5))])
[out]
def f(n):
    n :: int64
    r0, r1 :: vec[int64]
    r2, x :: int64
    r3 :: bit
    r4 :: int64
    r5 :: vec[int64]
    r6 :: int64
L0:
    r0 = VecI64Api.alloc(0)
    r1 = r0
    r2 = 0
    x = r2
L1:
    r3 = r2 < 5 :: signed
    if r3 goto L2 else goto L4 :: bool
L2:
    r4 = x + 1
    r5 = VecI64Api.append(r1, r4)
    r1 = r5
L3:
    r6 = r2 + 1
    r2 = r6
    x = r6
    goto L1
L4:
    return r1

[case testNewVecI64ForLoop]
from vecs import vec
from mypy_extensions import i64

def f(v: vec[i64]) -> i64:
    t: i64 = 0
    for x in v:
        t += 1
    return t
[out]
def f(v):
    v :: vec[int64]
    t :: int64
    r0, r1 :: native_int
    r2 :: bit
    r3 :: object
    r4 :: ptr
    r5 :: native_int
    r6 :: ptr
    r7, x, r8 :: int64
    r9 :: native_int
L0:
    t = 0
    r0 = 0
L1:
    r1 = v.len
    r2 = r0 < r1 :: signed
    if r2 goto L2 else goto L4 :: bool
L2:
    r3 = v.buf
    r4 = get_element_ptr r3 items :: VecbufI64Object
    r5 = r0 * 8
    r6 = r4 + r5
    r7 = load_mem r6 :: int64*
    keep_alive v
    x = r7
    r8 = t + 1
    t = r8
L3:
    r9 = r0 + 1
    r0 = r9
    goto L1
L4:
    return t

[case testNewVecI64Contains]
from vecs import vec
from mypy_extensions import i64

def contains(v: vec[i64], n: i64) -> bool:
    return n in v
[out]
def contains(v, n):
    v :: vec[int64]
    n :: int64
    r0 :: native_int
    r1 :: object
    r2 :: ptr
    r3 :: native_int
    r4, r5 :: ptr
    r6 :: bit
    r7 :: int64
    r8 :: bit
    r9 :: ptr
    r10 :: bool
L0:
    r0 = v.len
    r1 = v.buf
    r2 = get_element_ptr r1 items :: VecbufI64Object
    r3 = r0 * 8
    r4 = r2 + r3
    r5 = r2
L1:
    r6 = r5 < r4 :: unsigned
    if r6 goto L2 else goto L4 :: bool
L2:
    r7 = load_mem r5 :: int64*
    r8 = r7 == n
    if r8 goto L5 else goto L3 :: bool
L3:
    r9 = r5 + 8
    r5 = r9
    goto L1
L4:
    keep_alive v
    r10 = 0
    goto L6
L5:
    r10 = 1
L6:
    return r10

[case testNewVecI64GetItemWithInt]
from vecs import vec
from mypy_extensions import i64

def f(v: vec[i64]) -> i64:
    return v[0]
[out]
def f(v):
    v :: vec[int64]
    r0 :: native_int
    r1 :: bit
    r2 :: bool
    r3 :: object
    r4 :: ptr
    r5 :: int64
    r6 :: ptr
    r7 :: int64
L0:
    r0 = v.len
    r1 = 0 < r0 :: unsigned
    if r1 goto L2 else goto L1 :: bool
L1:
    r2 = raise IndexError
    unreachable
L2:
    r3 = v.buf
    r4 = get_element_ptr r3 items :: VecbufI64Object
    r5 = 0 * 8
    r6 = r4 + r5
    r7 = load_mem r6 :: int64*
    keep_alive v
    return r7

[case testNewVecI64Slicing]
from vecs import vec
from mypy_extensions import i64

def f(v: vec[i64], n: i64, m: i64) -> None:
    a = v[:]
    b = v[n:]
    c = v[n:m]
    d = v[:m]
    e = v[1:-2]
[out]
def f(v, n, m):
    v :: vec[int64]
    n, m :: int64
    r0, a, r1, b, r2, c, r3, d, r4, e :: vec[int64]
L0:
    r0 = VecI64Api.slice(v, 0, 4611686018427387903)
    a = r0
    r1 = VecI64Api.slice(v, n, 4611686018427387903)
    b = r1
    r2 = VecI64Api.slice(v, n, m)
    c = r2
    r3 = VecI64Api.slice(v, 0, m)
    d = r3
    r4 = VecI64Api.slice(v, 1, -2)
    e = r4
    return 1

[case testNewVecI64Remove]
from vecs import vec, remove
from mypy_extensions import i64

def rem(v: vec[i64], n: i64) -> None:
    v = remove(v, n)
[out]
def rem(v, n):
    v :: vec[int64]
    n :: int64
    r0 :: vec[int64]
L0:
    r0 = VecI64Api.remove(v, n)
    v = r0
    return 1

[case testNewVecI64PopLast]
from typing import Tuple
from vecs import vec, pop
from mypy_extensions import i64

def pop_last(v: vec[i64]) -> Tuple[vec[i64], i64]:
    return pop(v)
[out]
def pop_last(v):
    v :: vec[int64]
    r0 :: tuple[vec[int64], int64]
L0:
    r0 = VecI64Api.pop(v, -1)
    return r0

[case testNewVecI64PopNth]
from typing import Tuple
from vecs import vec, pop
from mypy_extensions import i64

def pop_nth(v: vec[i64], n: i64) -> Tuple[vec[i64], i64]:
    return pop(v, n)
[out]
def pop_nth(v, n):
    v :: vec[int64]
    n :: int64
    r0 :: tuple[vec[int64], int64]
L0:
    r0 = VecI64Api.pop(v, n)
    return r0
