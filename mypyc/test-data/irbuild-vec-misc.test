-- Test cases for packed/specialized vec item types other than vec[i64], such as
-- vec[i32] and vec[float]. Since many of the code paths are the same as for
-- vec[i64], only test a subset of functionality.

[case testVecMiscCreateEmpty]
from vecs import vec

from mypy_extensions import i32, i16, u8

def create_float() -> vec[float]:
    return vec[float]()

def create_i32() -> vec[i32]:
    return vec[i32]()

def create_i16() -> vec[i16]:
    return vec[i16]()

def create_u8() -> vec[u8]:
    return vec[u8]()

def create_bool() -> vec[bool]:
    return vec[bool]()
[out]
def create_float():
    r0 :: vec[float]
L0:
    r0 = VecFloatApi.alloc(0, 0)
    return r0
def create_i32():
    r0 :: vec[i32]
L0:
    r0 = VecI32Api.alloc(0, 0)
    return r0
def create_i16():
    r0 :: vec[i16]
L0:
    r0 = VecI16Api.alloc(0, 0)
    return r0
def create_u8():
    r0 :: vec[u8]
L0:
    r0 = VecU8Api.alloc(0, 0)
    return r0
def create_bool():
    r0 :: vec[bool]
L0:
    r0 = VecBoolApi.alloc(0, 0)
    return r0

[case testVecMiscCreateFromList]
from vecs import vec, remove

from mypy_extensions import i64

def create_float() -> vec[float]:
    return vec[float]([1.5, 2.5])
[out]
def create_float():
    r0 :: vec[float]
    r1 :: object
    r2, r3, r4 :: ptr
L0:
    r0 = VecFloatApi.alloc(2, 2)
    r1 = r0.buf
    r2 = get_element_ptr r1 items :: VecFloatBufObject
    set_mem r2, 1.5 :: builtins.float*
    r3 = r2 + 8
    set_mem r3, 2.5 :: builtins.float*
    r4 = r3 + 8
    keep_alive r0
    return r0

[case testVecMiscAppend]
from vecs import vec, append

from mypy_extensions import i32

def append_float(v: vec[float]) -> vec[float]:
    return append(v, 1.5)

def append_i32(v: vec[i32]) -> vec[i32]:
    return append(v, 123)
[out]
def append_float(v):
    v, r0 :: vec[float]
L0:
    r0 = VecFloatApi.append(v, 1.5)
    return r0
def append_i32(v):
    v, r0 :: vec[i32]
L0:
    r0 = VecI32Api.append(v, 123)
    return r0

[case testVecMiscGetItem]
from vecs import vec

from mypy_extensions import i64

def get_item_float(v: vec[float], i: i64) -> float:
    return v[i]
[out]
def get_item_float(v, i):
    v :: vec[float]
    i :: i64
    r0 :: native_int
    r1 :: bit
    r2 :: i64
    r3 :: bit
    r4 :: bool
    r5 :: i64
    r6 :: object
    r7 :: ptr
    r8 :: i64
    r9 :: ptr
    r10 :: float
L0:
    r0 = v.len
    r1 = i < r0 :: unsigned
    if r1 goto L4 else goto L1 :: bool
L1:
    r2 = i + r0
    r3 = r2 < r0 :: unsigned
    if r3 goto L3 else goto L2 :: bool
L2:
    r4 = raise IndexError
    unreachable
L3:
    r5 = r2
    goto L5
L4:
    r5 = i
L5:
    r6 = v.buf
    r7 = get_element_ptr r6 items :: VecFloatBufObject
    r8 = r5 * 8
    r9 = r7 + r8
    r10 = load_mem r9 :: builtins.float*
    keep_alive v
    return r10

[case testVecMiscPop]
from vecs import vec, pop

from mypy_extensions import i64

def pop_float(v: vec[float], i: i64) -> float:
    v, x = pop(v)
    return x
[out]
def pop_float(v, i):
    v :: vec[float]
    i :: i64
    r0 :: tuple[vec[float], float]
    r1, r2 :: vec[float]
    r3, r4, x :: float
L0:
    r0 = VecFloatApi.pop(v, -1)
    r1 = borrow r0[0]
    r2 = unborrow r1
    v = r2
    r3 = borrow r0[1]
    r4 = unborrow r3
    x = r4
    keep_alive steal r0
    return x

[case testVecMiscRemove]
from vecs import vec, remove

def remove_float(v: vec[float]) -> vec[float]:
    return remove(v, 1.5)
[out]
def remove_float(v):
    v, r0 :: vec[float]
L0:
    r0 = VecTApi.remove(v, 1.5)
    return r0

[case testVecMiscSlice]
from vecs import vec, remove

from mypy_extensions import i64

def remove_float(v: vec[float], x: i64, y: i64) -> vec[float]:
    return v[x:y]
[out]
def remove_float(v, x, y):
    v :: vec[float]
    x, y :: i64
    r0 :: vec[float]
L0:
    r0 = VecFloatApi.slice(v, x, y)
    return r0

[case testVecMiscForLoop]
from vecs import vec, remove

from mypy_extensions import i64

def for_float(v: vec[float]) -> float:
    s = 0.0
    for x in v:
        s += x
    return s
[out]
def for_float(v):
    v :: vec[float]
    s :: float
    r0, r1 :: native_int
    r2 :: bit
    r3 :: object
    r4 :: ptr
    r5 :: native_int
    r6 :: ptr
    r7, x, r8 :: float
    r9 :: native_int
L0:
    s = 0.0
    r0 = 0
L1:
    r1 = v.len
    r2 = r0 < r1 :: signed
    if r2 goto L2 else goto L4 :: bool
L2:
    r3 = v.buf
    r4 = get_element_ptr r3 items :: VecFloatBufObject
    r5 = r0 * 8
    r6 = r4 + r5
    r7 = load_mem r6 :: builtins.float*
    keep_alive v
    x = r7
    r8 = s + x
    s = r8
L3:
    r9 = r0 + 1
    r0 = r9
    goto L1
L4:
    return s
