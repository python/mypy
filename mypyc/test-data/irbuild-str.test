[case testStrSplit]
from typing import Optional, List

def do_split(s: str, sep: Optional[str] = None, max_split: Optional[int] = None) -> List[str]:
    if sep is not None:
        if max_split is not None:
            return s.split(sep, max_split)
        else:
            return s.split(sep)
    return s.split()
[out]
def do_split(s, sep, max_split):
    s :: str
    sep :: union[str, None]
    max_split :: union[int, None]
    r0, r1, r2 :: object
    r3 :: bit
    r4 :: object
    r5 :: bit
    r6 :: str
    r7 :: int
    r8 :: list
    r9 :: str
    r10, r11 :: list
L0:
    if is_error(sep) goto L1 else goto L2
L1:
    r0 = box(None, 1)
    sep = r0
L2:
    if is_error(max_split) goto L3 else goto L4
L3:
    r1 = box(None, 1)
    max_split = r1
L4:
    r2 = load_address _Py_NoneStruct
    r3 = sep != r2
    if r3 goto L5 else goto L9 :: bool
L5:
    r4 = load_address _Py_NoneStruct
    r5 = max_split != r4
    if r5 goto L6 else goto L7 :: bool
L6:
    r6 = cast(str, sep)
    r7 = unbox(int, max_split)
    r8 = CPyStr_Split(s, r6, r7)
    return r8
L7:
    r9 = cast(str, sep)
    r10 = PyUnicode_Split(s, r9, -1)
    return r10
L8:
L9:
    r11 = PyUnicode_Split(s, 0, -1)
    return r11


[case testStrEquality]
def eq(x: str, y: str) -> bool:
    return x == y

def neq(x: str, y: str) -> bool:
    return x != y

[out]
def eq(x, y):
    x, y :: str
    r0 :: i32
    r1 :: bit
    r2 :: object
    r3, r4, r5 :: bit
L0:
    r0 = PyUnicode_Compare(x, y)
    r1 = r0 == -1
    if r1 goto L1 else goto L3 :: bool
L1:
    r2 = PyErr_Occurred()
    r3 = r2 != 0
    if r3 goto L2 else goto L3 :: bool
L2:
    r4 = CPy_KeepPropagating()
L3:
    r5 = r0 == 0
    return r5
def neq(x, y):
    x, y :: str
    r0 :: i32
    r1 :: bit
    r2 :: object
    r3, r4, r5 :: bit
L0:
    r0 = PyUnicode_Compare(x, y)
    r1 = r0 == -1
    if r1 goto L1 else goto L3 :: bool
L1:
    r2 = PyErr_Occurred()
    r3 = r2 != 0
    if r3 goto L2 else goto L3 :: bool
L2:
    r4 = CPy_KeepPropagating()
L3:
    r5 = r0 != 0
    return r5

[case testStrReplace]
from typing import Optional

def do_replace(s: str, old_substr: str, new_substr: str, max_count: Optional[int] = None) -> str:
    if max_count is not None:
        return s.replace(old_substr, new_substr, max_count)
    else:
        return s.replace(old_substr, new_substr)
[out]
def do_replace(s, old_substr, new_substr, max_count):
    s, old_substr, new_substr :: str
    max_count :: union[int, None]
    r0, r1 :: object
    r2 :: bit
    r3 :: int
    r4, r5 :: str
L0:
    if is_error(max_count) goto L1 else goto L2
L1:
    r0 = box(None, 1)
    max_count = r0
L2:
    r1 = load_address _Py_NoneStruct
    r2 = max_count != r1
    if r2 goto L3 else goto L4 :: bool
L3:
    r3 = unbox(int, max_count)
    r4 = CPyStr_Replace(s, old_substr, new_substr, r3)
    return r4
L4:
    r5 = PyUnicode_Replace(s, old_substr, new_substr, -1)
    return r5
L5:
    unreachable

[case testStrToBool]
def is_true(x: str) -> bool:
    if x:
        return True
    else:
        return False
[out]
def is_true(x):
    x :: str
    r0 :: bit
L0:
    r0 = CPyStr_IsTrue(x)
    if r0 goto L1 else goto L2 :: bool
L1:
    return 1
L2:
    return 0
L3:
    unreachable

[case testStringFormatMethod]
def f(s: str, num: int) -> None:
    s1 = "Hi! I'm {}, and I'm {} years old.".format(s, num)
    s2 = ''.format()
    s3 = 'abc'.format()
    s4 = '}}{}{{{}}}{{{}'.format(num, num, num)
[out]
def f(s, num):
    s :: str
    num :: int
    r0, r1, r2, r3, r4, s1, r5, s2, r6, s3, r7, r8, r9, r10, r11, r12, r13, s4 :: str
L0:
    r0 = CPyTagged_Str(num)
    r1 = "Hi! I'm "
    r2 = ", and I'm "
    r3 = ' years old.'
    r4 = CPyStr_Build(5, r1, s, r2, r0, r3)
    s1 = r4
    r5 = ''
    s2 = r5
    r6 = 'abc'
    s3 = r6
    r7 = CPyTagged_Str(num)
    r8 = CPyTagged_Str(num)
    r9 = CPyTagged_Str(num)
    r10 = '}'
    r11 = '{'
    r12 = '}{'
    r13 = CPyStr_Build(6, r10, r7, r11, r8, r12, r9)
    s4 = r13
    return 1

[case testFStrings]
def f(var: str, num: int) -> None:
    s1 = f"Hi! I'm {var}. I am {num} years old."
    s2 = f'Hello {var:>{num}}'
    s3 = f''
    s4 = f'abc'
[out]
def f(var, num):
    var :: str
    num :: int
    r0, r1, r2, r3, r4, s1, r5, r6, r7, r8, r9, r10, r11 :: str
    r12 :: object
    r13 :: str
    r14 :: list
    r15 :: ptr
    r16, s2, r17, s3, r18, s4 :: str
L0:
    r0 = "Hi! I'm "
    r1 = '. I am '
    r2 = CPyTagged_Str(num)
    r3 = ' years old.'
    r4 = CPyStr_Build(5, r0, var, r1, r2, r3)
    s1 = r4
    r5 = ''
    r6 = 'Hello '
    r7 = '{:{}}'
    r8 = '>'
    r9 = CPyTagged_Str(num)
    r10 = CPyStr_Build(2, r8, r9)
    r11 = 'format'
    r12 = CPyObject_CallMethodObjArgs(r7, r11, var, r10, 0)
    r13 = cast(str, r12)
    r14 = PyList_New(2)
    r15 = list_items r14
    buf_init_item r15, 0, r6
    buf_init_item r15, 1, r13
    keep_alive r14
    r16 = PyUnicode_Join(r5, r14)
    s2 = r16
    r17 = ''
    s3 = r17
    r18 = 'abc'
    s4 = r18
    return 1

[case testStringFormattingCStyle]
def f(var: str, num: int) -> None:
    s1 = "Hi! I'm %s." % var
    s2 = "I am %d years old." % num
    s3 = "Hi! I'm %s. I am %d years old." % (var, num)
    s4 = "Float: %f" % num
[typing fixtures/typing-full.pyi]
[out]
def f(var, num):
    var :: str
    num :: int
    r0, r1, r2, s1, r3, r4, r5, r6, s2, r7, r8, r9, r10, r11, s3, r12 :: str
    r13, r14 :: object
    r15, s4 :: str
L0:
    r0 = "Hi! I'm "
    r1 = '.'
    r2 = CPyStr_Build(3, r0, var, r1)
    s1 = r2
    r3 = CPyTagged_Str(num)
    r4 = 'I am '
    r5 = ' years old.'
    r6 = CPyStr_Build(3, r4, r3, r5)
    s2 = r6
    r7 = CPyTagged_Str(num)
    r8 = "Hi! I'm "
    r9 = '. I am '
    r10 = ' years old.'
    r11 = CPyStr_Build(5, r8, var, r9, r7, r10)
    s3 = r11
    r12 = 'Float: %f'
    r13 = box(int, num)
    r14 = PyNumber_Remainder(r12, r13)
    r15 = cast(str, r14)
    s4 = r15
    return 1

[case testDecode]
def f(b: bytes) -> None:
    b.decode()
    b.decode('utf-8')
    b.decode('utf-8', 'backslashreplace')
[out]
def f(b):
    b :: bytes
    r0, r1, r2, r3, r4, r5 :: str
L0:
    r0 = CPy_Decode(b, 0, 0)
    r1 = 'utf-8'
    r2 = CPy_Decode(b, r1, 0)
    r3 = 'utf-8'
    r4 = 'backslashreplace'
    r5 = CPy_Decode(b, r3, r4)
    return 1

[case testEncode]
def f(s: str) -> None:
    s.encode()
    s.encode('utf-8')
    s.encode('utf8', 'strict')
    s.encode('latin1', errors='strict')
    s.encode(encoding='ascii')
    s.encode(errors='strict', encoding='latin-1')
    s.encode('utf-8', 'backslashreplace')
    s.encode('ascii', 'backslashreplace')
    encoding = 'utf8'
    s.encode(encoding)
    errors = 'strict'
    s.encode('utf8', errors)
    s.encode('utf8', errors=errors)
    s.encode(errors=errors)
    s.encode(encoding=encoding, errors=errors)
    s.encode('latin2')

[out]
def f(s):
    s :: str
    r0, r1, r2, r3, r4, r5 :: bytes
    r6, r7 :: str
    r8 :: bytes
    r9, r10 :: str
    r11 :: bytes
    r12, encoding :: str
    r13 :: bytes
    r14, errors, r15 :: str
    r16 :: bytes
    r17, r18 :: str
    r19 :: object
    r20 :: str
    r21 :: tuple
    r22 :: dict
    r23 :: object
    r24 :: str
    r25 :: object
    r26 :: str
    r27 :: tuple
    r28 :: dict
    r29 :: object
    r30 :: str
    r31 :: object
    r32, r33 :: str
    r34 :: tuple
    r35 :: dict
    r36 :: object
    r37 :: str
    r38 :: bytes
L0:
    r0 = PyUnicode_AsUTF8String(s)
    r1 = PyUnicode_AsUTF8String(s)
    r2 = PyUnicode_AsUTF8String(s)
    r3 = PyUnicode_AsLatin1String(s)
    r4 = PyUnicode_AsASCIIString(s)
    r5 = PyUnicode_AsLatin1String(s)
    r6 = 'utf-8'
    r7 = 'backslashreplace'
    r8 = CPy_Encode(s, r6, r7)
    r9 = 'ascii'
    r10 = 'backslashreplace'
    r11 = CPy_Encode(s, r9, r10)
    r12 = 'utf8'
    encoding = r12
    r13 = CPy_Encode(s, encoding, 0)
    r14 = 'strict'
    errors = r14
    r15 = 'utf8'
    r16 = CPy_Encode(s, r15, errors)
    r17 = 'utf8'
    r18 = 'encode'
    r19 = CPyObject_GetAttr(s, r18)
    r20 = 'errors'
    r21 = PyTuple_Pack(1, r17)
    r22 = CPyDict_Build(1, r20, errors)
    r23 = PyObject_Call(r19, r21, r22)
    r24 = 'encode'
    r25 = CPyObject_GetAttr(s, r24)
    r26 = 'errors'
    r27 = PyTuple_Pack(0)
    r28 = CPyDict_Build(1, r26, errors)
    r29 = PyObject_Call(r25, r27, r28)
    r30 = 'encode'
    r31 = CPyObject_GetAttr(s, r30)
    r32 = 'encoding'
    r33 = 'errors'
    r34 = PyTuple_Pack(0)
    r35 = CPyDict_Build(2, r32, encoding, r33, errors)
    r36 = PyObject_Call(r31, r34, r35)
    r37 = 'latin2'
    r38 = CPy_Encode(s, r37, 0)
    return 1

[case testOrd]
def str_ord(x: str) -> int:
    return ord(x)
def str_ord_literal() -> int:
    return ord("a")
def bytes_ord(x: bytes) -> int:
    return ord(x)
def bytes_ord_literal() -> int:
    return ord(b"a")
def any_ord(x) -> int:
    return ord(x)
[out]
def str_ord(x):
    x :: str
    r0 :: int
L0:
    r0 = CPyStr_Ord(x)
    return r0
def str_ord_literal():
L0:
    return 194
def bytes_ord(x):
    x :: bytes
    r0 :: int
L0:
    r0 = CPyBytes_Ord(x)
    return r0
def bytes_ord_literal():
L0:
    return 194
def any_ord(x):
    x, r0 :: object
    r1 :: str
    r2, r3 :: object
    r4 :: int
L0:
    r0 = builtins :: module
    r1 = 'ord'
    r2 = CPyObject_GetAttr(r0, r1)
    r3 = PyObject_CallFunctionObjArgs(r2, x, 0)
    r4 = unbox(int, r3)
    return r4
